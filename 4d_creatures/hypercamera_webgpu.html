<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGPU Hypercamera Renderer</title>
<style>
body {
  margin: 0;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}
canvas {
  border: 2px solid #444;
  background: #000;
  max-width: 100%;
}
.controls {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  align-items: center;
}
.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
label {
  font-size: 12px;
  color: #aaa;
}
input[type="range"] {
  width: 150px;
}
.info {
  font-size: 14px;
  color: #888;
  text-align: center;
}
</style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<div class="info">WebGPU Hypercamera Renderer</div>

<script>

const VOX = 64; // Voxel grid size

const canvas = document.getElementById('canvas');

// 4D transform class prototype
class Vector4D {
    constructor(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    add(v) {
        return new Vector4D(this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w);
    }
    subtract(v) {
        return new Vector4D(this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w);
    }
    normalize() {
        let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        if (mag === 0) return new Vector4D(0, 0, 0, 0);
        return new Vector4D(this.x / mag, this.y / mag, this.z / mag, this.w / mag);
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    multiply_by_scalar(s) {
        return new Vector4D(this.x * s, this.y * s, this.z * s, this.w * s);
    }
}
class Transform4D {
    // constructor() {
    //     this.matrix = [
    //         [1, 0, 0, 0, 0],
    //         [0, 1, 0, 0, 0],
    //         [0, 0, 1, 0, 0],
    //         [0, 0, 0, 1, 0],
    //         [0, 0, 0, 0, 1]
    //     ];
    // }
    constructor(matrix) {
        this.matrix = matrix;
    }

    origin() {
        return new Vector4D(this.matrix[0][4], this.matrix[1][4], this.matrix[2][4], this.matrix[3][4]);
    }

    // transform_point(v: Vector4D): Vector4D
    transform_point(v) {
        let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w + this.matrix[0][4];
        let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w + this.matrix[1][4];
        let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w + this.matrix[2][4];
        let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w + this.matrix[3][4];
        return new Vector4D(x, y, z, w);
    }

    transform_vector(v) {
        let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w;
        let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w;
        let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w;
        let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w;
        return new Vector4D(x, y, z, w);
    }

    transform_transform(T) {
        // matrix multiplication: this.matrix * T.matrix
        // inC_T_B * inB_T_A  -> inC_T_A
        // inC_T_B.transform_transform(inB_T_A) -> inC_T_A
        let Tl = this.matrix;
        let Tr = T.matrix;
        let Tn = [
            [
                Tl[0][0] * Tr[0][0] + Tl[0][1] * Tr[1][0] + Tl[0][2] * Tr[2][0] + Tl[0][3] * Tr[3][0],
                Tl[0][0] * Tr[0][1] + Tl[0][1] * Tr[1][1] + Tl[0][2] * Tr[2][1] + Tl[0][3] * Tr[3][1],
                Tl[0][0] * Tr[0][2] + Tl[0][1] * Tr[1][2] + Tl[0][2] * Tr[2][2] + Tl[0][3] * Tr[3][2],
                Tl[0][0] * Tr[0][3] + Tl[0][1] * Tr[1][3] + Tl[0][2] * Tr[2][3] + Tl[0][3] * Tr[3][3],
                Tl[0][0] * Tr[0][4] + Tl[0][1] * Tr[1][4] + Tl[0][2] * Tr[2][4] + Tl[0][3] * Tr[3][4] + Tl[0][4]
            ],
            [
                Tl[1][0] * Tr[0][0] + Tl[1][1] * Tr[1][0] + Tl[1][2] * Tr[2][0] + Tl[1][3] * Tr[3][0],
                Tl[1][0] * Tr[0][1] + Tl[1][1] * Tr[1][1] + Tl[1][2] * Tr[2][1] + Tl[1][3] * Tr[3][1],
                Tl[1][0] * Tr[0][2] + Tl[1][1] * Tr[1][2] + Tl[1][2] * Tr[2][2] + Tl[1][3] * Tr[3][2],
                Tl[1][0] * Tr[0][3] + Tl[1][1] * Tr[1][3] + Tl[1][2] * Tr[2][3] + Tl[1][3] * Tr[3][3],
                Tl[1][0] * Tr[0][4] + Tl[1][1] * Tr[1][4] + Tl[1][2] * Tr[2][4] + Tl[1][3] * Tr[3][4] + Tl[1][4]
            ],
            [
                Tl[2][0] * Tr[0][0] + Tl[2][1] * Tr[1][0] + Tl[2][2] * Tr[2][0] + Tl[2][3] * Tr[3][0],
                Tl[2][0] * Tr[0][1] + Tl[2][1] * Tr[1][1] + Tl[2][2] * Tr[2][1] + Tl[2][3] * Tr[3][1],
                Tl[2][0] * Tr[0][2] + Tl[2][1] * Tr[1][2] + Tl[2][2] * Tr[2][2] + Tl[2][3] * Tr[3][2],
                Tl[2][0] * Tr[0][3] + Tl[2][1] * Tr[1][3] + Tl[2][2] * Tr[2][3] + Tl[2][3] * Tr[3][3],
                Tl[2][0] * Tr[0][4] + Tl[2][1] * Tr[1][4] + Tl[2][2] * Tr[2][4] + Tl[2][3] * Tr[3][4] + Tl[2][4]
            ],
            [
                Tl[3][0] * Tr[0][0] + Tl[3][1] * Tr[1][0] + Tl[3][2] * Tr[2][0] + Tl[3][3] * Tr[3][0],
                Tl[3][0] * Tr[0][1] + Tl[3][1] * Tr[1][1] + Tl[3][2] * Tr[2][1] + Tl[3][3] * Tr[3][1],
                Tl[3][0] * Tr[0][2] + Tl[3][1] * Tr[1][2] + Tl[3][2] * Tr[2][2] + Tl[3][3] * Tr[3][2],
                Tl[3][0] * Tr[0][3] + Tl[3][1] * Tr[1][3] + Tl[3][2] * Tr[2][3] + Tl[3][3] * Tr[3][3],
                Tl[3][0] * Tr[0][4] + Tl[3][1] * Tr[1][4] + Tl[3][2] * Tr[2][4] + Tl[3][3] * Tr[3][4] + Tl[3][4]
            ],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(Tn);
    }


    translate_self_by_delta(dx, dy, dz, dw, is_in_own_frame) {
        if (is_in_own_frame) {
            // translation in own frame
            let delta_in_parent = this.transform_vector(new Vector4D(dx, dy, dz, dw));
            this.matrix[0][4] += delta_in_parent.x;
            this.matrix[1][4] += delta_in_parent.y;
            this.matrix[2][4] += delta_in_parent.z;
            this.matrix[3][4] += delta_in_parent.w;
        } else {
            // translation in parent frame
            this.matrix[0][4] += dx;
            this.matrix[1][4] += dy;
            this.matrix[2][4] += dz;
            this.matrix[3][4] += dw;
        }
    }

    rotate_self_by_delta(plane_string, angle_rad, is_in_own_frame) {
        // plane string: 'XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'
        let c = Math.cos(angle_rad);
        let s = Math.sin(angle_rad);
        let R = [
            [1, 0, 0, 0,  0],
            [0, 1, 0, 0,  0],
            [0, 0, 1, 0,  0],
            [0, 0, 0, 1,  0],

            [0, 0, 0, 0,  1]
        ];
        switch (plane_string) {
            case 'XY':
                R[0][0] = c; R[0][1] = -s;
                R[1][0] = s; R[1][1] = c;
                break;
            case 'XZ':
                R[0][0] = c; R[0][2] = -s;
                R[2][0] = s; R[2][2] = c;
                break;
            case 'XW':
                R[0][0] = c; R[0][3] = -s;
                R[3][0] = s; R[3][3] = c;
                break;
            case 'YZ':
                R[1][1] = c; R[1][2] = -s;
                R[2][1] = s; R[2][2] = c;
                break;
            case 'YW':
                R[1][1] = c; R[1][3] = -s;
                R[3][1] = s; R[3][3] = c;
                break;
            case 'ZW':
                R[2][2] = c; R[2][3] = -s;
                R[3][2] = s; R[3][3] = c;
                break;
            default:
                console.error('Invalid plane string for rotation');
                return;
        }
        // let newT = this.transform_transform(new Transform4D(R));
        // this.matrix = newT.matrix;
        let Rdelta = new Transform4D(R);
        if (is_in_own_frame) {
            // Apply rotation in own frame
            let newT = this.transform_transform(Rdelta);
            this.matrix = newT.matrix;
        } else {
            // Apply rotation in parent frame
            let newT = Rdelta.transform_transform(this);
            // this.matrix = newT.matrix;
            // only copy the rotation part, keep the translation part
            // without rotation_only, we rotate around the parent origin instead of our own origin
            this.matrix = [
                [newT.matrix[0][0], newT.matrix[0][1], newT.matrix[0][2], newT.matrix[0][3], this.matrix[0][4]],
                [newT.matrix[1][0], newT.matrix[1][1], newT.matrix[1][2], newT.matrix[1][3], this.matrix[1][4]],
                [newT.matrix[2][0], newT.matrix[2][1], newT.matrix[2][2], newT.matrix[2][3], this.matrix[2][4]],
                [newT.matrix[3][0], newT.matrix[3][1], newT.matrix[3][2], newT.matrix[3][3], this.matrix[3][4]],
                [0, 0, 0, 0, 1]
            ];
        }
    }
            

    

    rotation_only() {
        let R = [
            [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3], 0],
            [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3], 0],
            [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3], 0],
            [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3], 0],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(R);
    }

    inverse() {
        // separate rotation and translation
        let R = [
            [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3]],
            [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3]],
            [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3]],
            [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3]]
        ];
        let t = [
            this.matrix[0][4],
            this.matrix[1][4],
            this.matrix[2][4],
            this.matrix[3][4]
        ];
        // transpose rotation
        let R_inv = [
            [R[0][0], R[1][0], R[2][0], R[3][0]],
            [R[0][1], R[1][1], R[2][1], R[3][1]],
            [R[0][2], R[1][2], R[2][2], R[3][2]],
            [R[0][3], R[1][3], R[2][3], R[3][3]]
        ];
        // new translation
        let t_inv = [
            -(R_inv[0][0] * t[0] + R_inv[0][1] * t[1] + R_inv[0][2] * t[2] + R_inv[0][3] * t[3]),
            -(R_inv[1][0] * t[0] + R_inv[1][1] * t[1] + R_inv[1][2] * t[2] + R_inv[1][3] * t[3]),
            -(R_inv[2][0] * t[0] + R_inv[2][1] * t[1] + R_inv[2][2] * t[2] + R_inv[2][3] * t[3]),
            -(R_inv[3][0] * t[0] + R_inv[3][1] * t[1] + R_inv[3][2] * t[2] + R_inv[3][3] * t[3])
        ];
        // combine into new matrix
        let invMatrix = [
            [R_inv[0][0], R_inv[0][1], R_inv[0][2], R_inv[0][3], t_inv[0]],
            [R_inv[1][0], R_inv[1][1], R_inv[1][2], R_inv[1][3], t_inv[1]],
            [R_inv[2][0], R_inv[2][1], R_inv[2][2], R_inv[2][3], t_inv[2]],
            [R_inv[3][0], R_inv[3][1], R_inv[3][2], R_inv[3][3], t_inv[3]],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(invMatrix);
    }
}

// Hypercamera definition
let scene_bound = 10.0; // +10 means the scene goes from -10 to +10 in all dimensions
const hypercamera_height_above_ground = 1.0;
let hypercamera_T = new Transform4D([
    [1, 0, 0, 0, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 1, 0, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 1]
]); // hypercam in world
// let hf = 1.0; // hyper focal length
// let hypercamera_intrinsics = [
    // [hf, 0, 0, 0],
    // [0, hf, 0, 0],
    // [0, 0, hf, 0],
    // [0, 0, 0, 1]
// ]; // see TODO s , for now assume identity intrinsics
let hypercamera_sensor_size = 1
let hypercamera_sensor_uvl_range = [-1, 1, -1, 1, -1, 1]; // u_min, u_max, v_min, v_max, l_min, l_max
let hypercamera_is_unit_sensor = true;
let hypercamera_sensor_resolution = VOX;

// Define scene statically for now
class Hyperobject {
    constructor(vertices_in_object, edges, tetras, color, simulate_physics, show_vertices, mass, pose, name) {
        this.vertices_in_object = vertices_in_object; // in object frame
        this.edges = edges;
        this.tetras = tetras;
        this.color = color;
        this.simulate_physics = simulate_physics; // if true, object gets affected by physics
        this.show_vertices = show_vertices;
        this.mass = mass;
        this.pose = pose; // Transform4D from object frame to world frame
        this.name = name;
        // variables
        this.velocity_in_world = new Vector4D(0, 0, 0, 0);
        this.rotational_velocity = {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0};
        // computed properties
        this.update_vertices_in_world();
    }

    update_vertices_in_world() {
        this.vertices_in_world = [];
        for (let v of this.vertices_in_object) {
            let v_world = this.pose.transform_point(v);
            this.vertices_in_world.push(v_world);
        }
    }

    get_com() {
        return this.pose.origin();
    }
}


        // build a hyperfloor surface (triangle mesh)
        // 1. assign a z for each (x,y,w) grid point
        // 2. build triangles between grid points
        const GRID_LIMS = {
            x_min: -scene_bound,
            x_max: scene_bound,
            y_min: -scene_bound,
            y_max: scene_bound,
            z_min: -scene_bound,
            z_max: scene_bound,
            w_min: -scene_bound,
            w_max: scene_bound
        };
        const N_TILES = 10;
        const GRID_RES = 2 * scene_bound / N_TILES; // grid resolution
        const n_i = Math.floor((GRID_LIMS.x_max - GRID_LIMS.x_min) / GRID_RES) + 1;
        const n_j = Math.floor((GRID_LIMS.y_max - GRID_LIMS.y_min) / GRID_RES) + 1;
        const n_k = Math.floor((GRID_LIMS.w_max - GRID_LIMS.w_min) / GRID_RES) + 1;
        function floor_heightmap(x, y, w) {
            return 0 + x * 0.1;
        }
        let grid_vertices = [];
        let grid_edges = [];
        let grid_tetras = [];
        for (let i = 0; i < n_i; i++) {
            for (let j = 0; j < n_j; j++) {
                for (let k = 0; k < n_k; k++) {
                    let x = GRID_LIMS.x_min + i * GRID_RES;
                    let y = GRID_LIMS.y_min + j * GRID_RES;
                    let w = GRID_LIMS.w_min + k * GRID_RES;
                    // let z = Math.sin(0.2 * x) * Math.cos(0.2 * y) * 5; // example height function
                    let z = floor_heightmap(x, y, w);
                    grid_vertices.push(new Vector4D(x, y, z, w));
                    // add an edge to the next vertex in x
                    if (i < n_i - 1) {
                        let next_index = grid_vertices.length + (n_j * n_k) - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in y
                    if (j < n_j - 1) {
                        let next_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in w
                    if (k < n_k - 1) {
                        let next_index = grid_vertices.length;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge between next x and next y
                    if (i < n_i - 1 && j < n_j - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_y_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([next_x_index, next_y_index]);
                    }
                    // add an edge between next x and next w
                    if (i < n_i - 1 && k < n_k - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_x_index, next_w_index]);
                    }
                    // add an edge between next y and next w
                    if (j < n_j - 1 && k < n_k - 1) {
                        let next_y_index = grid_vertices.length + n_k - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_y_index, next_w_index]);
                    }
                    // add 5 tetras between this grid point and the next in x,y,w
                    if (i < n_i - 1 && j < n_j - 1 && k < n_k - 1) {
                        let nnn = i * n_j * n_k + j * n_k + k;
                        let pnn = (i + 1) * n_j * n_k + j * n_k + k;
                        let npn = i * n_j * n_k + (j + 1) * n_k + k;
                        let ppn = (i + 1) * n_j * n_k + (j + 1) * n_k + k;
                        let nnp = i * n_j * n_k + j * n_k + (k + 1);
                        let pnp = (i + 1) * n_j * n_k + j * n_k + (k + 1);
                        let npp = i * n_j * n_k + (j + 1) * n_k + (k + 1);
                        let ppp = (i + 1) * n_j * n_k + (j + 1) * n_k + (k + 1);
                        let cell_tetras = [
                            [pnn, nnn, ppn, pnp], // tet at corner p n n
                            [npn, ppn, nnn, npp], // tet at corner n p n
                            [nnp, pnp, npp, nnn], // tet at corner n n p
                            [ppp, npp, pnp, ppn], // tet at corner p p p
                            [nnn, ppn, npp, pnp]  // tet at center
                        ];
                        for (let tet of cell_tetras) { grid_tetras.push(tet); }
                    }
                }
            }
        }
        // create the class
        let hyperfloor = new Hyperobject(
            // vertices in object frame
            grid_vertices,
            // edges
            grid_edges,
            // tetras
            grid_tetras,
            // color
            0x000088,
            // simulate_physics
            false,
            // show_vertices
            false,
            // mass
            1.0,
            // pose (Transform4D)
            new Transform4D([
                [1, 0, 0, 0, 0],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ]),
            // name
            "Hyperfloor"
        );


        // define a hypercube object
        const OSZ = floor_heightmap(0, 0, 0) + 3.0; // object spawn z
        const const_hypercube_vertices = [ 
                new Vector4D(-1, -1, -1, -1),
                new Vector4D( 1, -1, -1, -1),
                new Vector4D( 1,  1, -1, -1),
                new Vector4D(-1,  1, -1, -1),
                new Vector4D(-1, -1,  1, -1),
                new Vector4D( 1, -1,  1, -1),
                new Vector4D( 1,  1,  1, -1),
                new Vector4D(-1,  1,  1, -1),
                new Vector4D(-1, -1, -1,  1),
                new Vector4D( 1, -1, -1,  1),
                new Vector4D( 1,  1, -1,  1),
                new Vector4D(-1,  1, -1,  1),
                new Vector4D(-1, -1,  1,  1),
                new Vector4D( 1, -1,  1,  1),
                new Vector4D( 1,  1,  1,  1),
                new Vector4D(-1,  1,  1,  1)
            ];
        // Tetrahedras
        function create_40_tetrahedra_tiling_of_hypercube(cube_vertices) {
            // cube_vertices need to all be -1 or 1 values (i.e. in unit cube coord system) for this to work!
            const p = 1.0;
            const n = -1.0;
            // for the 3D cube, these are the tetrahedra vertices
            // [[p, n, n], [n, n, n], [p, p, n], [p, n, p]], // tet at corner p n n
            // [[n, p, n], [p, p, n], [n, n, n], [n, p, p]], // tet at corner n p n
            // [[n, n, p], [p, n, p], [n, p, p], [n, n, n]], // tet at corner n n p
            // [[p, p, p], [n, p, p], [p, n, p], [p, p, n]], // tet at corner p p p
            // [[n, n, n], [p, p, n], [n, p, p], [p, n, p]]  // tet at center

            // to create 5 tet at each of the 8 cubes in the hypercube, we set one of the 4dims to either p or n and fill the remaining 3 with the above
            // for example if we tetrahedralize the cube at z = n, we set z = n and fill x=0, y=1, w=2 with the above
            // [[p, n, z, n], [n, n, z, n], [p, p, z, n], [p, n, z, p]]
            const xn = -1.0; // fixed x for this cube
            const xp = 1.0;  // fixed x for this cube
            const yn = -1.0; // fixed y for this cube
            const yp = 1.0;  // fixed y for this cube
            const zn = -1.0; // fixed z for this cube
            const zp = 1.0;  // fixed z for this cube
            const wn = -1.0; // fixed w for this cube
            const wp = 1.0;  // fixed w for this cube
            const tetrahedron_40_tiling_of_hypercube = [
                // cube at x = n
                [[xn, p, n, n], [xn, n, n, n], [xn, p, p, n], [xn, p, n, p]], // tet at corner p n n
                [[xn, n, p, n], [xn, p, p, n], [xn, n, n, n], [xn, n, p, p]], // tet at corner n p n
                [[xn, n, n, p], [xn, p, n, p], [xn, n, p, p], [xn, n, n, n]], // tet at corner n n p
                [[xn, p, p, p], [xn, n, p, p], [xn, p, n, p], [xn, p, p, n]], // tet at corner p p p
                [[xn, n, n, n], [xn, p, p, n], [xn, n, p, p], [xn, p, n, p]], // tet at center
                // cube at x = p
                [[xp, p, n, n], [xp, n, n, n], [xp, p, p, n], [xp, p, n, p]], // tet at corner p n n
                [[xp, n, p, n], [xp, p, p, n], [xp, n, n, n], [xp, n, p, p]], // tet at corner n p n
                [[xp, n, n, p], [xp, p, n, p], [xp, n, p, p], [xp, n, n, n]], // tet at corner n n p
                [[xp, p, p, p], [xp, n, p, p], [xp, p, n, p], [xp, p, p, n]], // tet at corner p p p
                [[xp, n, n, n], [xp, p, p, n], [xp, n, p, p], [xp, p, n, p]], // tet at center
                // cube at y = n
                [[p, yn, n, n], [n, yn, n, n], [p, yn, p, n], [p, yn, n, p]], // tet at corner p n n
                [[n, yn, p, n], [p, yn, p, n], [n, yn, n, n], [n, yn, p, p]], // tet at corner n p n
                [[n, yn, n, p], [p, yn, n, p], [n, yn, p, p], [n, yn, n, n]], // tet at corner n n p
                [[p, yn, p, p], [n, yn, p, p], [p, yn, n, p], [p, yn, p, n]], // tet at corner p p p
                [[n, yn, n, n], [p, yn, p, n], [n, yn, p, p], [p, yn, n, p]], // tet at center
                // cube at y = p
                [[p, yp, n, n], [n, yp, n, n], [p, yp, p, n], [p, yp, n, p]], // tet at corner p n n
                [[n, yp, p, n], [p, yp, p, n], [n, yp, n, n], [n, yp, p, p]], // tet at corner n p n
                [[n, yp, n, p], [p, yp, n, p], [n, yp, p, p], [n, yp, n, n]], // tet at corner n n p
                [[p, yp, p, p], [n, yp, p, p], [p, yp, n, p], [p, yp, p, n]], // tet at corner p p p
                [[n, yp, n, n], [p, yp, p, n], [n, yp, p, p], [p, yp, n, p]], // tet at center
                // cube at z = n
                [[p, n, zn, n], [n, n, zn, n], [p, p, zn, n], [p, n, zn, p]], // tet at corner p n n
                [[n, p, zn, n], [p, p, zn, n], [n, n, zn, n], [n, p, zn, p]], // tet at corner n p n
                [[n, n, zn, p], [p, n, zn, p], [n, p, zn, p], [n, n, zn, n]], // tet at corner n n p
                [[p, p, zn, p], [n, p, zn, p], [p, n, zn, p], [p, p, zn, n]], // tet at corner p p p
                [[n, n, zn, n], [p, p, zn, n], [n, p, zn, p], [p, n, zn, p]], // tet at center
                // cube at z = p 
                [[p, n, zp, n], [n, n, zp, n], [p, p, zp, n], [p, n, zp, p]], // tet at corner p n n
                [[n, p, zp, n], [p, p, zp, n], [n, n, zp, n], [n, p, zp, p]], // tet at corner n p n
                [[n, n, zp, p], [p, n, zp, p], [n, p, zp, p], [n, n, zp, n]], // tet at corner n n p
                [[p, p, zp, p], [n, p, zp, p], [p, n, zp, p], [p, p, zp, n]], // tet at corner p p p
                [[n, n, zp, n], [p, p, zp, n], [n, p, zp, p], [p, n, zp, p]], // tet at center
                // cube at w = n
                [[p, n, n, wn], [n, n, n, wn], [p, p, n, wn], [p, n, p, wn]], // tet at corner p n n
                [[n, p, n, wn], [p, p, n, wn], [n, n, n, wn], [n, p, p, wn]], // tet at corner n p n
                [[n, n, p, wn], [p, n, p, wn], [n, p, p, wn], [n, n, n, wn]], // tet at corner n n p
                [[p, p, p, wn], [n, p, p, wn], [p, n, p, wn], [p, p, n, wn]], // tet at corner p p p
                [[n, n, n, wn], [p, p, n, wn], [n, p, p, wn], [p, n, p, wn]], // tet at center
                // cube at w = p
                [[p, n, n, wp], [n, n, n, wp], [p, p, n, wp], [p, n, p, wp]], // tet at corner p n n
                [[n, p, n, wp], [p, p, n, wp], [n, n, n, wp], [n, p, p, wp]], // tet at corner n p n
                [[n, n, p, wp], [p, n, p, wp], [n, p, p, wp], [n, n, n, wp]], // tet at corner n n p
                [[p, p, p, wp], [n, p, p, wp], [p, n, p, wp], [p, p, n, wp]], // tet at corner p p p
                [[n, n, n, wp], [p, p, n, wp], [n, p, p, wp], [p, n, p, wp]]  // tet at center
            ];

            // convert to index
            let tetrahedra_indices = [];
            for (let tet of tetrahedron_40_tiling_of_hypercube) {
                let tet_indices = [];
                for (let v of tet) {
                    // find index in cube_vertices
                    for (let i = 0; i < cube_vertices.length; i++) {
                        let cv = cube_vertices[i];
                        if (cv.x === v[0] && cv.y === v[1] && cv.z === v[2] && cv.w === v[3]) {
                            tet_indices.push(i);
                            break;
                        }
                    }
                }
                if (tet_indices.length !== 4) {
                    console.error("Error creating tetrahedra indices");
                }
                tetrahedra_indices.push(tet_indices);
            }
            return tetrahedra_indices;
        }
        let hypercube = new Hyperobject(
            // vertices in object frame
            const_hypercube_vertices,
            // edges:
            [
                [0,1],[1,2],[2,3],[3,0],
                [4,5],[5,6],[6,7],[7,4],
                [0,4],[1,5],[2,6],[3,7],
                [8,9],[9,10],[10,11],[11,8],
                [12,13],[13,14],[14,15],[15,12],
                [8,12],[9,13],[10,14],[11,15],
                [0,8],[1,9],[2,10],[3,11],
                [4,12],[5,13],[6,14],[7,15]
            ],
            // tetras
            create_40_tetrahedra_tiling_of_hypercube(const_hypercube_vertices),
            // color
            0xff0000,
            // simulate_physics
            true,
            // show_vertices
            true,
            // mass
            1.0,
            // pose (Transform4D)
            new Transform4D([
                [1, 0, 0, 0, 4],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, OSZ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ]),
            // name
            "Hypercube"
        );


let hyperpyramid = new Hyperobject(
    // vertices in object frame
    [
        new Vector4D(0, 0, 1, 0),
        new Vector4D(1, 1, -1, 1),
        new Vector4D(1, -1, -1, -1),
        new Vector4D(-1, 1, -1, -1),
        new Vector4D(-1, -1, -1, 1)
    ],
    // edges
    [
        [0,1],[0,2],[0,3],[0,4],
        [1,2],[1,3],[1,4],
        [2,3],[2,4],
        [3,4]
    ],
    // tetras
    [
        [0,1,2,3],
        [0,1,2,4],
        [0,1,3,4],
        [0,2,3,4],
        [1,2,3,4]
    ],
    // color
    0x00ff00,
    // simulate_physics
    true,
    // show_vertices
    true,
    // mass
    1.0,
    // pose (Transform4D)
    new Transform4D([
        [1, 0, 0, 0, 4],
        [0, 1, 0, 0, 2],
        [0, 0, 1, 0, OSZ],
        [0, 0, 0, 1, 2],
        [0, 0, 0, 0, 1]
    ]),
    // name
    "Hyperpyramid"
);

// Check WebGPU support
if (!navigator.gpu) {
  document.body.innerHTML = '<div style="color: red; padding: 20px;">WebGPU is not supported in your browser.</div>';
  throw new Error('WebGPU not supported');
}

let timingsInfosHtml = "";

// Stage 0: Create buffers and gather all vertices and tetras from visible hyperobjects
const s0_start = performance.now();
let visibleHyperobjects = [hypercube, hyperpyramid, hyperfloor];

// let vertices_in_world = hypercube.vertices_in_world;
// let tetras = hypercube.tetras.map(tetra => ({ indices: tetra, color: hypercube.color }));
let vertices_in_world = [];
let tetras = [];
for (let obj of visibleHyperobjects) {
    const base_index = vertices_in_world.length;
    // add vertices
    for (let v of obj.vertices_in_world) {
        vertices_in_world.push(v);
    }
    // add tetras with adjusted indices
    for (let tet of obj.tetras) {
        tetras.push({ indices: tet.map(vi => vi + base_index), color: obj.color });
    }
}
const s0_end = performance.now();
console.log(`Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms</p>`;
        

// Create texture buffers
let object_texture_header_data = new Uint32Array(visibleHyperobjects.length * 4); // offset, USIZE, VSIZE, WSIZE
let vertices_texcoords_data = new Float32Array(vertices_in_world.length * 3); // u,v,l per vertex
// Create global texture data buffer and figure out offsets
let texture_data_offset = 0;
for (let obj_index = 0; obj_index < visibleHyperobjects.length; obj_index++) {
    let obj = visibleHyperobjects[obj_index];
    // for now fill all objects with 2x2x2 checkerboard texture
    // TODO: do this at object creation
    if (true) {
        let USIZE = 2; // for now fixed size
        let VSIZE = 2;
        let WSIZE = 2;
        let object_texture = new Uint32Array(USIZE * VSIZE * WSIZE); // RGBA
        let A_color = obj.color; // B is darker version of A
        let B_color = ((A_color & 0xFEFEFE) >> 1); // darker color
        for (let u = 0; u < USIZE; u++) {
            for (let v = 0; v < VSIZE; v++) {
                for (let w = 0; w < WSIZE; w++) {
                    // important to use the same indexing as in the shader!
                    let index = (u + (v * USIZE) + (w * USIZE * VSIZE)) * 4;
                    // checkerboard pattern
                    let is_A = ((u + v + w) % 2 === 0);
                    let color = is_A ? A_color : B_color;
                    // pack color into one u32 RGBA
                    let r_u8 = (color >> 16) & 0xFF;
                    let g_u8 = (color >> 8) & 0xFF;
                    let b_u8 = (color) & 0xFF;
                    let a_u8 = 255;
                    let rgba_u32 = (r_u8 << 24) | (g_u8 << 16) | (b_u8 << 8) | (a_u8);
                    object_texture[index] = rgba_u32;
                }
            }
        }
        obj.texture = object_texture; // store in object for now
        obj.texture_info = { USIZE: USIZE, VSIZE: VSIZE, WSIZE: WSIZE };
    }
    let USIZE = obj.texture_info.USIZE;
    let VSIZE = obj.texture_info.VSIZE;
    let WSIZE = obj.texture_info.WSIZE;
    // compute data size
    let data_size = USIZE * VSIZE * WSIZE; // RGBA
    // set header data
    object_texture_header_data[obj_index * 4 + 0] = texture_data_offset; // offset
    object_texture_header_data[obj_index * 4 + 1] = USIZE; // USIZE
    object_texture_header_data[obj_index * 4 + 2] = VSIZE; // VSIZE
    object_texture_header_data[obj_index * 4 + 3] = WSIZE; // WSIZE
    // update offsets
    texture_data_offset += data_size;
}
let total_texture_data_size = texture_data_offset;
// fill global texture data with object textures
let global_texture_data = new Uint32Array(total_texture_data_size);
for (let obj_index = 0; obj_index < visibleHyperobjects.length; obj_index++) {
    let obj = visibleHyperobjects[obj_index];
    let offset = object_texture_header_data[obj_index * 4 + 0];
    let USIZE = object_texture_header_data[obj_index * 4 + 1];
    let VSIZE = object_texture_header_data[obj_index * 4 + 2];
    let WSIZE = object_texture_header_data[obj_index * 4 + 3];
    for (let u = 0; u < USIZE; u++) {
        for (let v = 0; v < VSIZE; v++) {
            for (let w = 0; w < WSIZE; w++) {
                let index = (u + (v * USIZE) + (w * USIZE * VSIZE));
                let global_index = offset + index;
                let rgba_u32 = obj.texture[index];
                global_texture_data[global_index] = rgba_u32;
            }
        }
    }
}

// Create buffers with 1. all vertices in object frame, 2. all object poses 3. the object index of each vertex
let all_vertices_in_object_data = new Float32Array(vertices_in_world.length * 4);
let all_object_poses_data = new Float32Array(visibleHyperobjects.length * 5 * 5);
let vertex_object_indices_data = new Uint32Array(vertices_in_world.length);
let vertex_counter = 0;
for (let obj_index = 0; obj_index < visibleHyperobjects.length; obj_index++) {
    let obj = visibleHyperobjects[obj_index];
    // object poses
    let pose = obj.pose.matrix;
    for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            all_object_poses_data[obj_index * 5 * 5 + i * 5 + j] = pose[i][j];
        }
    }
    // vertices
    for (let v of obj.vertices_in_object) {
        all_vertices_in_object_data[vertex_counter * 4 + 0] = v.x;
        all_vertices_in_object_data[vertex_counter * 4 + 1] = v.y;
        all_vertices_in_object_data[vertex_counter * 4 + 2] = v.z;
        all_vertices_in_object_data[vertex_counter * 4 + 3] = v.w;
        vertex_object_indices_data[vertex_counter] = obj_index;
        // set texcoords for each vertex of this object
        // just map the object coordinates to the texture coordinates directly for now
        // TODO: assign these coords at object creation
        vertices_texcoords_data[vertex_counter * 3 + 0] = v.x;
        vertices_texcoords_data[vertex_counter * 3 + 1] = v.y;
        vertices_texcoords_data[vertex_counter * 3 + 2] = v.w;
        // increment counter
        vertex_counter++;
    }
}


// Initit Hypercamera Pose buffer
let hypercamera_inv_pose_data = new Float32Array(5 * 5);
let hc_pose = hypercamera_T.inverse().matrix;
for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        hypercamera_inv_pose_data[i * 5 + j] = hc_pose[i][j];
    }
}

// ---------------------------------------------------------------------------------
// Stage 1: Per-vertex - Transform vertices from world to camera space
const s1_start = performance.now();
let vertices_in_suvl = new Array(vertices_in_world.length);
let vertices_in_1uvl = new Array(vertices_in_world.length);
const camera_inverse = hypercamera_T.inverse();
function perVertex(vertex_index, vertices_in_world, vertices_in_suvl, vertices_in_1uvl) {
    const vert_suvl = camera_inverse.transform_point(vertices_in_world[vertex_index]);
    vertices_in_suvl[vertex_index] = vert_suvl;
    vertices_in_1uvl[vertex_index] = new Vector4D(1.0, vert_suvl.y / vert_suvl.x, vert_suvl.z / vert_suvl.x, vert_suvl.w / vert_suvl.x);
}
for (let vi = 0; vi < vertices_in_world.length; vi++) { perVertex(vi, vertices_in_world, vertices_in_suvl, vertices_in_1uvl); } // run the "shader"
const s1_end = performance.now();
console.log("Stage 1: # of vertices transformed to camera space:", vertices_in_world.length, `in ${(s1_end - s1_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 1: # of vertices transformed to camera space: ${vertices_in_world.length} in ${(s1_end - s1_start).toFixed(2)} ms</p>`;

// ---------------------------------------------------------------------------------
// Stage 2: (CPU) Per-tetra - Exclude tetras with any vertex behind camera
const s2_start = performance.now();
let valid_tetras = [];
function perTetra(tetra_index, tetras, vertices_in_suvl, valid_tetras) {
    let tetra = tetras[tetra_index];
    let behind_camera = false;
    for (let vi of tetra.indices) {
        if (vertices_in_suvl[vi].x <= 0) { // S coordinate
            behind_camera = true;
            break;
        }
    }
    if (!behind_camera) {
        valid_tetras.push(tetra);
    }
}
for (let ti = 0; ti < tetras.length; ti++) { perTetra(ti, tetras, vertices_in_suvl, valid_tetras); } // run the "shader"
const s2_end = performance.now();
console.log("Stage 2: # of valid tetras:", valid_tetras.length, `from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 2: # of valid tetras: ${valid_tetras.length} from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms</p>`;


const N_TETS = 5;

// Prepare tetra data
const tetraData = new Uint32Array(tetras.length * 5); // 4 vert idx per tet + 1 color
for (let i = 0; i < valid_tetras.length; i++) {
    const tetra = valid_tetras[i];
    tetraData[i * 5 + 0] = tetra.indices[0];
    tetraData[i * 5 + 1] = tetra.indices[1];
    tetraData[i * 5 + 2] = tetra.indices[2];
    tetraData[i * 5 + 3] = tetra.indices[3];
    tetraData[i * 5 + 4] = tetra.color;
}

// initialize vertex storage
const vertices1uvlstexData = new Float32Array(vertices_in_1uvl.length * 8);
for (let i = 0; i < vertices_in_1uvl.length; i++) {
  vertices1uvlstexData[i * 8 + 0] = vertices_in_1uvl[i].y;
  vertices1uvlstexData[i * 8 + 1] = vertices_in_1uvl[i].z;
  vertices1uvlstexData[i * 8 + 2] = vertices_in_1uvl[i].w;
  vertices1uvlstexData[i * 8 + 3] = vertices_in_suvl[i].x;
  vertices1uvlstexData[i * 8 + 4] = vertices_texcoords_data[i * 3 + 0];
  vertices1uvlstexData[i * 8 + 5] = vertices_texcoords_data[i * 3 + 1];
  vertices1uvlstexData[i * 8 + 6] = vertices_texcoords_data[i * 3 + 2];
  vertices1uvlstexData[i * 8 + 7] = 0.0; // padding
}

// initialize bvh
const TILE_SZ = 2;
const TILE_RES = VOX / TILE_SZ;
const MAX_ACCEL_STRUCTURE_DEPTH = 400;
const MAX_ACCEL_STRUCTURE_SIZE = TILE_RES*TILE_RES*TILE_RES*MAX_ACCEL_STRUCTURE_DEPTH;
const accelStructureOffsetsData = new Uint32Array(TILE_RES*TILE_RES*TILE_RES);
const accelStructureCountsData = new Uint32Array(TILE_RES*TILE_RES*TILE_RES);
const accelStructureTetraIndicesData = new Uint32Array(MAX_ACCEL_STRUCTURE_SIZE);
// for now we assign all 5 pyramid tetras to all voxels
// for (let i = 0; i < (TILE_RES*TILE_RES*TILE_RES); i++) {
//   const TU = i % TILE_RES;
//   const TV = Math.floor(i / TILE_RES) % TILE_RES;
//   const TL = Math.floor(i / (TILE_RES*TILE_RES)); 
//   // naive constant mapping
//   accelStructureOffsetsData[i] = i * N_TETS;
//   accelStructureCountsData[i] = N_TETS;
//   for (let i_tet = 0; i_tet < N_TETS; i_tet++) {
//     accelStructureTetraIndicesData[i * N_TETS + i_tet] = i_tet;
//   }
// }
// We assign each tetra to grid cells based on bounding box

        const s3_start = performance.now();
        let fragments = [];
        let fragCount = 0;
        let testCount = 0;
        const RES = hypercamera_sensor_resolution; // also assert is_unit_sensor
        const S_U_START = hypercamera_sensor_uvl_range[0];
        const S_U_RANGE = hypercamera_sensor_uvl_range[1] - hypercamera_sensor_uvl_range[0];
        const S_V_START = hypercamera_sensor_uvl_range[2];
        const S_V_RANGE = hypercamera_sensor_uvl_range[3] - hypercamera_sensor_uvl_range[2];
        const S_L_START = hypercamera_sensor_uvl_range[4];
        const S_L_RANGE = hypercamera_sensor_uvl_range[5] - hypercamera_sensor_uvl_range[4];
        let work_items = [];
        let poor_man_bvh = { // not even a BVH, just a grid keeping track of tetras to check per tile
            cell_counts: new Array(TILE_RES * TILE_RES * TILE_RES).fill(0),
            cell_offsets: new Array(TILE_RES * TILE_RES * TILE_RES).fill(0),
            total_entries: 0,
            cell_tetra_indices: null,
        };
        function perTetraBuildAccelStructure(tetra_index, valid_tetras, vertices_in_suvl, vertices_in_1uvl, poor_man_bvh, pass) {
            // project vertices to 1UVL, keep track of original s for "depth"
            let tetra = valid_tetras[tetra_index];
            let v0_idx = tetra.indices[0];
            let v1_idx = tetra.indices[1];
            let v2_idx = tetra.indices[2];
            let v3_idx = tetra.indices[3];
            let v0_1uvl = vertices_in_1uvl[v0_idx];
            let v1_1uvl = vertices_in_1uvl[v1_idx];
            let v2_1uvl = vertices_in_1uvl[v2_idx];
            let v3_1uvl = vertices_in_1uvl[v3_idx];
            let v0_s = vertices_in_suvl[v0_idx].x;
            let v1_s = vertices_in_suvl[v1_idx].x;
            let v2_s = vertices_in_suvl[v2_idx].x;
            let v3_s = vertices_in_suvl[v3_idx].x;
            
            // get bounding box in 1UVL
            let u_min = Math.min(v0_1uvl.y, v1_1uvl.y, v2_1uvl.y, v3_1uvl.y);
            let u_max = Math.max(v0_1uvl.y, v1_1uvl.y, v2_1uvl.y, v3_1uvl.y);
            let v_min = Math.min(v0_1uvl.z, v1_1uvl.z, v2_1uvl.z, v3_1uvl.z);
            let v_max = Math.max(v0_1uvl.z, v1_1uvl.z, v2_1uvl.z, v3_1uvl.z);
            let l_min = Math.min(v0_1uvl.w, v1_1uvl.w, v2_1uvl.w, v3_1uvl.w);
            let l_max = Math.max(v0_1uvl.w, v1_1uvl.w, v2_1uvl.w, v3_1uvl.w);
            // convert from -1..1 to 0..RES
            let U_min = Math.max(0, Math.min(RES - 1, Math.floor((u_min - S_U_START) / S_U_RANGE * RES)));
            let U_max = Math.max(0, Math.min(RES - 1, Math.ceil((u_max - S_U_START) / S_U_RANGE * RES)));
            let V_min = Math.max(0, Math.min(RES - 1, Math.floor((v_min - S_V_START) / S_V_RANGE * RES)));
            let V_max = Math.max(0, Math.min(RES - 1, Math.ceil((v_max - S_V_START) / S_V_RANGE * RES)));
            let L_min = Math.max(0, Math.min(RES - 1, Math.floor((l_min - S_L_START) / S_L_RANGE * RES)));
            let L_max = Math.max(0, Math.min(RES - 1, Math.ceil((l_max - S_L_START) / S_L_RANGE * RES)));

            // Convert from -1..1 in 1uvl to 0..N_TILES in tile space
            let TU_min = Math.max(0, Math.min(TILE_RES - 1, Math.floor((u_min - S_U_START) / S_U_RANGE * TILE_RES)));
            let TU_max = Math.max(0, Math.min(TILE_RES - 1, Math.ceil((u_max - S_U_START) / S_U_RANGE * TILE_RES)));
            let TV_min = Math.max(0, Math.min(TILE_RES - 1, Math.floor((v_min - S_V_START) / S_V_RANGE * TILE_RES)));
            let TV_max = Math.max(0, Math.min(TILE_RES - 1, Math.ceil((v_max - S_V_START) / S_V_RANGE * TILE_RES)));
            let TL_min = Math.max(0, Math.min(TILE_RES - 1, Math.floor((l_min - S_L_START) / S_L_RANGE * TILE_RES)));
            let TL_max = Math.max(0, Math.min(TILE_RES - 1, Math.ceil((l_max - S_L_START) / S_L_RANGE * TILE_RES)));
            
            // create a fragment for each pixel in the box
            let A = [v0_1uvl.y, v0_1uvl.z, v0_1uvl.w];
            let B = [v1_1uvl.y, v1_1uvl.z, v1_1uvl.w];
            let C = [v2_1uvl.y, v2_1uvl.z, v2_1uvl.w];
            let D = [v3_1uvl.y, v3_1uvl.z, v3_1uvl.w];

            for (let TU = TU_min; TU <= TU_max; TU++) {
                for (let TV = TV_min; TV <= TV_max; TV++) {
                    for (let TL = TL_min; TL <= TL_max; TL++) {
                        const CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
                        if (pass === 0) {
                            poor_man_bvh.cell_counts[CELL_ID]++;
                        } else {
                            const writeIndex = poor_man_bvh.cell_offsets[CELL_ID] + poor_man_bvh.cell_counts[CELL_ID];
                            poor_man_bvh.cell_tetra_indices[writeIndex] = tetra_index;
                            poor_man_bvh.cell_counts[CELL_ID]++;
                        }
                    }
                }
            }
        }
        // first pass to count entries
        for (let ti = 0; ti < valid_tetras.length; ti++) { perTetraBuildAccelStructure(ti, valid_tetras, vertices_in_suvl, vertices_in_1uvl, poor_man_bvh, 0); } // run the "shader"
        // compute offsets
        let running_offset = 0;
        for (let i = 0; i < TILE_RES * TILE_RES * TILE_RES; i++) {
            poor_man_bvh.cell_offsets[i] = running_offset;
            running_offset += poor_man_bvh.cell_counts[i];
            poor_man_bvh.total_entries = running_offset;
            poor_man_bvh.cell_counts[i] = 0; // reset to use as counter in next pass
        }
        poor_man_bvh.cell_tetra_indices = new Array(poor_man_bvh.total_entries).fill(0);
        // second pass to fill indices
        for (let ti = 0; ti < valid_tetras.length; ti++) { perTetraBuildAccelStructure(ti, valid_tetras, vertices_in_suvl, vertices_in_1uvl, poor_man_bvh, 1); } // run the "shader"
        const s3_end = performance.now();
        // timingsInfosHtml += `<p>Stage 3: Rasterized ${valid_tetras.length} tetras to S-buffer with ${fragCount} fragments (tested ${testCount}) in ${(s3_end - s3_start).toFixed(2)} ms</p>`;
        console.log(`Stage 3 Part 1: ${valid_tetras.length} tetras mapped to ${poor_man_bvh.total_entries} entries in accel structure with ${TILE_RES * TILE_RES * TILE_RES} tiles in ${(s3_end - s3_start).toFixed(2)} ms`);
        timingsInfosHtml += `<p>Stage 3 Part 1: ${valid_tetras.length} tetras mapped to ${poor_man_bvh.total_entries} entries in accel structure with ${TILE_RES * TILE_RES * TILE_RES} tiles in ${(s3_end - s3_start).toFixed(2)} ms</p>`;
        // put into data array
        for (let i = 0; i < TILE_RES * TILE_RES * TILE_RES; i++) {
            accelStructureCountsData[i] = poor_man_bvh.cell_counts[i];
            accelStructureOffsetsData[i] = poor_man_bvh.cell_offsets[i];
        }
        for (let i = 0; i < poor_man_bvh.cell_tetra_indices.length; i++) {
          accelStructureTetraIndicesData[i] = poor_man_bvh.cell_tetra_indices[i];
        }

// Initialize voxel grid (4x4x4)
const voxelData = new Float32Array(VOX*VOX*VOX*8); // 64x64x64 grid for simplicity
for (let i = 0; i < (VOX*VOX*VOX); i++) {
  const U = i % VOX;
  const V = Math.floor(i / VOX) % VOX;
  const L = Math.floor(i / (VOX*VOX));
  
  // Create interesting pattern
  let r, g, b, a, s;
  // if ((x + y + z) % 2 === 0) {
  //   r = Math.floor(x * 255 / (VOX-1));
  //   g = Math.floor(y * 255 / (VOX-1));
  //   b = Math.floor(z * 255 / (VOX-1));
  // } else {
  //   r = 255 - Math.floor(x * 255 / (VOX-1));
  //   g = 255 - Math.floor(z * 255 / (VOX-1));
  //   b = 255 - Math.floor(y * 255 / (VOX-1));
  // }
  // Random color
  r = 1.0;
  g = 1.0;
  b = 1.0;
  a = 0.0;
  if (U === 0 || U === (VOX-1) || V === 0 || V === (VOX-1) || L === 0 || L === (VOX-1)) {
    a = 0.5;
  }
  s = 1.0;
  
  // Pack RGBA into uint32 (make all visible)
  voxelData[i * 8 + 0] = r;
  voxelData[i * 8 + 1] = g;
  voxelData[i * 8 + 2] = b;
  voxelData[i * 8 + 3] = a;
  voxelData[i * 8 + 4] = s;
  voxelData[i * 8 + 5] = 0;
  voxelData[i * 8 + 6] = 0;
  voxelData[i * 8 + 7] = 0;
}



async function init() {
  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();
  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();
  
  context.configure({
    device,
    format,
    alphaMode: 'opaque',
  });

  const stage1ShaderCode = `
  // Stage 1: Transform vertices from object space to world space, then to camera space, then to SUVL space
struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

struct Vertex1uvlstex {
    u: f32,
    v: f32,
    l: f32,
    s: f32,
    tex_u: f32,
    tex_v: f32,
    tex_w: f32,
    padding: f32,
}

@group(0) @binding(0) var<storage, read> vertices_in_object: array<Vector4D>;
@group(0) @binding(1) var<storage, read> object_poses_5by5: array<f32>;
@group(0) @binding(2) var<storage, read> vertex_object_indices: array<u32>;
@group(0) @binding(3) var<storage, read> hypercamera_inv_pose_5by5: array<f32>;
@group(0) @binding(4) var<storage, read_write> vertices1uvlstexBuffer: array<Vertex1uvlstex>;

@group(1) @binding(0) var<uniform> vertex_counts: vec4<u32>; // num_vertices, unused, unused, unused

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let vertex_index = global_id.x;
    let num_vertices = vertex_counts.x; // TODO: pass as uniform
    if (vertex_index >= num_vertices) {
        return;
    }

    // Load vertex in object space
    let v_obj = vertices_in_object[vertex_index];
    // Load object pose
    let obj_index = vertex_object_indices[vertex_index];
    var obj_pose: array<array<f32,5>,5>;
    for (var i: u32 = 0u; i < 5u; i++) {
        for (var j: u32 = 0u; j < 5u; j++) {
            obj_pose[i][j] = object_poses_5by5[obj_index * 25u + i * 5u + j];
        }
    }
    // Transform to world space
    var v_world: Vector4D;
    v_world.x = obj_pose[0][0] * v_obj.x + obj_pose[0][1] * v_obj.y + obj_pose[0][2] * v_obj.z + obj_pose[0][3] * v_obj.w + obj_pose[0][4];
    v_world.y = obj_pose[1][0] * v_obj.x + obj_pose[1][1] * v_obj.y + obj_pose[1][2] * v_obj.z + obj_pose[1][3] * v_obj.w + obj_pose[1][4];
    v_world.z = obj_pose[2][0] * v_obj.x + obj_pose[2][1] * v_obj.y + obj_pose[2][2] * v_obj.z + obj_pose[2][3] * v_obj.w + obj_pose[2][4];
    v_world.w = obj_pose[3][0] * v_obj.x + obj_pose[3][1] * v_obj.y + obj_pose[3][2] * v_obj.z + obj_pose[3][3] * v_obj.w + obj_pose[3][4];
    // Load hypercamera pose
    var hc_pose: array<array<f32,5>,5>;
    for (var i: u32 = 0u; i < 5u; i++) {
        for (var j: u32 = 0u; j < 5u; j++) {
            hc_pose[i][j] = hypercamera_inv_pose_5by5[i * 5u + j];
        }
    }
    // Transform to camera space
    var v_cam: Vector4D;
    v_cam.x = hc_pose[0][0] * v_world.x + hc_pose[0][1] * v_world.y + hc_pose[0][2] * v_world.z + hc_pose[0][3] * v_world.w + hc_pose[0][4];
    v_cam.y = hc_pose[1][0] * v_world.x + hc_pose[1][1] * v_world.y + hc_pose[1][2] * v_world.z + hc_pose[1][3] * v_world.w + hc_pose[1][4];
    v_cam.z = hc_pose[2][0] * v_world.x + hc_pose[2][1] * v_world.y + hc_pose[2][2] * v_world.z + hc_pose[2][3] * v_world.w + hc_pose[2][4];
    v_cam.w = hc_pose[3][0] * v_world.x + hc_pose[3][1] * v_world.y + hc_pose[3][2] * v_world.z + hc_pose[3][3] * v_world.w + hc_pose[3][4];
    // Transform to 1UVL space
    // var v_1uvls: Vector4D;
    // v_1uvls.x = v_cam.y / v_cam.x;
    // v_1uvls.y = v_cam.z / v_cam.x;
    // v_1uvls.z = v_cam.w / v_cam.x;
    // v_1uvls.w = v_cam.x;

    // keep the texcoords, only update the suvls
    let prev = vertices1uvlstexBuffer[vertex_index];
    var v_1uvlstex: Vertex1uvlstex;
    v_1uvlstex.u = v_cam.y / v_cam.x;
    v_1uvlstex.v = v_cam.z / v_cam.x;
    v_1uvlstex.l = v_cam.w / v_cam.x;
    v_1uvlstex.s = v_cam.x;
    v_1uvlstex.tex_u = prev.tex_u;
    v_1uvlstex.tex_v = prev.tex_v;
    v_1uvlstex.tex_w = prev.tex_w;
    v_1uvlstex.padding = 0.0;

    // Store result
    vertices1uvlstexBuffer[vertex_index] = v_1uvlstex;
}
`;
  
  // Stage 2.1 - Update counts in Screen Space Tile Acceleration Structure
  const stage2p1ShaderCode = `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

struct Vertex1uvlstex {
    u: f32,
    v: f32,
    l: f32,
    s: f32,
    tex_u: f32,
    tex_v: f32,
    tex_w: f32,
    padding: f32,
}

struct CellCountAndOffset {
    count: u32,
    offset: u32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices1uvlstexBuffer: array<Vertex1uvlstex>;
@group(0) @binding(2) var<storage, read_write> cellCountsAndOffsetsBuffer: array<atomic<u32>>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // RES, TILE_RES, TILE_SZ, unused
@group(1) @binding(1) var<uniform> tetra_counts: vec4<u32>; // num_valid_tetras, num_vertices, unused, unused

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tetra_index = global_id.x;
    let num_tetras = tetra_counts.x; // TODO: pass as uniform
    let TILE_RES = params.y;
    
    if (tetra_index >= num_tetras) {
        return;
    }
    
    let tetra = tetras[tetra_index];
    let v0_1uvls = vertices1uvlstexBuffer[tetra.i0];
    let v1_1uvls = vertices1uvlstexBuffer[tetra.i1];
    let v2_1uvls = vertices1uvlstexBuffer[tetra.i2];
    let v3_1uvls = vertices1uvlstexBuffer[tetra.i3];

    // For safety, ignore tetra if any vertex has non-positive S
    if (v0_1uvls.s <= 0.0 || v1_1uvls.s <= 0.0 || v2_1uvls.s <= 0.0 || v3_1uvls.s <= 0.0) {
        return;
    }

    let u_min = min(min(v0_1uvls.u, v1_1uvls.u), min(v2_1uvls.u, v3_1uvls.u));
    let u_max = max(max(v0_1uvls.u, v1_1uvls.u), max(v2_1uvls.u, v3_1uvls.u));
    let v_min = min(min(v0_1uvls.v, v1_1uvls.v), min(v2_1uvls.v, v3_1uvls.v));
    let v_max = max(max(v0_1uvls.v, v1_1uvls.v), max(v2_1uvls.v, v3_1uvls.v));
    let l_min = min(min(v0_1uvls.l, v1_1uvls.l), min(v2_1uvls.l, v3_1uvls.l));
    let l_max = max(max(v0_1uvls.l, v1_1uvls.l), max(v2_1uvls.l, v3_1uvls.l));
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let TU_min = u32(clamp(floor((u_min - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TU_max = u32(clamp(ceil((u_max - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_min = u32(clamp(floor((v_min - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_max = u32(clamp(ceil((v_max - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_min = u32(clamp(floor((l_min - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_max = u32(clamp(ceil((l_max - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    
    for (var TU = TU_min; TU <= TU_max; TU++) {
        for (var TV = TV_min; TV <= TV_max; TV++) {
            for (var TL = TL_min; TL <= TL_max; TL++) {
                let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
                atomicAdd(&cellCountsAndOffsetsBuffer[CELL_ID * 2], 1u); // * 2 to access the count element
            }
        }
    }
}
`;

// Stage 2.2
// Stage 2.2: Prefix Sum to calculate offsets from counts
// This uses a work-efficient parallel scan algorithm
const stage2p2ShaderCode = `

struct CellCountAndOffset {
    count: u32,
    offset: u32,
}

@group(0) @binding(0) var<storage, read_write> cellCountsAndOffsetsBuffer: array<CellCountAndOffset>;
@group(0) @binding(1) var<storage, read_write> temp: array<u32>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; 

@compute @workgroup_size(256)
fn upsweep(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let level = params.y;
    let num_elements = params.x;
    
    let stride = 1u << (level + 1u);
    let idx = tid * stride;
    
    if (idx + stride - 1u < num_elements) {
        let left = idx + (1u << level) - 1u;
        let right = idx + stride - 1u;
        temp[right] = temp[left] + temp[right];
    }
}

@compute @workgroup_size(256)
fn downsweep(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let level = params.y;
    let num_elements = params.x;
    
    let stride = 1u << (level + 1u);
    let idx = tid * stride;
    
    if (idx + stride - 1u < num_elements) {
        let left = idx + (1u << level) - 1u;
        let right = idx + stride - 1u;
        
        let t = temp[left];
        temp[left] = temp[right];
        temp[right] = t + temp[right];
    }
}

@compute @workgroup_size(256)
fn init(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let num_elements = params.x;
    if (tid < num_elements) {
        temp[tid] = cellCountsAndOffsetsBuffer[tid].count;
    }
}

@compute @workgroup_size(256)
fn finalize(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let num_elements = params.x;
    if (tid < num_elements) {
        cellCountsAndOffsetsBuffer[tid].offset = temp[tid];
    }
}

// NEW: Kernel to clear the root element safely
@compute @workgroup_size(1)
fn clear_root() {
    let num_elements = params.x;
    if (num_elements > 0u) {
        temp[num_elements - 1u] = 0u;
    }
}
`;

// NEW: Shader to clear buffers (replaces queue.writeBuffer)
const clearBufferShaderCode = `
@group(0) @binding(0) var<storage, read_write> buffer: array<u32>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx < arrayLength(&buffer)) {
        buffer[idx] = 0u;
    }
}
`;

// NEW: Stage 2.3 - Binning (Writes tetra indices into the grid)
const stage2p3ShaderCode = `
struct TetraData { i0: u32, i1: u32, i2: u32, i3: u32, color: u32 }
struct Vector4D { x: f32, y: f32, z: f32, w: f32 }

struct Vertex1uvlstex {
    u: f32,
    v: f32,
    l: f32,
    s: f32,
    tex_u: f32,
    tex_v: f32,
    tex_w: f32,
    padding: f32,
}

struct CellCountAndOffset {
    count: u32,
    offset: u32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices1uvlstexBuffer: array<Vertex1uvlstex>;
@group(0) @binding(2) var<storage, read> cellCountsAndOffsetsBuffer: array<CellCountAndOffset>;
@group(0) @binding(3) var<storage, read_write> cell_write_counters: array<atomic<u32>>; // Temporary atomic counter
@group(0) @binding(4) var<storage, read_write> cell_tetra_indices: array<u32>; // Output

@group(1) @binding(0) var<uniform> params: vec4<u32>;
@group(1) @binding(1) var<uniform> tetra_counts: vec4<u32>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tetra_index = global_id.x;
    let num_tetras = tetra_counts.x;
    let TILE_RES = params.y;
    
    if (tetra_index >= num_tetras) { return; }
    
    let tetra = tetras[tetra_index];
    let v0 = vertices1uvlstexBuffer[tetra.i0];
    let v1 = vertices1uvlstexBuffer[tetra.i1];
    let v2 = vertices1uvlstexBuffer[tetra.i2];
    let v3 = vertices1uvlstexBuffer[tetra.i3];

    // For safety, ignore tetra if any vertex has non-positive S
    if (v0.s <= 0.0 || v1.s <= 0.0 || v2.s <= 0.0 || v3.s <= 0.0) {
        return;
    }
    
    // Calculate AABB (Same logic as Stage 2.1)
    let u_min = min(min(v0.u, v1.u), min(v2.u, v3.u));
    let u_max = max(max(v0.u, v1.u), max(v2.u, v3.u));
    let v_min = min(min(v0.v, v1.v), min(v2.v, v3.v));
    let v_max = max(max(v0.v, v1.v), max(v2.v, v3.v));
    let l_min = min(min(v0.l, v1.l), min(v2.l, v3.l));
    let l_max = max(max(v0.l, v1.l), max(v2.l, v3.l));
    
    let S_U_START = -1.0; let S_U_RANGE = 2.0;
    let S_V_START = -1.0; let S_V_RANGE = 2.0;
    let S_L_START = -1.0; let S_L_RANGE = 2.0;
    
    let TU_min = u32(clamp(floor((u_min - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TU_max = u32(clamp(ceil((u_max - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_min = u32(clamp(floor((v_min - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_max = u32(clamp(ceil((v_max - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_min = u32(clamp(floor((l_min - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_max = u32(clamp(ceil((l_max - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    
    for (var TU = TU_min; TU <= TU_max; TU++) {
        for (var TV = TV_min; TV <= TV_max; TV++) {
            for (var TL = TL_min; TL <= TL_max; TL++) {
                let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
                
                // CRITICAL FIX: Determine where to write using Offsets + Atomic Increment
                let start_offset = cellCountsAndOffsetsBuffer[CELL_ID].offset;
                let local_idx = atomicAdd(&cell_write_counters[CELL_ID], 1u);
                
                // Safety check: if we exceed allocated size, skip writing
                if (start_offset + local_idx >= arrayLength(&cell_tetra_indices)) {
                    continue; // TODO: raise some kind of error
                }

                // Write the tetra index to the global buffer
                // Note: We should technically check bounds here, but MAX_SIZE is usually large enough
                cell_tetra_indices[start_offset + local_idx] = tetra_index;
            }
        }
    }
}
`;

  // Stage 3 - Per voxel: tetra tests and final compute shader to write to voxels
  const stage3ShaderCode = `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}


struct Vertex1uvlstex {
    u: f32,
    v: f32,
    l: f32,
    s: f32,
    tex_u: f32,
    tex_v: f32,
    tex_w: f32,
    padding: f32,
}

struct Voxel {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
    s: f32,
    _pad: u32,
    _pad2: u32,
    _pad3: u32,
}


struct CellCountAndOffset {
    count: u32,
    offset: u32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices1uvlstexBuffer: array<Vertex1uvlstex>;
@group(0) @binding(2) var<storage, read> cellCountsAndOffsetsBuffer: array<CellCountAndOffset>;
@group(0) @binding(3) var<storage, read> cell_tetra_indices: array<u32>;
// @group(0) @binding(5) var<storage, read> vertex_object_indices: array<u32>;
// @group(0) @binding(6) var<storage, read> vertices_texcoords: array<Vector4D>; // merge with 1uvls
// @group(0) @binding(7) var<storage, read> object_texture_header: array<vec4<u32>>; // offset, USIZE, VSIZE, WSIZE
// @group(0) @binding(8) var<storage, read> texture_data: array<u32>; // combine with above
// @group(0) @binding(9) var<storage, read_write> voxels: array<Voxel>;
@group(0) @binding(4) var<storage, read_write> voxels: array<Voxel>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // RES, TILE_RES, TILE_SZ, unused

fn signedVolume(a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> f32 {
    let ab = b - a;
    let ac = c - a;
    let ad = d - a;
    return dot(cross(ab, ac), ad) / 6.0;
}

fn barycentricCoordinates(P: vec3<f32>, A: vec3<f32>, B: vec3<f32>, C: vec3<f32>, D: vec3<f32>) -> vec4<f32> {
    let V = signedVolume(A, B, C, D);
    if (abs(V) < 1e-10) {
        return vec4<f32>(-1.0);
    }
    let alpha = signedVolume(P, B, C, D) / V;
    let beta = signedVolume(A, P, C, D) / V;
    let gamma = signedVolume(A, B, P, D) / V;
    let delta = signedVolume(A, B, C, P) / V;
    return vec4<f32>(alpha, beta, gamma, delta);
}

fn getTexture(tetra: TetraData, bary: vec4<f32>) -> vec3<f32> {
    // Get UVMap coordinates from barycentric interpolation
    // let object_index = vertex_object_indices[tetra.i0]; // assuming all vertices of tetra belong to same object
    // let v0_uvlstexcoord = vertices_texcoords[tetra.i0];
    // let v1_uvlstexcoord = vertices_texcoords[tetra.i1];
    // let v2_uvlstexcoord = vertices_texcoords[tetra.i2];
    // let v3_uvlstexcoord = vertices_texcoords[tetra.i3];
    // let v0_texcoord = vec3<f32>(v0_uvlstexcoord.tex_u, v0_uvlstexcoord.tex_v, v0_uvlstexcoord.tex_w);
    // let v1_texcoord = vec3<f32>(v1_uvlstexcoord.tex_u, v1_uvlstexcoord.tex_v, v1_uvlstexcoord.tex_w);
    // let v2_texcoord = vec3<f32>(v2_uvlstexcoord.tex_u, v2_uvlstexcoord.tex_v, v2_uvlstexcoord.tex_w);
    // let v3_texcoord = vec3<f32>(v3_uvlstexcoord.tex_u, v3_uvlstexcoord.tex_v, v3_uvlstexcoord.tex_w);
    // let texcoord = bary.x * v0_texcoord + bary.y * v1_texcoord + bary.z * v2_texcoord + bary.w * v3_texcoord;
    // modulo texcoord to [0,1] (for repeating textures)
    // texcoord = fract(texcoord);
    // Load texture map for that object
    // let tex_info = object_texture_header[object_index]; // offset, USIZE, VSIZE, WSIZE
    // let tex_offset = tex_info.x; // texture for that object starts at this offset
    // let tex_usize = tex_info.y; // number of texels in [0, 1] u direction (aka resolution)
    // let tex_vsize = tex_info.z;
    // let tex_wsize = tex_info.w;
    // let texcoord_discrete = vec3<u32>(u32(texcoord.x * f32(tex_usize)), u32(texcoord.y * f32(tex_vsize)), u32(texcoord.z * f32(tex_wsize)));
    // Clamp to valid range
    // texcoord_discrete.x = min(texcoord_discrete.x, tex_usize - 1u);
    // texcoord_discrete.y = min(texcoord_discrete.y, tex_vsize - 1u);
    // texcoord_discrete.z = min(texcoord_discrete.z, tex_wsize - 1u);
    // Fetch texel
    // let texel_index = tex_offset + texcoord_discrete.x + texcoord_discrete.y * tex_usize + texcoord_discrete.z * tex_usize * tex_vsize;
    // // We can't store as u8, so we store as one big u32 and unpack here
    // let texel_u32 = texture_data[texel_index];
    // let texel_u8 = vec4<u32>(
    //     (texel_u32.x >> 0u) & 0xFF
    //     (texel_u32.x >> 8u) & 0xFF,
    //     (texel_u32.x >> 16u) & 0xFF,
    //     (texel_u32.x >> 24u) & 0xFF,
    // );
    // let texel = vec3<f32>(f32(texel_u8.x) / 255.0, f32(texel_u8.y) / 255.0, f32(texel_u8.z) / 255.0);
    // return texel;
    return vec3<f32>(1.0, 1.0, 1.0); // placeholder white
}

@compute @workgroup_size(4, 4, 4)
fn cs_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let RES = params.x;
    let TILE_RES = params.y;
    let TILE_SZ = params.z;
    
    let U = global_id.x;
    let V = global_id.y;
    let L = global_id.z;
    
    if (U >= RES || V >= RES || L >= RES) {
        return;
    }

      
    let voxel_index = U + V * RES + L * RES * RES;

    if (U == 0 || U == RES-1 || V == 0 || V == RES-1 || L == 0 || L == RES-1) {
     voxels[voxel_index] = Voxel(1.0, 1.0, 1.0, 0.1, 1.0, 0u, 0u, 0u);
     return;
     } 
    
    let TU = U / TILE_SZ;
    let TV = V / TILE_SZ;
    let TL = L / TILE_SZ;
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let u = S_U_START + (f32(U) + 0.5) / f32(RES) * S_U_RANGE;
    let v = S_V_START + (f32(V) + 0.5) / f32(RES) * S_V_RANGE;
    let l = S_L_START + (f32(L) + 0.5) / f32(RES) * S_L_RANGE;
    
    let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
    let cell_offset = cellCountsAndOffsetsBuffer[CELL_ID].offset;
    let cell_count = cellCountsAndOffsetsBuffer[CELL_ID].count;
  
    var best_voxel = voxels[voxel_index];
    best_voxel.s = 100000000.0; // TODO inf
    best_voxel.a = 0.0;
    
    for (var i = 0u; i < cell_count; i++) {
        let tetra_index = cell_tetra_indices[cell_offset + i];
        let tetra = tetras[tetra_index];
        
        let v0_1uvls = vertices1uvlstexBuffer[tetra.i0];
        let v1_1uvls = vertices1uvlstexBuffer[tetra.i1];
        let v2_1uvls = vertices1uvlstexBuffer[tetra.i2];
        let v3_1uvls = vertices1uvlstexBuffer[tetra.i3];
        
        let v0_s = v0_1uvls.s;
        let v1_s = v1_1uvls.s;
        let v2_s = v2_1uvls.s;
        let v3_s = v3_1uvls.s;
        
        let A = vec3<f32>(v0_1uvls.u, v0_1uvls.v, v0_1uvls.l);
        let B = vec3<f32>(v1_1uvls.u, v1_1uvls.v, v1_1uvls.l);
        let C = vec3<f32>(v2_1uvls.u, v2_1uvls.v, v2_1uvls.l);
        let D = vec3<f32>(v3_1uvls.u, v3_1uvls.v, v3_1uvls.l);
        let P = vec3<f32>(u, v, l);
        
        let u_min = min(min(v0_1uvls.u, v1_1uvls.u), min(v2_1uvls.u, v3_1uvls.u));
        let u_max = max(max(v0_1uvls.u, v1_1uvls.u), max(v2_1uvls.u, v3_1uvls.u));
        let v_min = min(min(v0_1uvls.v, v1_1uvls.v), min(v2_1uvls.v, v3_1uvls.v));
        let v_max = max(max(v0_1uvls.v, v1_1uvls.v), max(v2_1uvls.v, v3_1uvls.v));
        let l_min = min(min(v0_1uvls.l, v1_1uvls.l), min(v2_1uvls.l, v3_1uvls.l));
        let l_max = max(max(v0_1uvls.l, v1_1uvls.l), max(v2_1uvls.l, v3_1uvls.l));
        
        if (u < u_min || u > u_max || v < v_min || v > v_max || l < l_min || l > l_max) {
            continue;
        }
        
        let bary = barycentricCoordinates(P, A, B, C, D);
        
        if (all(bary >= vec4<f32>(0.0)) && all(bary <= vec4<f32>(1.0))) {
            let s = bary.x * v0_s + bary.y * v1_s + bary.z * v2_s + bary.w * v3_s;
            
            if (s < best_voxel.s) {
                best_voxel.r = f32(((tetra_index + 1u) * 53u) % 256u) / 256.0;
                best_voxel.g = f32(((tetra_index + 1u) * 97u) % 256u) / 256.0;
                best_voxel.b = f32(((tetra_index + 1u) * 193u) % 256u) / 256.0;
                best_voxel.a = 0.2;
                best_voxel.s = s;
            }
        }
    }
    
    voxels[voxel_index] = best_voxel;
}
`;

  // Create shader module
  const stage1ShaderModule = device.createShaderModule({
    code: stage1ShaderCode,
  });
  const stage2p1ShaderModule = device.createShaderModule({
    code: stage2p1ShaderCode,
  });
  const stage2p2ShaderModule = device.createShaderModule({
    code: stage2p2ShaderCode,
  });
  const stage3ShaderModule = device.createShaderModule({
    code: stage3ShaderCode,
  });

  // DDA ray traversal shader code
  const shaderCode = `
struct Uniforms {
  cameraPos: vec3f,
  cameraDir: vec3f,
  cameraUp: vec3f,
  cameraRight: vec3f,
  resolution: vec2f,
}

struct Voxel {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
    s: f32,
    _pad: u32,
    _pad2: u32,
    _pad3: u32,
}

const fVOX: f32 = 64.0;
const iVOX: i32 = 64;

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> voxelGrid: array<Voxel>;

fn getVoxel(pos: vec3i) -> Voxel {
  if (pos.x < 0 || pos.x >= iVOX || pos.y < 0 || pos.y >= iVOX || pos.z < 0 || pos.z >= iVOX) {
    return Voxel(0.0, 0.0, 0.0, 0.0, 0.0, 0u, 0u, 0u);
  }
  let idx = pos.x + pos.y * iVOX + pos.z * iVOX * iVOX;
  return voxelGrid[idx];
}


fn unpackColor(voxel: Voxel) -> vec4f {
  let r = voxel.r;
  let g = voxel.g;
  let b = voxel.b;
  let a = voxel.a;
  return vec4f(r, g, b, a);
}

// DDA ray traversal through voxel grid
fn traceRay(origin: vec3f, dir: vec3f) -> vec4f {
  // Find intersection with grid bounding box (0,0,0) to (VOX,VOX,VOX)
  let boxMin = vec3f(0.0, 0.0, 0.0);
  let boxMax = vec3f(fVOX, fVOX, fVOX);
  
  let invDir = vec3f(1.0) / dir;
  let t0 = (boxMin - origin) * invDir;
  let t1 = (boxMax - origin) * invDir;
  
  let tmin = min(t0, t1);
  let tmax = max(t0, t1);
  
  let tenter = max(max(tmin.x, tmin.y), tmin.z);
  let texit = min(min(tmax.x, tmax.y), tmax.z);
  
  
  var skyColor = vec4f(0.07, 0.07, 0.07, 1.0);

  // Ray misses box or starts after exit
  if (tenter > texit || texit < 0.0) {
    return skyColor;
  }
  
  // Start ray at entry point (or origin if inside box)
  let tstart = max(tenter, 0.0);
  var rayPos = origin + dir * tstart + dir * 0.001; // Small epsilon to ensure we're inside
  
  // Current voxel position
  var voxelPos = vec3i(floor(rayPos));
  
  // Clamp to valid range
  voxelPos = clamp(voxelPos, vec3i(0), vec3i(iVOX-1));
  
  // Step direction (1 or -1 for each axis)
  let step = vec3i(sign(dir));
  
  // Distance to next voxel boundary along each axis
  let deltaDist = abs(vec3f(1.0) / dir);
  
  // Initial side distances
  var sideDist: vec3f;
  if (dir.x < 0.0) {
    sideDist.x = (rayPos.x - f32(voxelPos.x)) * deltaDist.x;
  } else {
    sideDist.x = (f32(voxelPos.x + 1) - rayPos.x) * deltaDist.x;
  }
  if (dir.y < 0.0) {
    sideDist.y = (rayPos.y - f32(voxelPos.y)) * deltaDist.y;
  } else {
    sideDist.y = (f32(voxelPos.y + 1) - rayPos.y) * deltaDist.y;
  }
  if (dir.z < 0.0) {
    sideDist.z = (rayPos.z - f32(voxelPos.z)) * deltaDist.z;
  } else {
    sideDist.z = (f32(voxelPos.z + 1) - rayPos.z) * deltaDist.z;
  }
  
  // DDA traversal
  var compositeRayColor = vec4f(0.0, 0.0, 0.0, 0.0);
  var side = 0;
  let maxSteps = iVOX * 4;
  
  for (var i = 0; i < maxSteps; i++) {
    // Check current voxel
    let voxel = getVoxel(voxelPos);
    if (true) {
      let color = unpackColor(voxel);
      if (color.a > 0.0) {
        var effectiveAlpha = color.a;
        var srcAlpha = effectiveAlpha * (1 - compositeRayColor.a);
        compositeRayColor = vec4f(compositeRayColor.rgb + color.rgb * srcAlpha, compositeRayColor.a + srcAlpha);
        if (compositeRayColor.a >= 0.99) {
          return compositeRayColor;
        }
      }
    }
    
    // Step to next voxel
    if (sideDist.x < sideDist.y) {
      if (sideDist.x < sideDist.z) {
        sideDist.x += deltaDist.x;
        voxelPos.x += step.x;
        side = 0;
      } else {
        sideDist.z += deltaDist.z;
        voxelPos.z += step.z;
        side = 2;
      }
    } else {
      if (sideDist.y < sideDist.z) {
        sideDist.y += deltaDist.y;
        voxelPos.y += step.y;
        side = 1;
      } else {
        sideDist.z += deltaDist.z;
        voxelPos.z += step.z;
        side = 2;
      }
    }
    
    // Check if ray left grid bounds
    if (voxelPos.x < -1 || voxelPos.x > iVOX || 
        voxelPos.y < -1 || voxelPos.y > iVOX || 
        voxelPos.z < -1 || voxelPos.z > iVOX) {
      break;
    }
  }
  
  // Sky color
  var effectiveAlpha = skyColor.a;
  var srcAlpha = effectiveAlpha * (1 - compositeRayColor.a);
  compositeRayColor = vec4f(compositeRayColor.rgb + skyColor.rbg * srcAlpha, compositeRayColor.a + srcAlpha);

  return compositeRayColor;
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
  // Full screen quad
  var pos = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f(1.0, -1.0),
    vec2f(-1.0, 1.0),
    vec2f(-1.0, 1.0),
    vec2f(1.0, -1.0),
    vec2f(1.0, 1.0)
  );
  return vec4f(pos[vertexIndex], 0.0, 1.0);
}

@fragment
fn fs_main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
  let uv = (fragCoord.xy / uniforms.resolution) * 2.0 - 1.0;
  let aspect = uniforms.resolution.x / uniforms.resolution.y;
  
  // Construct ray direction
  let rayDir = normalize(
    uniforms.cameraDir + 
    uniforms.cameraRight * uv.x * aspect -
    uniforms.cameraUp * uv.y
  );
  
  return traceRay(uniforms.cameraPos, rayDir);
}
`;
  
  // Create shader module
  const shaderModule = device.createShaderModule({
    code: shaderCode,
  });

  // ----------------------
  
  // Create uniform buffer
  // 4 vec4s (camera pos, dir, up, right) + 1 vec2 (resolution) + padding = 80 bytes
  const uniformBuffer = device.createBuffer({
    size: 80,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  
  // Create voxel storage buffer
  const voxelBuffer = device.createBuffer({
    size: voxelData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(voxelBuffer, 0, voxelData);
  
  // Create bind group layout
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: 'uniform' },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: 'read-only-storage' },
      },
    ],
  });
  
  const bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: { buffer: voxelBuffer } },
    ],
  });
  
  // Create pipeline
  const pipeline = device.createRenderPipeline({
    layout: device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout],
    }),
    vertex: {
      module: shaderModule,
      entryPoint: 'vs_main',
    },
    fragment: {
      module: shaderModule,
      entryPoint: 'fs_main',
      targets: [{ format }],
    },
    primitive: {
      topology: 'triangle-list',
    },
  });

  // Stage 1 Buffers and Pipeline
    
    const tetraBuffer = device.createBuffer({
        size: tetraData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(tetraBuffer, 0, tetraData);

    const tetraCountsBuffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(tetraCountsBuffer, 0, new Uint32Array([valid_tetras.length, vertices_in_1uvl.length, 0, 0]));

    const vertices1uvlstexBuffer = device.createBuffer({
        size: vertices1uvlstexData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(vertices1uvlstexBuffer, 0, vertices1uvlstexData);
    
  const allVerticesInObjectBuffer = device.createBuffer({
    size: all_vertices_in_object_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(allVerticesInObjectBuffer, 0, all_vertices_in_object_data);

  const objectPosesBuffer = device.createBuffer({
    size: all_object_poses_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(objectPosesBuffer, 0, all_object_poses_data);

  const vertexObjectIndicesBuffer = device.createBuffer({
    size: vertex_object_indices_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(vertexObjectIndicesBuffer, 0, vertex_object_indices_data);

  const hypercameraInvPoseBuffer = device.createBuffer({
    size: hypercamera_inv_pose_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(hypercameraInvPoseBuffer, 0, hypercamera_inv_pose_data);

  const stage1ParamsBuffer = device.createBuffer({
    size: 16,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(stage1ParamsBuffer, 0, new Uint32Array([all_vertices_in_object_data.length, 0, 0, 0]));

  // textures
  const textureHeaderBuffer = device.createBuffer({
    size: object_texture_header_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(textureHeaderBuffer, 0, object_texture_header_data);

  const textureBuffer = device.createBuffer({
    size: global_texture_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(textureBuffer, 0, global_texture_data);
 
  const verticesTexcoordBuffer = device.createBuffer({
    size: vertices_texcoords_data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(verticesTexcoordBuffer, 0, vertices_texcoords_data);  

  // Layout and pipeline
  const stage1BindGroupLayout = device.createBindGroupLayout({
    entries: [
      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
      { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
      { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
      { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
      { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
    ]
  });
  const stage1ParamsBindGroupLayout = device.createBindGroupLayout({
    entries: [
      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
    ]
  });
  const stage1PipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [stage1BindGroupLayout, stage1ParamsBindGroupLayout]
  });
  const stage1Pipeline = device.createComputePipeline({
    layout: stage1PipelineLayout,
    compute: {
      module: stage1ShaderModule,
      entryPoint: 'main'
    }
  });
  const stage1BindGroup = device.createBindGroup({
    layout: stage1BindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: allVerticesInObjectBuffer } },
      { binding: 1, resource: { buffer: objectPosesBuffer } },
      { binding: 2, resource: { buffer: vertexObjectIndicesBuffer } },
      { binding: 3, resource: { buffer: hypercameraInvPoseBuffer } },
      { binding: 4, resource: { buffer: vertices1uvlstexBuffer } }
    ]
  });
  const stage1ParamsBindGroup = device.createBindGroup({
    layout: stage1ParamsBindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: stage1ParamsBuffer } }
    ]
  });



  // Stage 3 Bind Groups ----
  // Create buffers

    // these two buffers are no longer used
    const cellCountsBuffer = device.createBuffer({
        size: accelStructureCountsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellCountsBuffer, 0, accelStructureCountsData);
    const cellOffsetsBuffer = device.createBuffer({
        size: accelStructureOffsetsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellOffsetsBuffer, 0, accelStructureOffsetsData);

    // consolidate into one buffer to reduce bind groups
    const cellCountsAndOffsetsBuffer = device.createBuffer({
        size: accelStructureCountsData.byteLength + accelStructureOffsetsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellCountsAndOffsetsBuffer, 0, accelStructureCountsData);
    device.queue.writeBuffer(cellCountsAndOffsetsBuffer, accelStructureCountsData.byteLength, accelStructureOffsetsData);

    const cellTetraIndicesBuffer = device.createBuffer({
        size: accelStructureTetraIndicesData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellTetraIndicesBuffer, 0, accelStructureTetraIndicesData);

  // Stage 2p2 - Buffers
  // Create temp buffer for scan algorithm
  const tempBuffer = device.createBuffer({
      size: accelStructureCountsData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC // NOCOMMIT DEBUG
  });

  //  Create a larger buffer for parameters
  // We need space for ~40 passes. 256 bytes alignment is standard.
  const ALIGNED_SIZE = 256; 
  const MAX_PASSES = 100; // Enough for Init + Up(18) + Clear + Down(18) + Finalize
  const prefixSumParamsBuffer = device.createBuffer({
      size: MAX_PASSES * ALIGNED_SIZE, 
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  // Stage 2p3 - Buffers
  // Buffer for temporary write counts during binning
  const cellWriteCountsBuffer = device.createBuffer({
      size: accelStructureCountsData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });

  // Update params for rasterization
  const rasterParamsData = new Uint32Array([VOX, TILE_RES, TILE_SZ, 0]);
  const rasterParamsBuffer = device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(rasterParamsBuffer, 0, rasterParamsData);

  const stage2p1BindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
      ]
  });
  const stage2p1ParamsBindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
      ]
  });
  const stage2p1PipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [stage2p1BindGroupLayout, stage2p1ParamsBindGroupLayout]
  });
  const stage2p1Pipeline = device.createComputePipeline({
      layout: stage2p1PipelineLayout,
      compute: {
          module: stage2p1ShaderModule,
          entryPoint: 'main'
      }
  });
  const stage2p1BindGroup = device.createBindGroup({
      layout: stage2p1BindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: tetraBuffer } },
          { binding: 1, resource: { buffer: vertices1uvlstexBuffer } },
          { binding: 2, resource: { buffer: cellCountsAndOffsetsBuffer } }
      ]
  });
  const stage2p1ParamsBindGroup = device.createBindGroup({
      layout: stage2p1ParamsBindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: rasterParamsBuffer } },
          { binding: 1, resource: { buffer: tetraCountsBuffer } }
      ]
  });

  // 2p2

    const prefixSumBindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
      ]
  });
   const prefixSumParamsLayout = device.createBindGroupLayout({
      entries: [
          { 
            binding: 0, 
            visibility: GPUShaderStage.COMPUTE, 
            buffer: { type: 'uniform', hasDynamicOffset: true } // Changed to true
          }
      ]
  });
  const prefixSumBindGroup = device.createBindGroup({
      layout: prefixSumBindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: cellCountsAndOffsetsBuffer } },
          { binding: 1, resource: { buffer: tempBuffer } }
      ]
  });

    const prefixSumParamsBindGroup = device.createBindGroup({
      layout: prefixSumParamsLayout,
      entries: [
          { 
            binding: 0, 
            resource: { 
                buffer: prefixSumParamsBuffer,
                size: 16 // Shader only needs a vec4<u32> (16 bytes)
            } 
          }
      ]
  });
  const prefixSumPipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [prefixSumBindGroupLayout, prefixSumParamsLayout]
  });

    // Create pipelines for each stage
  const initPipeline = device.createComputePipeline({
    layout: prefixSumPipelineLayout,
    compute: {
      module: stage2p2ShaderModule,
      entryPoint: 'init'
    }
  });
  const upsweepPipeline = device.createComputePipeline({
    layout: prefixSumPipelineLayout,
    compute: {
      module: stage2p2ShaderModule,
      entryPoint: 'upsweep'
    }
  });
  const clearRootPipeline = device.createComputePipeline({
    layout: prefixSumPipelineLayout,
    compute: {
      module: stage2p2ShaderModule,
      entryPoint: 'clear_root'
    }
  });
  const downsweepPipeline = device.createComputePipeline({
    layout: prefixSumPipelineLayout,
    compute: {
      module: stage2p2ShaderModule,
      entryPoint: 'downsweep'
    }
  });
  const finalizePipeline = device.createComputePipeline({
    layout: prefixSumPipelineLayout,
    compute: {
      module: stage2p2ShaderModule,
      entryPoint: 'finalize'
    }
  });

  // 2p3

  
// 1. Setup Clear Pipeline
const clearShaderModule = device.createShaderModule({ code: clearBufferShaderCode });
const clearBindGroupLayout = device.createBindGroupLayout({
    entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }]
});
const clearPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [clearBindGroupLayout] });
const clearPipeline = device.createComputePipeline({
    layout: clearPipelineLayout,
    compute: { module: clearShaderModule, entryPoint: 'main' }
});
// Create bind groups for clearing specific buffers
const clearCountsBG = device.createBindGroup({
    layout: clearBindGroupLayout,
    entries: [{ binding: 0, resource: { buffer: cellCountsAndOffsetsBuffer } }]
});
const clearWriteCountsBG = device.createBindGroup({
    layout: clearBindGroupLayout,
    entries: [{ binding: 0, resource: { buffer: cellWriteCountsBuffer } }]
});

// 2. Setup Stage 2.3 (Binning) Pipeline
const stage2p3ShaderModule = device.createShaderModule({ code: stage2p3ShaderCode });
const stage2p3BindGroupLayout = device.createBindGroupLayout({
    entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // Offsets
        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },           // Write Counters (Atomic)
        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }            // Tetra Indices (Output)
    ]
});
const stage2p3PipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [stage2p3BindGroupLayout, stage2p1ParamsBindGroupLayout] // Reuse params layout
});
const stage2p3Pipeline = device.createComputePipeline({
    layout: stage2p3PipelineLayout,
    compute: { module: stage2p3ShaderModule, entryPoint: 'main' }
});
const stage2p3BindGroup = device.createBindGroup({
    layout: stage2p3BindGroupLayout,
    entries: [
        { binding: 0, resource: { buffer: tetraBuffer } },
        { binding: 1, resource: { buffer: vertices1uvlstexBuffer } },
        { binding: 2, resource: { buffer: cellCountsAndOffsetsBuffer } },
        { binding: 3, resource: { buffer: cellWriteCountsBuffer } },
        { binding: 4, resource: { buffer: cellTetraIndicesBuffer } }
    ]
});

  // 3

  const stage3BindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        //   { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        //   { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        //   { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        //   { binding: 7, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        //   { binding: 8, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
          { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
      ]
  });
  const stage3ParamsBindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
      ]
  });
  const stage3PipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [stage3BindGroupLayout, stage3ParamsBindGroupLayout]
  });
  const stage3Pipeline = device.createComputePipeline({
      layout: stage3PipelineLayout,
      compute: {
          module: stage3ShaderModule,
          entryPoint: 'cs_main'
      }
  });
  const stage3BindGroup = device.createBindGroup({
      layout: stage3BindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: tetraBuffer } },
          { binding: 1, resource: { buffer: vertices1uvlstexBuffer } },
          { binding: 2, resource: { buffer: cellCountsAndOffsetsBuffer } },
          { binding: 3, resource: { buffer: cellTetraIndicesBuffer } },
        //   { binding: 4, resource: { buffer: vertexObjectIndicesBuffer } },
        //   { binding: 5, resource: { buffer: verticesTexcoordBuffer } },
        //   { binding: 6, resource: { buffer: textureHeaderBuffer } },
        //   { binding: 7, resource: { buffer: textureBuffer } },
        //   { binding: 8, resource: { buffer: voxelBuffer } }
            { binding: 4, resource: { buffer: voxelBuffer } }
      ]
  });
  const stage3ParamsBindGroup = device.createBindGroup({
      layout: stage3ParamsBindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: rasterParamsBuffer } }
      ]
  });

  let sensorCamRotX = 0;
  let sensorCamRotY = 0;
  let sensorCamDist = 100;
  
  
  function updateCamera() {
    const rotY = sensorCamRotX;
    const rotX = sensorCamRotY;
    const dist = sensorCamDist;
    
    // Camera position (orbit around center at 2,2,2)
    const cx = VOX / 2 + Math.cos(rotY) * Math.cos(rotX) * dist;
    const cy = VOX / 2 + Math.sin(rotX) * dist;
    const cz = VOX / 2 + Math.sin(rotY) * Math.cos(rotX) * dist;
    
    // Camera direction (look at center)
    const target = [VOX / 2, VOX / 2, VOX / 2];
    const dx = target[0] - cx;
    const dy = target[1] - cy;
    const dz = target[2] - cz;
    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const dir = [dx/len, dy/len, dz/len];
    
    // Camera up and right vectors
    const worldUp = [0, 1, 0];
    const right = [
      dir[1] * worldUp[2] - dir[2] * worldUp[1],
      dir[2] * worldUp[0] - dir[0] * worldUp[2],
      dir[0] * worldUp[1] - dir[1] * worldUp[0],
    ];
    const rlen = Math.sqrt(right[0]**2 + right[1]**2 + right[2]**2);
    right[0] /= rlen; right[1] /= rlen; right[2] /= rlen;
    
    const up = [
      right[1] * dir[2] - right[2] * dir[1],
      right[2] * dir[0] - right[0] * dir[2],
      right[0] * dir[1] - right[1] * dir[0],
    ];
    
    // Update uniform buffer
    const uniforms = new Float32Array([
      cx, cy, cz, 0,
      dir[0], dir[1], dir[2], 0,
      up[0], up[1], up[2], 0,
      right[0], right[1], right[2], 0,
      canvas.width, canvas.height, 0, 0,
    ]);
    device.queue.writeBuffer(uniformBuffer, 0, uniforms);
  }

  let STEP_PHYSICS_ONCE = false;
  let DEBUG_PHYSICS = false;
  let physics_time_s = 0;
  let accumulated_animation_time_s = 0;
  
  // Register Keyboard controls
  const keys = {};
  window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
  });

  window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
  });


  function render() {
    // update DDA camera
    updateCamera();
    // update hypercamera
    //  Handle WASD movement for selected vertex
            if (true) {
                
                const moveSpeed = 0.1;
                const RELATIVE_MOVEMENT = true;
                if (keys['w']) {
                    hypercamera_T.translate_self_by_delta(moveSpeed, 0, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['s']) {
                    hypercamera_T.translate_self_by_delta(-moveSpeed, 0, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['a']) {
                    hypercamera_T.translate_self_by_delta(0, moveSpeed, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['d']) {
                    hypercamera_T.translate_self_by_delta(0,-moveSpeed, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['q']) {
                    hypercamera_T.translate_self_by_delta(0, 0, 0, moveSpeed, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['e']) {
                    hypercamera_T.translate_self_by_delta(0, 0, 0, -moveSpeed, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['r']) {
                    hypercamera_T.translate_self_by_delta(0, 0, moveSpeed, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['f']) {
                    hypercamera_T.translate_self_by_delta(0, 0, -moveSpeed, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                // reset camera z to 0
                hypercamera_T.matrix[2][4] = floor_heightmap(
                    hypercamera_T.matrix[0][4],
                    hypercamera_T.matrix[1][4],
                    hypercamera_T.matrix[3][4]
                ) + hypercamera_height_above_ground;

                if (keys['i']) {
                    hypercamera_T.rotate_self_by_delta('XZ', 0.05, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['k']) {
                    hypercamera_T.rotate_self_by_delta('XZ', -0.05, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['j']) {
                    hypercamera_T.rotate_self_by_delta('XY', 0.05, false);
                    moved = true;
                }
                if (keys['l']) {
                    hypercamera_T.rotate_self_by_delta('XY', -0.05, false);
                    moved = true;
                }
                if (keys['u']) {
                    hypercamera_T.rotate_self_by_delta('XW', 0.05, false);
                    moved = true;
                }
                if (keys['o']) {
                    hypercamera_T.rotate_self_by_delta('XW', -0.05, false);
                    moved = true;
                }
                if (keys['y']) {
                    hypercamera_T.rotate_self_by_delta('YW', -0.05, false);
                    moved = true;
                }
                if (keys['p']) {
                    hypercamera_T.rotate_self_by_delta('YW', 0.05, false);
                    moved = true;
                }
              }
    // let time = performance.now() * 0.001;
    // hypercamera_T.translate_self_by_delta(
    //     Math.sin(time) * 0.05,
    //     0,
    //     0,
    //     0,
    //     false
    // );
    let inv_pose = hypercamera_T.inverse();
    let inv_pose_data = new Float32Array(5 * 5);
    let inv_pose_matrix = inv_pose.matrix;
    for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            inv_pose_data[i * 5 + j] = inv_pose_matrix[i][j];
        }
    }
    device.queue.writeBuffer(hypercameraInvPoseBuffer, 0, inv_pose_data);
    // update physics
                // Simulate physics
            const SIMULATE_PHYSICS = true;
            for (let n = 0; n < 4; n++) { // substeps for stability
                if (SIMULATE_PHYSICS) {
                    moved = true;

                    // debug log
                    let html_physics_log = '';

                    const FLOOR_STIFFNESS = 100;
                    const FLOOR_DAMPING = 10;
                    const GRAVITY = -9.81;
                    const AIR_FRICTION_COEFFICIENT = 1.0;
                    const FLOOR_SIDE_FRICTION_COEFFICIENT = 1;
                    const dt = 0.016; // ~60fps

                    html_physics_log += '<b>Sim Time:</b> ' + physics_time_s.toFixed(2) + ' s<br>';
                    html_physics_log += '<b>UI Time:</b> ' + accumulated_animation_time_s.toFixed(2) + ' s<br>';

                    for (let hyperobject of visibleHyperobjects) {
                        if (hyperobject.simulate_physics) {

                            html_physics_log += `<b>Object:</b> ${hyperobject.name}<br>`;

                            // calculate hyperobject center of mass 
                            let hyperobject_com = hyperobject.get_com();
                            
                            // mujoco-style forward/backward
                            // 1. apply gravity
                            // 2. apply collision to c.o.m based on vertices penetrating the floor (use z=-2 as the floor height)
                            // 3. resolve c.o.m velocity and rotational velocity
                            // 4. update vertex positions based on c.o.m and rotational velocity
                            
                            // force and torque accumulators
                            let com_force = new Vector4D(0, 0, GRAVITY * hyperobject.mass, 0);
                            let com_torque = {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0};

                            // If object com is within 1 unit of camera, push it away with small force
                            let to_camera = hyperobject_com.subtract(hypercamera_T.origin());
                            let distance_to_camera = Math.sqrt(to_camera.x**2 + to_camera.y**2 + to_camera.z**2 + to_camera.w**2);
                            if (distance_to_camera < 2.0 && distance_to_camera > 0.01) {
                                // let push_strength = 50 * (1.0 - distance_to_camera);
                                let min_push_strength = 50;
                                let max_push_strength = 500;
                                let push_01 = (2.0 - distance_to_camera) / 2.0;
                                let push_strength = min_push_strength + (max_push_strength - min_push_strength) * push_01;
                                let push_direction = to_camera.multiply_by_scalar(1.0 / distance_to_camera); // normalize
                                let push_force = push_direction.multiply_by_scalar(push_strength);
                                com_force = com_force.add(push_force);
                                // update mission variables
                                user_has_pushed_object = true;
                            }

                            // Add a general friction force
                            let friction_force = hyperobject.velocity_in_world.multiply_by_scalar(-AIR_FRICTION_COEFFICIENT);
                            com_force = com_force.add(friction_force);

                            // Add a general air friction rotational torque
                            com_torque.xy += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.xy;
                            com_torque.xz += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.xz;
                            com_torque.xw += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.xw;
                            com_torque.yz += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.yz;
                            com_torque.yw += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.yw;
                            com_torque.zw += -AIR_FRICTION_COEFFICIENT * hyperobject.rotational_velocity.zw;
                            
                            // 2. Check for collisions with floor and accumulate forces/torques
                            for (let v of hyperobject.vertices_in_world) {
                                let floor_height = floor_heightmap(v.x, v.y, v.w);
                                let penetration = floor_height - v.z;
                                if (penetration > 0) {
                                    // Position relative to CoM
                                    let r = v.subtract(hyperobject_com); // position relative to CoM
                                    
                                    // Calculate velocity of this vertex in world frame
                                    let vertex_velocity = new Vector4D(0, 0, 0, 0);

                                    // Linear velocity from CoM
                                    vertex_velocity = vertex_velocity.add(hyperobject.velocity_in_world)

                                    // Velocity due to rotation (v_rot = omega  r in 4D)
                                    // too unstable
                                    // let v_rot = new Vector4D(
                                        // hyperobject.rotational_velocity.xy * r.y - hyperobject.rotational_velocity.xz * r.z - hyperobject.rotational_velocity.xw * r.w,
                                        // -hyperobject.rotational_velocity.xy * r.x + hyperobject.rotational_velocity.yz * r.z + hyperobject.rotational_velocity.yw * r.w,
                                        // hyperobject.rotational_velocity.xz * r.x - hyperobject.rotational_velocity.yz * r.y + hyperobject.rotational_velocity.zw * r.w,
                                        // hyperobject.rotational_velocity.xw * r.x - hyperobject.rotational_velocity.yw * r.y - hyperobject.rotational_velocity.zw * r.z
                                    // );
                                    // vertex_velocity = vertex_velocity.add(v_rot);
                                    
                                    
                                    
                                    // Spring-damper force (normal direction only, z-axis)
                                    let normal_force_z = FLOOR_STIFFNESS * penetration - FLOOR_DAMPING * vertex_velocity.z;
                                    
                                    let contact_force = new Vector4D(0, 0, normal_force_z, 0);

                                    // Add side friction to contact force
                                    let lateral_velocity = new Vector4D(vertex_velocity.x, vertex_velocity.y, 0, vertex_velocity.w);
                                    let lateral_speed = Math.sqrt(lateral_velocity.x**2 + lateral_velocity.y**2 + lateral_velocity.w**2);
                                    if (lateral_speed > 0.01) {
                                        let lateral_direction = lateral_velocity.multiply_by_scalar(1.0 / lateral_speed); // normalize
                                        let lateral_friction_magnitude = FLOOR_SIDE_FRICTION_COEFFICIENT * Math.abs(normal_force_z);
                                        let lateral_friction = lateral_direction.multiply_by_scalar(-lateral_friction_magnitude);
                                        contact_force = contact_force.add(lateral_friction);
                                    }
                                    
                                    // Accumulate force on CoM
                                    com_force = com_force.add(contact_force);

                                    // Debug
                                    if (v.z < -4) {
                                        let aaa = 1;
                                    }
                                    
                                    // Accumulate torque (r  F in 4D gives bivector with 6 components)
                                    com_torque.xy += r.x * contact_force.y - r.y * contact_force.x;
                                    com_torque.xz += r.x * contact_force.z - r.z * contact_force.x;
                                    com_torque.xw += r.x * contact_force.w - r.w * contact_force.x;
                                    com_torque.yz += r.y * contact_force.z - r.z * contact_force.y;
                                    com_torque.yw += r.y * contact_force.w - r.w * contact_force.y;
                                    com_torque.zw += r.z * contact_force.w - r.w * contact_force.z;
                                }
                            }


                            const fmt = (n) => {
                                let str = n.toFixed(3);
                                str = (n < 0 ? str.slice(1) : str); // remove minus for padding
                                str = str.padStart(8, '_');
                                str = (n >= 0 ? '+' + str : '-' + str);
                                return str
                            };

                            html_physics_log += `<table style="border-collapse: collapse; font-family: monospace;">`;
                            html_physics_log += `<tr><th>Property</th><th>x</th><th>y</th><th>z</th><th>w</th><th></th><th></th></tr>`;
                            html_physics_log += `<tr><td>Com Force</td><td>${fmt(com_force.x)}</td><td>${fmt(com_force.y)}</td><td>${fmt(com_force.z)}</td><td>${fmt(com_force.w)}</td><td></td><td></td></tr>`;
                            html_physics_log += `<tr><td>Com Vel</td><td>${fmt(hyperobject.velocity_in_world.x)}</td><td>${fmt(hyperobject.velocity_in_world.y)}</td><td>${fmt(hyperobject.velocity_in_world.z)}</td><td>${fmt(hyperobject.velocity_in_world.w)}</td><td></td><td></td></tr>`;
                            html_physics_log += `<tr><th></th><th>xy</th><th>xz</th><th>xw</th><th>yz</th><th>yw</th><th>zw</th></tr>`;
                            html_physics_log += `<tr><td>Com Torque</td><td>${fmt(com_torque.xy)}</td><td>${fmt(com_torque.xz)}</td><td>${fmt(com_torque.xw)}</td><td>${fmt(com_torque.yz)}</td><td>${fmt(com_torque.yw)}</td><td>${fmt(com_torque.zw)}</td></tr>`;
                            html_physics_log += `<tr><td>Com Ang Vel</td><td>${fmt(hyperobject.rotational_velocity.xy)}</td><td>${fmt(hyperobject.rotational_velocity.xz)}</td><td>${fmt(hyperobject.rotational_velocity.xw)}</td><td>${fmt(hyperobject.rotational_velocity.yz)}</td><td>${fmt(hyperobject.rotational_velocity.yw)}</td><td>${fmt(hyperobject.rotational_velocity.zw)}</td></tr>`;
                            html_physics_log += `</table>`;
                            
                            // 3. Integrate velocities (simple Euler integration)
                            
                            // Linear velocity update: v += (F/m) * dt
                            hyperobject.velocity_in_world = hyperobject.velocity_in_world.add(
                                new Vector4D(
                                    com_force.x / hyperobject.mass * dt,
                                    com_force.y / hyperobject.mass * dt,
                                    com_force.z / hyperobject.mass * dt,
                                    com_force.w / hyperobject.mass * dt
                                )
                            );
                            
                            // Angular velocity update: omega += (torque / I) * dt
                            // For uniform hyperobject with edge length 2: I = (2/3) * mass
                            const I = (2/3) * hyperobject.mass;
                            hyperobject.rotational_velocity.xy += (com_torque.xy / I) * dt;
                            hyperobject.rotational_velocity.xz += (com_torque.xz / I) * dt;
                            hyperobject.rotational_velocity.xw += (com_torque.xw / I) * dt;
                            hyperobject.rotational_velocity.yz += (com_torque.yz / I) * dt;
                            hyperobject.rotational_velocity.yw += (com_torque.yw / I) * dt;
                            hyperobject.rotational_velocity.zw += (com_torque.zw / I) * dt;
                            
                            // 4. Update pose based on CoM velocity and rotation, update vertices
                            // Update CoM position
                            previous_pose = hyperobject.pose;
                            // translate the pose matrix by velocity * dt
                            hyperobject.pose.translate_self_by_delta(
                                hyperobject.velocity_in_world.x * dt,
                                hyperobject.velocity_in_world.y * dt,
                                hyperobject.velocity_in_world.z * dt,
                                hyperobject.velocity_in_world.w * dt,
                                false
                            );
                            // rotate the pose matrix by rotational velocity * dt
                            hyperobject.pose.rotate_self_by_delta('XY', hyperobject.rotational_velocity.xy * dt, false);
                            hyperobject.pose.rotate_self_by_delta('XZ', hyperobject.rotational_velocity.xz * dt, false);
                            hyperobject.pose.rotate_self_by_delta('XW', hyperobject.rotational_velocity.xw * dt, false);
                            hyperobject.pose.rotate_self_by_delta('YZ', hyperobject.rotational_velocity.yz * dt, false);
                            hyperobject.pose.rotate_self_by_delta('YW', hyperobject.rotational_velocity.yw * dt, false);
                            hyperobject.pose.rotate_self_by_delta('ZW', hyperobject.rotational_velocity.zw * dt, false);
                            // update vertices
                            hyperobject.update_vertices_in_world();
                        }
                    }

                    physics_time_s += dt;

                    if (DEBUG_PHYSICS) {
                        // document.getElementById('physics-debug-text').innerHTML = html_physics_log;
                    } else {
                        // document.getElementById('physics-debug-text').innerHTML = '';
                    }

                    if (STEP_PHYSICS_ONCE) {
                        SIMULATE_PHYSICS = false;
                        STEP_PHYSICS_ONCE = false;
                    }
                } // End of SIMULATE_PHYSICS
            } // end of substeps
    let new_object_poses_data = new Float32Array(visibleHyperobjects.length * 5 * 5);
    for (let obj_index = 0; obj_index < visibleHyperobjects.length; obj_index++) {
        let obj = visibleHyperobjects[obj_index];
        // basic physics - move cube up and down 
        let time = performance.now() * 0.001;
        // DEBUG - rotate the hypercube
        // if (obj_index === 0) {
        //     obj.pose.rotate_self_by_delta('ZW', 0.01, false)
        // }
        // object poses
        let pose = obj.pose.matrix;
        for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 5; j++) {
                new_object_poses_data[obj_index * 5 * 5 + i * 5 + j] = pose[i][j];
            }
        }
    }
    device.queue.writeBuffer(objectPosesBuffer, 0, new_object_poses_data);
    
    const commandEncoder = device.createCommandEncoder();
    const textureView = context.getCurrentTexture().createView();

    // Stage 1: Vertex Shader
    if (true) {
      const computePass = commandEncoder.beginComputePass();
      computePass.setPipeline(stage1Pipeline);
      computePass.setBindGroup(0, stage1BindGroup);
      computePass.setBindGroup(1, stage1ParamsBindGroup);
      const workgroupCount = Math.ceil(all_vertices_in_object_data.length / 64);
      computePass.dispatchWorkgroups(workgroupCount);
      computePass.end();
    }

    // Stage 2: Cull tetras, + add clipped tetras if needed
    // TODO

    // Stage 2.0: Clear Counters (Use Compute Shader, NOT writeBuffer for proper sync) ---
    const clearPass = commandEncoder.beginComputePass();
    clearPass.setPipeline(clearPipeline);
    // Clear cell_counts
    clearPass.setBindGroup(0, clearCountsBG);
    clearPass.dispatchWorkgroups(Math.ceil(accelStructureCountsData.length * 2 / 256));
    // Clear cell_write_counters
    clearPass.setBindGroup(0, clearWriteCountsBG);
    clearPass.dispatchWorkgroups(Math.ceil(accelStructureCountsData.length / 256));
    clearPass.end();

    // Stage 2.1: Accel structure counts
    if (true) {
      const computePass = commandEncoder.beginComputePass();
      computePass.setPipeline(stage2p1Pipeline);
      computePass.setBindGroup(0, stage2p1BindGroup);
      computePass.setBindGroup(1, stage2p1ParamsBindGroup);
      const workgroupCount = Math.ceil(valid_tetras.length / 64);
      computePass.dispatchWorkgroups(workgroupCount);
      computePass.end();
    }

    function computePrefixSum(commandEncoder, numElements) {
        const numLevels = Math.ceil(Math.log2(numElements));
        
        // --- 1. Prepare Data CPU Side ---
        // We calculate all parameters needed for every pass and put them in one array
        const ALIGNED_SIZE = 256;
        // Total steps: Init(1) + Up(numLevels) + Clear(1) + Down(numLevels) + Finalize(1)
        const totalSteps = 1 + numLevels + 1 + numLevels + 1;
        
        // Use a DataView or typed array to write into the buffer
        const uniformData = new Uint8Array(totalSteps * ALIGNED_SIZE);
        const view = new DataView(uniformData.buffer);

        let stepIndex = 0;
        
        // Helper to write params (num_elements, level, 0, 0)
        function addParams(n, l) {
            const offset = stepIndex * ALIGNED_SIZE;
            view.setUint32(offset + 0, n, true); // Little endian
            view.setUint32(offset + 4, l, true);
            view.setUint32(offset + 8, 0, true);
            view.setUint32(offset + 12, 0, true);
            stepIndex++;
            return offset;
        }

        // Generate Offsets
        const offsetInit = addParams(numElements, 0);
        
        const offsetsUp = [];
        for (let level = 0; level < numLevels; level++) {
            offsetsUp.push(addParams(numElements, level));
        }
        
        const offsetClear = addParams(numElements, 0); // params.x used for bounds check
        
        const offsetsDown = [];
        for (let level = numLevels - 1; level >= 0; level--) {
            offsetsDown.push(addParams(numElements, level));
        }
        
        const offsetFinalize = addParams(numElements, 0);

        // --- 2. Upload Data to GPU ---
        // Write the entire sequence of parameters once
        device.queue.writeBuffer(prefixSumParamsBuffer, 0, uniformData);

        // --- 3. Record Commands with Dynamic Offsets ---
        
        // Init
        let pass = commandEncoder.beginComputePass();
        pass.setPipeline(initPipeline);
        pass.setBindGroup(0, prefixSumBindGroup);
        pass.setBindGroup(1, prefixSumParamsBindGroup, [offsetInit]); // Pass offset here
        pass.dispatchWorkgroups(Math.ceil(numElements / 256));
        pass.end();
        
        // Up-sweep
        for (let i = 0; i < numLevels; i++) {
            const level = i;
            pass = commandEncoder.beginComputePass();
            pass.setPipeline(upsweepPipeline);
            pass.setBindGroup(0, prefixSumBindGroup);
            pass.setBindGroup(1, prefixSumParamsBindGroup, [offsetsUp[i]]);
            const workgroups = Math.ceil(numElements / (256 * (1 << (level + 1))));
            pass.dispatchWorkgroups(Math.max(1, workgroups));
            pass.end();
        }
        
        // Clear Root (GPU side)
        pass = commandEncoder.beginComputePass();
        pass.setPipeline(clearRootPipeline);
        pass.setBindGroup(0, prefixSumBindGroup);
        pass.setBindGroup(1, prefixSumParamsBindGroup, [offsetClear]);
        pass.dispatchWorkgroups(1);
        pass.end();
        
        // Down-sweep
        for (let i = 0; i < numLevels; i++) {
            const level = numLevels - 1 - i;
            pass = commandEncoder.beginComputePass();
            pass.setPipeline(downsweepPipeline);
            pass.setBindGroup(0, prefixSumBindGroup);
            pass.setBindGroup(1, prefixSumParamsBindGroup, [offsetsDown[i]]);
            const workgroups = Math.ceil(numElements / (256 * (1 << (level + 1))));
            pass.dispatchWorkgroups(Math.max(1, workgroups));
            pass.end();
        }
        
        // Finalize
        pass = commandEncoder.beginComputePass();
        pass.setPipeline(finalizePipeline);
        pass.setBindGroup(0, prefixSumBindGroup);
        pass.setBindGroup(1, prefixSumParamsBindGroup, [offsetFinalize]);
        pass.dispatchWorkgroups(Math.ceil(numElements / 256));
        pass.end();
    }

    // Stage 2.2: Prefix sum to compute cell offsets
    if (true) {
      computePrefixSum(commandEncoder, TILE_RES * TILE_RES * TILE_RES);
    }

    // Stage 2.3 (Binning - Write Indices) ---
    // populates cellTetraIndicesBuffer with the current frame's data
    const pass3 = commandEncoder.beginComputePass();
    pass3.setPipeline(stage2p3Pipeline);
    pass3.setBindGroup(0, stage2p3BindGroup);
    pass3.setBindGroup(1, stage2p1ParamsBindGroup); // Reusing params
    pass3.dispatchWorkgroups(Math.ceil(valid_tetras.length / 64));
    pass3.end();

    // Stage 3: Intersection tests compute pass to update voxel data
    if (true) {
      const computePass = commandEncoder.beginComputePass();
      computePass.setPipeline(stage3Pipeline);
      computePass.setBindGroup(0, stage3BindGroup);
      computePass.setBindGroup(1, stage3ParamsBindGroup);
      const workgroupCount = Math.ceil(VOX / 4);
      computePass.dispatchWorkgroups(workgroupCount, workgroupCount, workgroupCount);
      computePass.end();
    }


    // Stage 4: DDA Render pass
    const renderPass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: textureView,
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        loadOp: 'clear',
        storeOp: 'store',
      }],
    });
    renderPass.setPipeline(pipeline);
    renderPass.setBindGroup(0, bindGroup);
    renderPass.draw(6);
    renderPass.end();
    
    device.queue.submit([commandEncoder.finish()]);
    requestAnimationFrame(render);
  }

  // Mouse interaction
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
  });
  canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - lastX;
      const deltaY = e.clientY - lastY;


      sensorCamRotY = sensorCamRotY + deltaY * 0.01;
      sensorCamRotX += deltaX * 0.01;
      
      // camera.theta += -deltaX * 0.01;
      // camera.phi = Math.max(0.1, Math.min(Math.PI - 0.1, camera.phi - deltaY * 0.01));
      
      lastX = e.clientX;
      lastY = e.clientY;
      
  });
  canvas.addEventListener('mouseup', () => {
      isDragging = false;
  });
  canvas.addEventListener('mouseleave', () => {
      isDragging = false;
  });
  // Scrolling changes camera distance
  canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      sensorCamDist += e.deltaY * 0.05;
      // camera.distance += e.deltaY * 0.05;
      // camera.distance = Math.max(5, Math.min(hypercamera_sensor_resolution * 4.0, camera.distance));

  });
  
  render();

  // DEBUG: read back counts and offsets and log
  if (false) {
    const readbackBuffer = device.createBuffer({
      size: cellCountsBuffer.size + cellOffsetsBuffer.size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
    const readbackEncoder = device.createCommandEncoder();
    const nItemsToRead = 128;
    const itemsReadStart = 100000;
    readbackEncoder.copyBufferToBuffer(cellCountsBuffer, itemsReadStart * 4, readbackBuffer, 0, nItemsToRead * 4);
    readbackEncoder.copyBufferToBuffer(cellOffsetsBuffer, itemsReadStart * 4, readbackBuffer, nItemsToRead * 4, nItemsToRead * 4);
    readbackEncoder.copyBufferToBuffer(tempBuffer, itemsReadStart * 4, readbackBuffer, nItemsToRead * 8, nItemsToRead * 4); // NOCOMMIT DEBUG
    device.queue.submit([readbackEncoder.finish()]);
    await readbackBuffer.mapAsync(GPUMapMode.READ);
    const readbackArray = new Uint32Array(readbackBuffer.getMappedRange());
    console.log('Cell Counts:', readbackArray.slice(0, nItemsToRead));
    console.log('Cell Offsets:', readbackArray.slice(nItemsToRead, nItemsToRead * 2));
    console.log('Temp Buffer (NOCOMMIT DEBUG):', readbackArray.slice(nItemsToRead * 2, nItemsToRead * 3));
    readbackBuffer.unmap();
  }
  
}

init().catch(err => {
  console.error(err);
  document.body.innerHTML += '<div style="color: red; padding: 20px;">Error: ' + err.message + '</div>';
});
</script>
</body>
</html>
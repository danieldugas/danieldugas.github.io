<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGPU Voxel DDA Ray Traversal</title>
<style>
body {
  margin: 0;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}
canvas {
  border: 2px solid #444;
  background: #000;
  max-width: 100%;
}
.controls {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  align-items: center;
}
.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
label {
  font-size: 12px;
  color: #aaa;
}
input[type="range"] {
  width: 150px;
}
.info {
  font-size: 14px;
  color: #888;
  text-align: center;
}
</style>
</head>
<body>
<canvas id="canvas" width="800" height="600"></canvas>
<div class="controls">
  <div class="control-group">
    <label>Camera Y Rotation: <span id="rotYValue">0</span>°</label>
    <input type="range" id="rotY" min="0" max="360" value="0">
  </div>
  <div class="control-group">
    <label>Camera X Rotation: <span id="rotXValue">-20</span>°</label>
    <input type="range" id="rotX" min="-90" max="90" value="-20">
  </div>
  <div class="control-group">
    <label>Camera Distance: <span id="distValue">100</span></label>
    <input type="range" id="dist" min="5" max="150" value="100" step="0.5">
  </div>
</div>
<div class="info">WebGPU Voxel Renderer with DDA Ray Traversal</div>

<script>

const VOX = 64; // Voxel grid size

const canvas = document.getElementById('canvas');
const rotYSlider = document.getElementById('rotY');
const rotXSlider = document.getElementById('rotX');
const distSlider = document.getElementById('dist');

// 4D transform class prototype
class Vector4D {
    constructor(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    add(v) {
        return new Vector4D(this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w);
    }
    subtract(v) {
        return new Vector4D(this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w);
    }
    normalize() {
        let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        if (mag === 0) return new Vector4D(0, 0, 0, 0);
        return new Vector4D(this.x / mag, this.y / mag, this.z / mag, this.w / mag);
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    multiply_by_scalar(s) {
        return new Vector4D(this.x * s, this.y * s, this.z * s, this.w * s);
    }
}
class Transform4D {
    // constructor() {
    //     this.matrix = [
    //         [1, 0, 0, 0, 0],
    //         [0, 1, 0, 0, 0],
    //         [0, 0, 1, 0, 0],
    //         [0, 0, 0, 1, 0],
    //         [0, 0, 0, 0, 1]
    //     ];
    // }
    constructor(matrix) {
        this.matrix = matrix;
    }

    origin() {
        return new Vector4D(this.matrix[0][4], this.matrix[1][4], this.matrix[2][4], this.matrix[3][4]);
    }

    // transform_point(v: Vector4D): Vector4D
    transform_point(v) {
        let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w + this.matrix[0][4];
        let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w + this.matrix[1][4];
        let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w + this.matrix[2][4];
        let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w + this.matrix[3][4];
        return new Vector4D(x, y, z, w);
    }

    transform_vector(v) {
        let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w;
        let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w;
        let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w;
        let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w;
        return new Vector4D(x, y, z, w);
    }

    transform_transform(T) {
        // matrix multiplication: this.matrix * T.matrix
        // inC_T_B * inB_T_A  -> inC_T_A
        // inC_T_B.transform_transform(inB_T_A) -> inC_T_A
        let Tl = this.matrix;
        let Tr = T.matrix;
        let Tn = [
            [
                Tl[0][0] * Tr[0][0] + Tl[0][1] * Tr[1][0] + Tl[0][2] * Tr[2][0] + Tl[0][3] * Tr[3][0],
                Tl[0][0] * Tr[0][1] + Tl[0][1] * Tr[1][1] + Tl[0][2] * Tr[2][1] + Tl[0][3] * Tr[3][1],
                Tl[0][0] * Tr[0][2] + Tl[0][1] * Tr[1][2] + Tl[0][2] * Tr[2][2] + Tl[0][3] * Tr[3][2],
                Tl[0][0] * Tr[0][3] + Tl[0][1] * Tr[1][3] + Tl[0][2] * Tr[2][3] + Tl[0][3] * Tr[3][3],
                Tl[0][0] * Tr[0][4] + Tl[0][1] * Tr[1][4] + Tl[0][2] * Tr[2][4] + Tl[0][3] * Tr[3][4] + Tl[0][4]
            ],
            [
                Tl[1][0] * Tr[0][0] + Tl[1][1] * Tr[1][0] + Tl[1][2] * Tr[2][0] + Tl[1][3] * Tr[3][0],
                Tl[1][0] * Tr[0][1] + Tl[1][1] * Tr[1][1] + Tl[1][2] * Tr[2][1] + Tl[1][3] * Tr[3][1],
                Tl[1][0] * Tr[0][2] + Tl[1][1] * Tr[1][2] + Tl[1][2] * Tr[2][2] + Tl[1][3] * Tr[3][2],
                Tl[1][0] * Tr[0][3] + Tl[1][1] * Tr[1][3] + Tl[1][2] * Tr[2][3] + Tl[1][3] * Tr[3][3],
                Tl[1][0] * Tr[0][4] + Tl[1][1] * Tr[1][4] + Tl[1][2] * Tr[2][4] + Tl[1][3] * Tr[3][4] + Tl[1][4]
            ],
            [
                Tl[2][0] * Tr[0][0] + Tl[2][1] * Tr[1][0] + Tl[2][2] * Tr[2][0] + Tl[2][3] * Tr[3][0],
                Tl[2][0] * Tr[0][1] + Tl[2][1] * Tr[1][1] + Tl[2][2] * Tr[2][1] + Tl[2][3] * Tr[3][1],
                Tl[2][0] * Tr[0][2] + Tl[2][1] * Tr[1][2] + Tl[2][2] * Tr[2][2] + Tl[2][3] * Tr[3][2],
                Tl[2][0] * Tr[0][3] + Tl[2][1] * Tr[1][3] + Tl[2][2] * Tr[2][3] + Tl[2][3] * Tr[3][3],
                Tl[2][0] * Tr[0][4] + Tl[2][1] * Tr[1][4] + Tl[2][2] * Tr[2][4] + Tl[2][3] * Tr[3][4] + Tl[2][4]
            ],
            [
                Tl[3][0] * Tr[0][0] + Tl[3][1] * Tr[1][0] + Tl[3][2] * Tr[2][0] + Tl[3][3] * Tr[3][0],
                Tl[3][0] * Tr[0][1] + Tl[3][1] * Tr[1][1] + Tl[3][2] * Tr[2][1] + Tl[3][3] * Tr[3][1],
                Tl[3][0] * Tr[0][2] + Tl[3][1] * Tr[1][2] + Tl[3][2] * Tr[2][2] + Tl[3][3] * Tr[3][2],
                Tl[3][0] * Tr[0][3] + Tl[3][1] * Tr[1][3] + Tl[3][2] * Tr[2][3] + Tl[3][3] * Tr[3][3],
                Tl[3][0] * Tr[0][4] + Tl[3][1] * Tr[1][4] + Tl[3][2] * Tr[2][4] + Tl[3][3] * Tr[3][4] + Tl[3][4]
            ],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(Tn);
    }


    translate_self_by_delta(dx, dy, dz, dw, is_in_own_frame) {
        if (is_in_own_frame) {
            // translation in own frame
            let delta_in_parent = this.transform_vector(new Vector4D(dx, dy, dz, dw));
            this.matrix[0][4] += delta_in_parent.x;
            this.matrix[1][4] += delta_in_parent.y;
            this.matrix[2][4] += delta_in_parent.z;
            this.matrix[3][4] += delta_in_parent.w;
        } else {
            // translation in parent frame
            this.matrix[0][4] += dx;
            this.matrix[1][4] += dy;
            this.matrix[2][4] += dz;
            this.matrix[3][4] += dw;
        }
    }

    rotate_self_by_delta(plane_string, angle_rad, is_in_own_frame) {
        // plane string: 'XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'
        let c = Math.cos(angle_rad);
        let s = Math.sin(angle_rad);
        let R = [
            [1, 0, 0, 0,  0],
            [0, 1, 0, 0,  0],
            [0, 0, 1, 0,  0],
            [0, 0, 0, 1,  0],

            [0, 0, 0, 0,  1]
        ];
        switch (plane_string) {
            case 'XY':
                R[0][0] = c; R[0][1] = -s;
                R[1][0] = s; R[1][1] = c;
                break;
            case 'XZ':
                R[0][0] = c; R[0][2] = -s;
                R[2][0] = s; R[2][2] = c;
                break;
            case 'XW':
                R[0][0] = c; R[0][3] = -s;
                R[3][0] = s; R[3][3] = c;
                break;
            case 'YZ':
                R[1][1] = c; R[1][2] = -s;
                R[2][1] = s; R[2][2] = c;
                break;
            case 'YW':
                R[1][1] = c; R[1][3] = -s;
                R[3][1] = s; R[3][3] = c;
                break;
            case 'ZW':
                R[2][2] = c; R[2][3] = -s;
                R[3][2] = s; R[3][3] = c;
                break;
            default:
                console.error('Invalid plane string for rotation');
                return;
        }
        // let newT = this.transform_transform(new Transform4D(R));
        // this.matrix = newT.matrix;
        let Rdelta = new Transform4D(R);
        if (is_in_own_frame) {
            // Apply rotation in own frame
            let newT = this.transform_transform(Rdelta);
            this.matrix = newT.matrix;
        } else {
            // Apply rotation in parent frame
            let newT = Rdelta.transform_transform(this);
            // this.matrix = newT.matrix;
            // only copy the rotation part, keep the translation part
            // without rotation_only, we rotate around the parent origin instead of our own origin
            this.matrix = [
                [newT.matrix[0][0], newT.matrix[0][1], newT.matrix[0][2], newT.matrix[0][3], this.matrix[0][4]],
                [newT.matrix[1][0], newT.matrix[1][1], newT.matrix[1][2], newT.matrix[1][3], this.matrix[1][4]],
                [newT.matrix[2][0], newT.matrix[2][1], newT.matrix[2][2], newT.matrix[2][3], this.matrix[2][4]],
                [newT.matrix[3][0], newT.matrix[3][1], newT.matrix[3][2], newT.matrix[3][3], this.matrix[3][4]],
                [0, 0, 0, 0, 1]
            ];
        }
    }
            

    

    rotation_only() {
        let R = [
            [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3], 0],
            [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3], 0],
            [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3], 0],
            [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3], 0],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(R);
    }

    inverse() {
        // separate rotation and translation
        let R = [
            [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3]],
            [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3]],
            [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3]],
            [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3]]
        ];
        let t = [
            this.matrix[0][4],
            this.matrix[1][4],
            this.matrix[2][4],
            this.matrix[3][4]
        ];
        // transpose rotation
        let R_inv = [
            [R[0][0], R[1][0], R[2][0], R[3][0]],
            [R[0][1], R[1][1], R[2][1], R[3][1]],
            [R[0][2], R[1][2], R[2][2], R[3][2]],
            [R[0][3], R[1][3], R[2][3], R[3][3]]
        ];
        // new translation
        let t_inv = [
            -(R_inv[0][0] * t[0] + R_inv[0][1] * t[1] + R_inv[0][2] * t[2] + R_inv[0][3] * t[3]),
            -(R_inv[1][0] * t[0] + R_inv[1][1] * t[1] + R_inv[1][2] * t[2] + R_inv[1][3] * t[3]),
            -(R_inv[2][0] * t[0] + R_inv[2][1] * t[1] + R_inv[2][2] * t[2] + R_inv[2][3] * t[3]),
            -(R_inv[3][0] * t[0] + R_inv[3][1] * t[1] + R_inv[3][2] * t[2] + R_inv[3][3] * t[3])
        ];
        // combine into new matrix
        let invMatrix = [
            [R_inv[0][0], R_inv[0][1], R_inv[0][2], R_inv[0][3], t_inv[0]],
            [R_inv[1][0], R_inv[1][1], R_inv[1][2], R_inv[1][3], t_inv[1]],
            [R_inv[2][0], R_inv[2][1], R_inv[2][2], R_inv[2][3], t_inv[2]],
            [R_inv[3][0], R_inv[3][1], R_inv[3][2], R_inv[3][3], t_inv[3]],
            [0, 0, 0, 0, 1]
        ];
        return new Transform4D(invMatrix);
    }
}

// Hypercamera definition
let scene_bound = 10.0; // +10 means the scene goes from -10 to +10 in all dimensions
const hypercamera_height_above_ground = 1.0;
let hypercamera_T = new Transform4D([
    [1, 0, 0, 0, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 1, 0, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 1]
]); // hypercam in world
// let hf = 1.0; // hyper focal length
// let hypercamera_intrinsics = [
    // [hf, 0, 0, 0],
    // [0, hf, 0, 0],
    // [0, 0, hf, 0],
    // [0, 0, 0, 1]
// ]; // see TODO s , for now assume identity intrinsics
let hypercamera_sensor_size = 1
let hypercamera_sensor_uvl_range = [-1, 1, -1, 1, -1, 1]; // u_min, u_max, v_min, v_max, l_min, l_max
let hypercamera_is_unit_sensor = true;
let hypercamera_sensor_resolution = VOX;

// Define scene statically for now
class Hyperobject {
    constructor(vertices_in_object, edges, tetras, color, simulate_physics, show_vertices, mass, pose, name) {
        this.vertices_in_object = vertices_in_object; // in object frame
        this.edges = edges;
        this.tetras = tetras;
        this.color = color;
        this.simulate_physics = simulate_physics; // if true, object gets affected by physics
        this.show_vertices = show_vertices;
        this.mass = mass;
        this.pose = pose; // Transform4D from object frame to world frame
        this.name = name;
        // variables
        this.velocity_in_world = new Vector4D(0, 0, 0, 0);
        this.rotational_velocity = {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0};
        // computed properties
        this.update_vertices_in_world();
    }

    update_vertices_in_world() {
        this.vertices_in_world = [];
        for (let v of this.vertices_in_object) {
            let v_world = this.pose.transform_point(v);
            this.vertices_in_world.push(v_world);
        }
    }

    get_com() {
        return this.pose.origin();
    }
}

let hyperpyramid = new Hyperobject(
    // vertices in object frame
    [
        new Vector4D(0, 0, 1, 0),
        new Vector4D(1, 1, -1, 1),
        new Vector4D(1, -1, -1, -1),
        new Vector4D(-1, 1, -1, -1),
        new Vector4D(-1, -1, -1, 1)
    ],
    // edges
    [
        [0,1],[0,2],[0,3],[0,4],
        [1,2],[1,3],[1,4],
        [2,3],[2,4],
        [3,4]
    ],
    // tetras
    [
        [0,1,2,3],
        [0,1,2,4],
        [0,1,3,4],
        [0,2,3,4],
        [1,2,3,4]
    ],
    // color
    0x00ff00,
    // simulate_physics
    true,
    // show_vertices
    true,
    // mass
    1.0,
    // pose (Transform4D)
    new Transform4D([
        [1, 0, 0, 0, 4],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 1],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1]
    ]),
    // name
    "Hyperpyramid"
);

// Check WebGPU support
if (!navigator.gpu) {
  document.body.innerHTML = '<div style="color: red; padding: 20px;">WebGPU is not supported in your browser.</div>';
  throw new Error('WebGPU not supported');
}

let timingsInfosHtml = "";

// Stage 0: Create buffers and gather all vertices and tetras from visible hyperobjects
const s0_start = performance.now();
let visibleHyperobjects = [hyperpyramid];
// let vertices_in_world = hypercube.vertices_in_world;
// let tetras = hypercube.tetras.map(tetra => ({ indices: tetra, color: hypercube.color }));
let vertices_in_world = [];
let tetras = [];
for (let obj of visibleHyperobjects) {
    const base_index = vertices_in_world.length;
    // add vertices
    for (let v of obj.vertices_in_world) {
        vertices_in_world.push(v);
    }
    // add tetras with adjusted indices
    for (let tet of obj.tetras) {
        tetras.push({ indices: tet.map(vi => vi + base_index), color: obj.color });
    }
}
const s0_end = performance.now();
console.log(`Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms</p>`;
        
// ---------------------------------------------------------------------------------
// Stage 1: Per-vertex - Transform vertices from world to camera space
const s1_start = performance.now();
let vertices_in_suvl = new Array(vertices_in_world.length);
let vertices_in_1uvl = new Array(vertices_in_world.length);
const camera_inverse = hypercamera_T.inverse();
function perVertex(vertex_index, vertices_in_world, vertices_in_suvl, vertices_in_1uvl) {
    const vert_suvl = camera_inverse.transform_point(vertices_in_world[vertex_index]);
    vertices_in_suvl[vertex_index] = vert_suvl;
    vertices_in_1uvl[vertex_index] = new Vector4D(1.0, vert_suvl.y / vert_suvl.x, vert_suvl.z / vert_suvl.x, vert_suvl.w / vert_suvl.x);
}
for (let vi = 0; vi < vertices_in_world.length; vi++) { perVertex(vi, vertices_in_world, vertices_in_suvl, vertices_in_1uvl); } // run the "shader"
const s1_end = performance.now();
console.log("Stage 1: # of vertices transformed to camera space:", vertices_in_world.length, `in ${(s1_end - s1_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 1: # of vertices transformed to camera space: ${vertices_in_world.length} in ${(s1_end - s1_start).toFixed(2)} ms</p>`;

// ---------------------------------------------------------------------------------
// Stage 2: (CPU) Per-tetra - Exclude tetras with any vertex behind camera
const s2_start = performance.now();
let valid_tetras = [];
function perTetra(tetra_index, tetras, vertices_in_suvl, valid_tetras) {
    let tetra = tetras[tetra_index];
    let behind_camera = false;
    for (let vi of tetra.indices) {
        if (vertices_in_suvl[vi].x <= 0) { // S coordinate
            behind_camera = true;
            break;
        }
    }
    if (!behind_camera) {
        valid_tetras.push(tetra);
    }
}
for (let ti = 0; ti < tetras.length; ti++) { perTetra(ti, tetras, vertices_in_suvl, valid_tetras); } // run the "shader"
const s2_end = performance.now();
console.log("Stage 2: # of valid tetras:", valid_tetras.length, `from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms`);
timingsInfosHtml += `<p>Stage 2: # of valid tetras: ${valid_tetras.length} from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms</p>`;


const N_TETS = 5;

// Prepare tetra data
const tetraData = new Uint32Array(N_TETS * 5); // 4 vert idx per tet + 1 color
for (let i = 0; i < valid_tetras.length; i++) {
    const tetra = valid_tetras[i];
    tetraData[i * 5 + 0] = tetra.indices[0];
    tetraData[i * 5 + 1] = tetra.indices[1];
    tetraData[i * 5 + 2] = tetra.indices[2];
    tetraData[i * 5 + 3] = tetra.indices[3];
    tetraData[i * 5 + 4] = tetra.color;
}

const N_MAX_VERTS = N_TETS * 4 * 4; // 4 verts per tetra, 4 floats per vert (uvls)
// initialize vertex storage
const vertices1uvlsData = new Float32Array(N_MAX_VERTS);
for (let i = 0; i < vertices_in_1uvl.length; i++) {
  vertices1uvlsData[i * 4 + 0] = vertices_in_1uvl[i].y;
  vertices1uvlsData[i * 4 + 1] = vertices_in_1uvl[i].z;
  vertices1uvlsData[i * 4 + 2] = vertices_in_1uvl[i].w;
  vertices1uvlsData[i * 4 + 3] = vertices_in_suvl[i].x;
}

// initialize bvh
  const TILE_SZ = 1;
  const TILE_RES = VOX / TILE_SZ;
const MAX_ACCEL_STRUCTURE_SIZE = TILE_RES*TILE_RES*TILE_RES*N_TETS;
const accelStructureOffsetsData = new Uint32Array(TILE_RES*TILE_RES*TILE_RES);
const accelStructureCountsData = new Uint32Array(TILE_RES*TILE_RES*TILE_RES);
const accelStructureTetraIndicesData = new Uint32Array(MAX_ACCEL_STRUCTURE_SIZE);
// for now we assign all 5 pyramid tetras to all voxels
for (let i = 0; i < (TILE_RES*TILE_RES*TILE_RES); i++) {
  const TU = i % TILE_RES;
  const TV = Math.floor(i / TILE_RES) % TILE_RES;
  const TL = Math.floor(i / (TILE_RES*TILE_RES)); 
  // naive constant mapping
  accelStructureOffsetsData[i] = i * N_TETS;
  accelStructureCountsData[i] = N_TETS;
  for (let i_tet = 0; i_tet < N_TETS; i_tet++) {
    accelStructureTetraIndicesData[i * N_TETS + i_tet] = i_tet;
  }
}

// Initialize voxel grid (4x4x4)
const voxelData = new Float32Array(VOX*VOX*VOX*8); // 64x64x64 grid for simplicity
for (let i = 0; i < (VOX*VOX*VOX); i++) {
  const U = i % VOX;
  const V = Math.floor(i / VOX) % VOX;
  const L = Math.floor(i / (VOX*VOX));
  
  // Create interesting pattern
  let r, g, b, a, s;
  // if ((x + y + z) % 2 === 0) {
  //   r = Math.floor(x * 255 / (VOX-1));
  //   g = Math.floor(y * 255 / (VOX-1));
  //   b = Math.floor(z * 255 / (VOX-1));
  // } else {
  //   r = 255 - Math.floor(x * 255 / (VOX-1));
  //   g = 255 - Math.floor(z * 255 / (VOX-1));
  //   b = 255 - Math.floor(y * 255 / (VOX-1));
  // }
  // Random color
  r = 1.0;
  g = 1.0;
  b = 1.0;
  a = 0.0;
  if (U === 0 || U === (VOX-1) || V === 0 || V === (VOX-1) || L === 0 || L === (VOX-1)) {
    a = 0.5;
  }
  s = 1.0;
  
  // Pack RGBA into uint32 (make all visible)
  voxelData[i * 8 + 0] = r;
  voxelData[i * 8 + 1] = g;
  voxelData[i * 8 + 2] = b;
  voxelData[i * 8 + 3] = a;
  voxelData[i * 8 + 4] = s;
  voxelData[i * 8 + 5] = 0;
  voxelData[i * 8 + 6] = 0;
  voxelData[i * 8 + 7] = 0;
}



async function init() {
  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();
  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();
  
  context.configure({
    device,
    format,
    alphaMode: 'opaque',
  });

  // Stage 3.3 - Per voxel: tetra tests and final compute shader to write to voxels
  const stage3p3ShaderCode = `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

struct Voxel {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
    s: f32,
    _pad: u32,
    _pad2: u32,
    _pad3: u32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices_1uvls: array<Vector4D>;
@group(0) @binding(2) var<storage, read> cell_offsets: array<u32>;
@group(0) @binding(3) var<storage, read> cell_counts: array<u32>;
@group(0) @binding(4) var<storage, read> cell_tetra_indices: array<u32>;
@group(0) @binding(5) var<storage, read_write> voxels: array<Voxel>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // RES, TILE_RES, TILE_SZ, unused

fn signedVolume(a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> f32 {
    let ab = b - a;
    let ac = c - a;
    let ad = d - a;
    return dot(cross(ab, ac), ad) / 6.0;
}

fn barycentricCoordinates(P: vec3<f32>, A: vec3<f32>, B: vec3<f32>, C: vec3<f32>, D: vec3<f32>) -> vec4<f32> {
    let V = signedVolume(A, B, C, D);
    if (abs(V) < 1e-10) {
        return vec4<f32>(-1.0);
    }
    let alpha = signedVolume(P, B, C, D) / V;
    let beta = signedVolume(A, P, C, D) / V;
    let gamma = signedVolume(A, B, P, D) / V;
    let delta = signedVolume(A, B, C, P) / V;
    return vec4<f32>(alpha, beta, gamma, delta);
}

@compute @workgroup_size(4, 4, 4)
fn cs_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let RES = params.x;
    let TILE_RES = params.y;
    let TILE_SZ = params.z;
    
    let U = global_id.x;
    let V = global_id.y;
    let L = global_id.z;
    
    if (U >= RES || V >= RES || L >= RES) {
        return;
    }

      
    let voxel_index = U + V * RES + L * RES * RES;

    if (U == 0 || U == RES-1 || V == 0 || V == RES-1 || L == 0 || L == RES-1) {
     voxels[voxel_index] = Voxel(1.0, 1.0, 1.0, 0.1, 1.0, 0u, 0u, 0u);
     return;
     } 
    
    let TU = U / TILE_SZ;
    let TV = V / TILE_SZ;
    let TL = L / TILE_SZ;
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let u = S_U_START + (f32(U) + 0.5) / f32(RES) * S_U_RANGE;
    let v = S_V_START + (f32(V) + 0.5) / f32(RES) * S_V_RANGE;
    let l = S_L_START + (f32(L) + 0.5) / f32(RES) * S_L_RANGE;
    
    let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
    let cell_offset = cell_offsets[CELL_ID];
    let cell_count = cell_counts[CELL_ID];
  
    var best_voxel = voxels[voxel_index];
    best_voxel.s = 100000000.0; // TODO inf
    best_voxel.a = 0.0;
    
    for (var i = 0u; i < cell_count; i++) {
        let tetra_index = cell_tetra_indices[cell_offset + i];
        let tetra = tetras[tetra_index];
        
        let v0_1uvls = vertices_1uvls[tetra.i0];
        let v1_1uvls = vertices_1uvls[tetra.i1];
        let v2_1uvls = vertices_1uvls[tetra.i2];
        let v3_1uvls = vertices_1uvls[tetra.i3];
        
        let v0_s = v0_1uvls.w;
        let v1_s = v1_1uvls.w;
        let v2_s = v2_1uvls.w;
        let v3_s = v3_1uvls.w;
        
        let A = vec3<f32>(v0_1uvls.x, v0_1uvls.y, v0_1uvls.z);
        let B = vec3<f32>(v1_1uvls.x, v1_1uvls.y, v1_1uvls.z);
        let C = vec3<f32>(v2_1uvls.x, v2_1uvls.y, v2_1uvls.z);
        let D = vec3<f32>(v3_1uvls.x, v3_1uvls.y, v3_1uvls.z);
        let P = vec3<f32>(u, v, l);
        
        let u_min = min(min(v0_1uvls.x, v1_1uvls.x), min(v2_1uvls.x, v3_1uvls.x));
        let u_max = max(max(v0_1uvls.x, v1_1uvls.x), max(v2_1uvls.x, v3_1uvls.x));
        let v_min = min(min(v0_1uvls.y, v1_1uvls.y), min(v2_1uvls.y, v3_1uvls.y));
        let v_max = max(max(v0_1uvls.y, v1_1uvls.y), max(v2_1uvls.y, v3_1uvls.y));
        let l_min = min(min(v0_1uvls.z, v1_1uvls.z), min(v2_1uvls.z, v3_1uvls.z));
        let l_max = max(max(v0_1uvls.z, v1_1uvls.z), max(v2_1uvls.z, v3_1uvls.z));
        
        if (u < u_min || u > u_max || v < v_min || v > v_max || l < l_min || l > l_max) {
            continue;
        }
        
        let bary = barycentricCoordinates(P, A, B, C, D);
        
        if (all(bary >= vec4<f32>(0.0)) && all(bary <= vec4<f32>(1.0))) {
            let s = bary.x * v0_s + bary.y * v1_s + bary.z * v2_s + bary.w * v3_s;
            
            if (s < best_voxel.s) {
                best_voxel.r = f32(((tetra_index + 1u) * 53u) % 256u);
                best_voxel.g = f32(((tetra_index + 1u) * 97u) % 256u);
                best_voxel.b = f32(((tetra_index + 1u) * 193u) % 256u);
                best_voxel.a = 1.0;
                best_voxel.s = s;
            }
        }
    }
    
    voxels[voxel_index] = best_voxel;
}
`;

  // Create shader module
  const stage3p3ShaderModule = device.createShaderModule({
    code: stage3p3ShaderCode,
  });

  // DDA ray traversal shader code
  const shaderCode = `
struct Uniforms {
  cameraPos: vec3f,
  cameraDir: vec3f,
  cameraUp: vec3f,
  cameraRight: vec3f,
  resolution: vec2f,
}

struct Voxel {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
    s: f32,
    _pad: u32,
    _pad2: u32,
    _pad3: u32,
}

const fVOX: f32 = 64.0;
const iVOX: i32 = 64;

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> voxelGrid: array<Voxel>;

fn getVoxel(pos: vec3i) -> Voxel {
  if (pos.x < 0 || pos.x >= iVOX || pos.y < 0 || pos.y >= iVOX || pos.z < 0 || pos.z >= iVOX) {
    return Voxel(0.0, 0.0, 0.0, 0.0, 0.0, 0u, 0u, 0u);
  }
  let idx = pos.x + pos.y * iVOX + pos.z * iVOX * iVOX;
  return voxelGrid[idx];
}


fn unpackColor(voxel: Voxel) -> vec4f {
  let r = voxel.r;
  let g = voxel.g;
  let b = voxel.b;
  let a = voxel.a;
  return vec4f(r, g, b, a);
}

// DDA ray traversal through voxel grid
fn traceRay(origin: vec3f, dir: vec3f) -> vec4f {
  // Find intersection with grid bounding box (0,0,0) to (VOX,VOX,VOX)
  let boxMin = vec3f(0.0, 0.0, 0.0);
  let boxMax = vec3f(fVOX, fVOX, fVOX);
  
  let invDir = vec3f(1.0) / dir;
  let t0 = (boxMin - origin) * invDir;
  let t1 = (boxMax - origin) * invDir;
  
  let tmin = min(t0, t1);
  let tmax = max(t0, t1);
  
  let tenter = max(max(tmin.x, tmin.y), tmin.z);
  let texit = min(min(tmax.x, tmax.y), tmax.z);
  
  // Ray misses box or starts after exit
  if (tenter > texit || texit < 0.0) {
    return vec4f(0.1, 0.1, 0.15, 1.0);
  }
  
  // Start ray at entry point (or origin if inside box)
  let tstart = max(tenter, 0.0);
  var rayPos = origin + dir * tstart + dir * 0.001; // Small epsilon to ensure we're inside
  
  // Current voxel position
  var voxelPos = vec3i(floor(rayPos));
  
  // Clamp to valid range
  voxelPos = clamp(voxelPos, vec3i(0), vec3i(iVOX-1));
  
  // Step direction (1 or -1 for each axis)
  let step = vec3i(sign(dir));
  
  // Distance to next voxel boundary along each axis
  let deltaDist = abs(vec3f(1.0) / dir);
  
  // Initial side distances
  var sideDist: vec3f;
  if (dir.x < 0.0) {
    sideDist.x = (rayPos.x - f32(voxelPos.x)) * deltaDist.x;
  } else {
    sideDist.x = (f32(voxelPos.x + 1) - rayPos.x) * deltaDist.x;
  }
  if (dir.y < 0.0) {
    sideDist.y = (rayPos.y - f32(voxelPos.y)) * deltaDist.y;
  } else {
    sideDist.y = (f32(voxelPos.y + 1) - rayPos.y) * deltaDist.y;
  }
  if (dir.z < 0.0) {
    sideDist.z = (rayPos.z - f32(voxelPos.z)) * deltaDist.z;
  } else {
    sideDist.z = (f32(voxelPos.z + 1) - rayPos.z) * deltaDist.z;
  }
  
  // DDA traversal
  var hit = false;
  var compositeRayColor = vec4f(0.0, 0.0, 0.0, 0.0);
  var side = 0;
  let maxSteps = iVOX * 4;
  
  for (var i = 0; i < maxSteps; i++) {
    // Check current voxel
    let voxel = getVoxel(voxelPos);
    if (true) {
      let color = unpackColor(voxel);
      if (color.a > 0.0) {
        hit = true;
        // Simple shading based on face normal
        var shade = 1.0;
        if (side == 0) { shade = 0.9; }      // X face
        else if (side == 1) { shade = 1.0; } // Y face (top)
        else { shade = 0.7; }                // Z face
        
        var effectiveAlpha = color.a;
        var srcAlpha = effectiveAlpha * (1 - compositeRayColor.a);
        compositeRayColor = vec4f(compositeRayColor.rgb + color.rgb * srcAlpha, compositeRayColor.a + srcAlpha);
        if (compositeRayColor.a >= 0.99) {
          return compositeRayColor;
        }
      }
    }
    
    // Step to next voxel
    if (sideDist.x < sideDist.y) {
      if (sideDist.x < sideDist.z) {
        sideDist.x += deltaDist.x;
        voxelPos.x += step.x;
        side = 0;
      } else {
        sideDist.z += deltaDist.z;
        voxelPos.z += step.z;
        side = 2;
      }
    } else {
      if (sideDist.y < sideDist.z) {
        sideDist.y += deltaDist.y;
        voxelPos.y += step.y;
        side = 1;
      } else {
        sideDist.z += deltaDist.z;
        voxelPos.z += step.z;
        side = 2;
      }
    }
    
    // Check if ray left grid bounds
    if (voxelPos.x < -1 || voxelPos.x > iVOX || 
        voxelPos.y < -1 || voxelPos.y > iVOX || 
        voxelPos.z < -1 || voxelPos.z > iVOX) {
      break;
    }
  }
  
  // Sky color
  var skyColor = vec4f(0.1, 0.1, 0.15, 1.0);
  var effectiveAlpha = skyColor.a;
  var srcAlpha = effectiveAlpha * (1 - compositeRayColor.a);
  compositeRayColor = vec4f(compositeRayColor.rgb + skyColor.rbg * srcAlpha, compositeRayColor.a + srcAlpha);

  return compositeRayColor;
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
  // Full screen quad
  var pos = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f(1.0, -1.0),
    vec2f(-1.0, 1.0),
    vec2f(-1.0, 1.0),
    vec2f(1.0, -1.0),
    vec2f(1.0, 1.0)
  );
  return vec4f(pos[vertexIndex], 0.0, 1.0);
}

@fragment
fn fs_main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
  let uv = (fragCoord.xy / uniforms.resolution) * 2.0 - 1.0;
  let aspect = uniforms.resolution.x / uniforms.resolution.y;
  
  // Construct ray direction
  let rayDir = normalize(
    uniforms.cameraDir + 
    uniforms.cameraRight * uv.x * aspect +
    uniforms.cameraUp * uv.y
  );
  
  return traceRay(uniforms.cameraPos, rayDir);
}
`;
  
  // Create shader module
  const shaderModule = device.createShaderModule({
    code: shaderCode,
  });
  
  // Create uniform buffer
  // 4 vec4s (camera pos, dir, up, right) + 1 vec2 (resolution) + padding = 80 bytes
  const uniformBuffer = device.createBuffer({
    size: 80,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  
  // Create voxel storage buffer
  const voxelBuffer = device.createBuffer({
    size: voxelData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(voxelBuffer, 0, voxelData);
  
  // Create bind group layout
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: 'uniform' },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: 'read-only-storage' },
      },
    ],
  });
  
  const bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: { buffer: voxelBuffer } },
    ],
  });
  
  // Create pipeline
  const pipeline = device.createRenderPipeline({
    layout: device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout],
    }),
    vertex: {
      module: shaderModule,
      entryPoint: 'vs_main',
    },
    fragment: {
      module: shaderModule,
      entryPoint: 'fs_main',
      targets: [{ format }],
    },
    primitive: {
      topology: 'triangle-list',
    },
  });

  // Stage 3p3 Bind Groups ----
  // Create buffers
  
    const tetraBuffer = device.createBuffer({
        size: tetraData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(tetraBuffer, 0, tetraData);

      const vertices1uvlsBuffer = device.createBuffer({
        size: vertices1uvlsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(vertices1uvlsBuffer, 0, vertices1uvlsData);
    
    const cellCountsBuffer = device.createBuffer({
        size: accelStructureCountsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellCountsBuffer, 0, accelStructureCountsData);

    const cellOffsetsBuffer = device.createBuffer({
        size: accelStructureOffsetsData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellOffsetsBuffer, 0, accelStructureOffsetsData);

    const cellTetraIndicesBuffer = device.createBuffer({
        size: accelStructureTetraIndicesData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellTetraIndicesBuffer, 0, accelStructureTetraIndicesData);


  // Update params for rasterization
  const rasterParamsData = new Uint32Array([VOX, TILE_RES, TILE_SZ, 0]);
  const rasterParamsBuffer = device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(rasterParamsBuffer, 0, rasterParamsData);

  const stage3p3BindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
          { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
      ]
  });

  const stage3p3ParamsBindGroupLayout = device.createBindGroupLayout({
      entries: [
          { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
      ]
  });

  const stage3p3PipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [stage3p3BindGroupLayout, stage3p3ParamsBindGroupLayout]
  });

  const stage3p3Pipeline = device.createComputePipeline({
      layout: stage3p3PipelineLayout,
      compute: {
          module: stage3p3ShaderModule,
          entryPoint: 'cs_main'
      }
  });

  const stage3p3BindGroup = device.createBindGroup({
      layout: stage3p3BindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: tetraBuffer } },
          { binding: 1, resource: { buffer: vertices1uvlsBuffer } },
          { binding: 2, resource: { buffer: cellOffsetsBuffer } },
          { binding: 3, resource: { buffer: cellCountsBuffer } },
          { binding: 4, resource: { buffer: cellTetraIndicesBuffer } },
          { binding: 5, resource: { buffer: voxelBuffer } }
      ]
  });

  const stage3p3ParamsBindGroup = device.createBindGroup({
      layout: stage3p3ParamsBindGroupLayout,
      entries: [
          { binding: 0, resource: { buffer: rasterParamsBuffer } }
      ]
  });
  
  
  function updateCamera() {
    const rotY = parseFloat(rotYSlider.value) * Math.PI / 180;
    const rotX = parseFloat(rotXSlider.value) * Math.PI / 180;
    const dist = parseFloat(distSlider.value);
    
    document.getElementById('rotYValue').textContent = rotYSlider.value;
    document.getElementById('rotXValue').textContent = rotXSlider.value;
    document.getElementById('distValue').textContent = distSlider.value;
    
    // Camera position (orbit around center at 2,2,2)
    const cx = VOX / 2 + Math.cos(rotY) * Math.cos(rotX) * dist;
    const cy = VOX / 2 + Math.sin(rotX) * dist;
    const cz = VOX / 2 + Math.sin(rotY) * Math.cos(rotX) * dist;
    
    // Camera direction (look at center)
    const target = [VOX / 2, VOX / 2, VOX / 2];
    const dx = target[0] - cx;
    const dy = target[1] - cy;
    const dz = target[2] - cz;
    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const dir = [dx/len, dy/len, dz/len];
    
    // Camera up and right vectors
    const worldUp = [0, 1, 0];
    const right = [
      dir[1] * worldUp[2] - dir[2] * worldUp[1],
      dir[2] * worldUp[0] - dir[0] * worldUp[2],
      dir[0] * worldUp[1] - dir[1] * worldUp[0],
    ];
    const rlen = Math.sqrt(right[0]**2 + right[1]**2 + right[2]**2);
    right[0] /= rlen; right[1] /= rlen; right[2] /= rlen;
    
    const up = [
      right[1] * dir[2] - right[2] * dir[1],
      right[2] * dir[0] - right[0] * dir[2],
      right[0] * dir[1] - right[1] * dir[0],
    ];
    
    // Update uniform buffer
    const uniforms = new Float32Array([
      cx, cy, cz, 0,
      dir[0], dir[1], dir[2], 0,
      up[0], up[1], up[2], 0,
      right[0], right[1], right[2], 0,
      canvas.width, canvas.height, 0, 0,
    ]);
    device.queue.writeBuffer(uniformBuffer, 0, uniforms);
  }
  
  function render() {
    updateCamera();
    
    const commandEncoder = device.createCommandEncoder();
    const textureView = context.getCurrentTexture().createView();

    // compute pass to update voxel data (if needed)
    if (true) {
      const computePass = commandEncoder.beginComputePass();
      computePass.setPipeline(stage3p3Pipeline);
      computePass.setBindGroup(0, stage3p3BindGroup);
      computePass.setBindGroup(1, stage3p3ParamsBindGroup);
      const workgroupCount = Math.ceil(VOX / 4);
      computePass.dispatchWorkgroups(workgroupCount, workgroupCount, workgroupCount);
      computePass.end();
    }
    
    const renderPass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: textureView,
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        loadOp: 'clear',
        storeOp: 'store',
      }],
    });
    
    renderPass.setPipeline(pipeline);
    renderPass.setBindGroup(0, bindGroup);
    renderPass.draw(6);
    renderPass.end();
    
    device.queue.submit([commandEncoder.finish()]);
    requestAnimationFrame(render);
  }
  
  rotYSlider.addEventListener('input', () => {});
  rotXSlider.addEventListener('input', () => {});
  distSlider.addEventListener('input', () => {});
  
  render();
}

init().catch(err => {
  console.error(err);
  document.body.innerHTML += '<div style="color: red; padding: 20px;">Error: ' + err.message + '</div>';
});
</script>
</body>
</html>
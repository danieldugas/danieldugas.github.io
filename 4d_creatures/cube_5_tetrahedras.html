<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetrahedra Tiling Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #controls label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        #slider {
            width: 200px;
        }
        #info {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="slider">Separation: <span id="value">0.0</span></label>
        <input type="range" id="slider" min="0" max="100" value="0" step="1">
        <div id="info">5 tetrahedra tiling a cube</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Define cube vertices
        const s = 1; // half-size of cube
        const cubeVertices = [
            new THREE.Vector3(-s, -s, -s), // 0
            new THREE.Vector3( s, -s, -s), // 1
            new THREE.Vector3( s,  s, -s), // 2
            new THREE.Vector3(-s,  s, -s), // 3
            new THREE.Vector3(-s, -s,  s), // 4
            new THREE.Vector3( s, -s,  s), // 5
            new THREE.Vector3( s,  s,  s), // 6
            new THREE.Vector3(-s,  s,  s)  // 7
        ];
        
        // Define 5 tetrahedra that tile the cube
        // Each tetrahedron is defined by 4 vertex indices
        const tetrahedraIndices = [
            [0, 1, 3, 4], // Bottom-left tetrahedron
            [1, 2, 3, 6], // Top-front tetrahedron
            [1, 4, 5, 6], // Right tetrahedron
            [3, 4, 6, 7], // Left tetrahedron
            [1, 3, 4, 6]  // Center tetrahedron
        ];
        
        const colors = [
            0xff4444, // Red
            0x44ff44, // Green
            0x4444ff, // Blue
            0xffff44, // Yellow
            0xff44ff  // Magenta
        ];
        
        // Create tetrahedra
        const tetrahedra = [];
        
        tetrahedraIndices.forEach((indices, i) => {
            // Get the 4 vertices for this tetrahedron
            const v0 = cubeVertices[indices[0]];
            const v1 = cubeVertices[indices[1]];
            const v2 = cubeVertices[indices[2]];
            const v3 = cubeVertices[indices[3]];
            
            // Create geometry from these 4 vertices
            const geometry = new THREE.BufferGeometry();
            
            // Define the 4 triangular faces of the tetrahedron
            const vertices = new Float32Array([
                // Face 1: v0, v1, v2
                v0.x, v0.y, v0.z,
                v1.x, v1.y, v1.z,
                v2.x, v2.y, v2.z,
                // Face 2: v0, v1, v3
                v0.x, v0.y, v0.z,
                v1.x, v1.y, v1.z,
                v3.x, v3.y, v3.z,
                // Face 3: v0, v2, v3
                v0.x, v0.y, v0.z,
                v2.x, v2.y, v2.z,
                v3.x, v3.y, v3.z,
                // Face 4: v1, v2, v3
                v1.x, v1.y, v1.z,
                v2.x, v2.y, v2.z,
                v3.x, v3.y, v3.z
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                color: colors[i],
                flatShading: true,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Calculate centroid for separation
            const centroid = new THREE.Vector3()
                .add(v0)
                .add(v1)
                .add(v2)
                .add(v3)
                .multiplyScalar(0.25);
            
            mesh.userData.centroid = centroid;
            mesh.userData.vertices = [v0.clone(), v1.clone(), v2.clone(), v3.clone()];
            
            scene.add(mesh);
            tetrahedra.push(mesh);
        });
        
        // Add wireframe cube for reference
        const cubeEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(2*s, 2*s, 2*s));
        const cubeLine = new THREE.LineSegments(
            cubeEdges,
            new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true })
        );
        scene.add(cubeLine);
        
        // Slider control
        const slider = document.getElementById('slider');
        const valueDisplay = document.getElementById('value');
        
        function updateTetrahedra(separation) {
            tetrahedra.forEach(tetra => {
                const centroid = tetra.userData.centroid;
                
                // Move the entire tetrahedron away from the center (0,0,0)
                const direction = centroid.clone().normalize();
                const offset = direction.multiplyScalar(separation);
                tetra.position.copy(offset);
            });
        }
        
        slider.addEventListener('input', (e) => {
            const separation = parseFloat(e.target.value) / 50; // Scale to reasonable range
            valueDisplay.textContent = (separation).toFixed(2);
            updateTetrahedra(separation);
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the entire scene
            scene.rotation.y += 0.005;
            scene.rotation.x = Math.sin(Date.now() * 0.0005) * 0.2;
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #projection-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
        }
        .projection-view {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        .projection-label {
            color: white;
            text-align: center;
            padding: 5px;
            background: rgba(0, 0, 0, 0.9);
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        WASD: Move selected vertex (XY)<br>
        Q/E: Move selected vertex (Z)<br>
        Mouse drag: Rotate view<br>
        Mouse wheel: Zoom<br>
        Click: Select vertex<br>
        Selected: <span id="selected">None</span>
    </div>
    <div id="main-canvas"></div>
    <div id="projection-container">
        <div class="projection-view">
            <div class="projection-label">XZ Projection (Top View)</div>
            <div id="xz-canvas"></div>
        </div>
        <div class="projection-view">
            <div class="projection-label">YZ Projection (Side View)</div>
            <div id="yz-canvas"></div>
        </div>
        <div class="projection-view">
            <div class="projection-label">WZ Projection (AnaKata View)</div>
            <div id="wz-canvas"></div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OrbitControls implementation
        THREE.OrbitControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.enabled = true;
            this.target = new THREE.Vector3();
            
            const scope = this;
            const rotateSpeed = 1.0;
            const zoomSpeed = 1.0;
            
            let rotateStart = new THREE.Vector2();
            let rotateEnd = new THREE.Vector2();
            let rotateDelta = new THREE.Vector2();
            
            let spherical = new THREE.Spherical();
            let sphericalDelta = new THREE.Spherical();
            
            let scale = 1;
            const EPS = 0.000001;
            
            this.update = function() {
                const offset = new THREE.Vector3();
                offset.copy(scope.camera.position).sub(scope.target);
                
                spherical.setFromVector3(offset);
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
                spherical.phi = Math.max(EPS, Math.min(Math.PI - EPS, spherical.phi));
                spherical.radius *= scale;
                
                offset.setFromSpherical(spherical);
                scope.camera.position.copy(scope.target).add(offset);
                scope.camera.lookAt(scope.target);
                
                sphericalDelta.set(0, 0, 0);
                scale = 1;
            };
            
            function onMouseDown(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                rotateStart.set(event.clientX, event.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            
            function onMouseMove(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                rotateEnd.set(event.clientX, event.clientY);
                rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(rotateSpeed);
                
                sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight;
                sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight;
                
                rotateStart.copy(rotateEnd);
                scope.update();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            function onMouseWheel(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                if (event.deltaY < 0) {
                    scale /= 0.95;
                } else if (event.deltaY > 0) {
                    scale *= 0.95;
                }
                scope.update();
            }
            
            this.domElement.addEventListener('mousedown', onMouseDown);
            this.domElement.addEventListener('wheel', onMouseWheel);
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('main-canvas').appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement); // Add OrbitControls
        
        // Create bounding box
        const boxSize = 10;
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        const boxEdges = new THREE.EdgesGeometry(boxGeometry);
        const boxMaterial = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
        const boundingBox = new THREE.LineSegments(boxEdges, boxMaterial);
        scene.add(boundingBox);

        // Setup XZ projection (top view)
        const projectionSize = 200;
        const xzScene = new THREE.Scene();
        xzScene.background = new THREE.Color(0x0a0a1a);
        const xzCamera = new THREE.OrthographicCamera(-6, 6, 6, -6, 0.1, 100);
        xzCamera.position.set(20, 0, 0);
        xzCamera.lookAt(0, 0, 0);
        const xzRenderer = new THREE.WebGLRenderer({ antialias: true });
        xzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('xz-canvas').appendChild(xzRenderer.domElement);

        // Setup YZ projection (side view)
        const yzScene = new THREE.Scene();
        yzScene.background = new THREE.Color(0x0a0a1a);
        const yzCamera = new THREE.OrthographicCamera(-6, 6, 6, -6, 0.1, 100);
        yzCamera.position.set(20, 0, 0);
        yzCamera.lookAt(0, 0, 0);
        const yzRenderer = new THREE.WebGLRenderer({ antialias: true });
        yzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('yz-canvas').appendChild(yzRenderer.domElement);

        // Setup WZ projection (AnaKata view)
        const wzScene = new THREE.Scene();
        wzScene.background = new THREE.Color(0x0a0a1a);
        const wzCamera = new THREE.OrthographicCamera(-6, 6, 6, -6, 0.1, 100);
        wzCamera.position.set(20, 0, 0);
        wzCamera.lookAt(0, 0, 0);
        const wzRenderer = new THREE.WebGLRenderer({ antialias: true });
        wzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('wz-canvas').appendChild(wzRenderer.domElement);

        // Add bounding boxes to projections
        const xzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        xzBox.rotation.y = Math.PI / 2;
        xzScene.add(xzBox);

        const yzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        yzBox.rotation.y = Math.PI / 2;
        yzScene.add(yzBox);

        const wzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        wzBox.rotation.y = Math.PI / 2;
        wzScene.add(wzBox);

        // 4D transform class prototype (just implement init, and origin() for now)
        class Vector4D {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
        }
        class Transform4D {
            // constructor() {
            //     this.matrix = [
            //         [1, 0, 0, 0, 0],
            //         [0, 1, 0, 0, 0],
            //         [0, 0, 1, 0, 0],
            //         [0, 0, 0, 1, 0],
            //         [0, 0, 0, 0, 1]
            //     ];
            // }
            constructor(matrix) {
                this.matrix = matrix;
            }

            static origin() {
                return Vector4D(this.matrix[0][4], this.matrix[1][4], this.matrix[2][4], this.matrix[3][4]);
            }
        }

        // 4D Scene Bodies
        let hypercamera_T = new Transform4D([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
        ]);
        let hf = 1.0; // hyper focal length
        let hypercamera_intrinsics = [
            [hf, 0, 0, 0],
            [0, hf, 0, 0],
            [0, 0, hf, 0],
            [0, 0, 0, 1]
        ];
        let hypercamera_sensor_uvl_range = [-1, 1, -1, 1, -1, 1]; // u_min, u_max, v_min, v_max, l_min, l_max
        let hypercube = {
            vertices: [
                [-1, -1, -1, -1],
                [ 1, -1, -1, -1],
                [ 1,  1, -1, -1],
                [-1,  1, -1, -1],
                [-1, -1,  1, -1],
                [ 1, -1,  1, -1],
                [ 1,  1,  1, -1],
                [-1,  1,  1, -1],
                [-1, -1, -1,  1],
                [ 1, -1, -1,  1],
                [ 1,  1, -1,  1],
                [-1,  1, -1,  1],
                [-1, -1,  1,  1],
                [ 1, -1,  1,  1],
                [ 1,  1,  1,  1],
                [-1,  1,  1,  1]
            ],
            edges: [
                [0,1],[1,2],[2,3],[3,0],
                [4,5],[5,6],[6,7],[7,4],
                [0,4],[1,5],[2,6],[3,7],
                [8,9],[9,10],[10,11],[11,8],
                [12,13],[13,14],[14,15],[15,12],
                [8,12],[9,13],[10,14],[11,15],
                [0,8],[1,9],[2,10],[3,11],
                [4,12],[5,13],[6,14],[7,15]
            ]
        };


        // Graph data structure
        let world_vertices = [];
        let world_edges = [];
        let xz_vertices = [];
        let xz_edges = [];
        let yz_vertices = [];
        let yz_edges = [];
        let wz_vertices = [];
        let wz_edges = [];
        // meshes reprojected "inside" the camera sensor
        let uvl_vertices = [];
        let uvl_edges = [];
        let selectedVertexIndex = 0;

        // Materials
        const vertexMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
        const selectedVertexMaterial = new THREE.MeshBasicMaterial({ color: 0xff3366 });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x4477ff, linewidth: 2 });

        // Threejs Mesh objects
        let vertexMeshes = [];
        let edgeMeshes = [];
        let xzVertexMeshes = [];
        let xzEdgeMeshes = [];
        let yzVertexMeshes = [];
        let yzEdgeMeshes = [];
        let wzVertexMeshes = [];
        let wzEdgeMeshes = [];

        // Generate initial constant mesh
        function generateConstantMesh() {
            // Create vertices in 3D space
            world_vertices = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(3, 2, 1),
                new THREE.Vector3(-2, 3, -2),
                new THREE.Vector3(-3, -1, 2),
                new THREE.Vector3(2, -2, -1),
                new THREE.Vector3(0, 4, 3),
                new THREE.Vector3(1, -3, -2),
                new THREE.Vector3(-2, -2, 1)
            ];
            
            // Create edges connecting vertices
            world_edges = [
                [0, 1], [0, 2], [0, 3], [0, 4],
                [1, 2], [2, 3], [3, 4], [4, 1],
                [1, 5], [2, 5],
                [5, 6], [6, 7], [7, 3]
            ];
        }


        // Create vertex meshes
        function createThreeJSPrimitivesFromScene() {
            // Project 4D Scene into 2D Orthogonal Views
            xz_vertices = [];
            for (let v of hypercube.vertices) {
                xz_vertices.push(new THREE.Vector3(0, v[0], v[2]));
            }
            xz_edges = hypercube.edges.slice();

            yz_vertices = [];
            for (let v of hypercube.vertices) {
                yz_vertices.push(new THREE.Vector3(0, v[1], v[2]));
            }
            yz_edges = hypercube.edges.slice();

            wz_vertices = [];
            for (let v of hypercube.vertices) {
                wz_vertices.push(new THREE.Vector3(0, v[3], v[2]));
            }
            wz_edges = hypercube.edges.slice();

            // Project Meshes into 3D Camera Sensor
            uvl_vertices = [];
            for (let v of hypercube.vertices) {
                uvl_vertices.push(new THREE.Vector3(v[0], v[1], v[2]));
            }
            uvl_edges = hypercube.edges.slice();

            // Clear existing meshes
            vertexMeshes.forEach(mesh => scene.remove(mesh));
            vertexMeshes = [];
            xzVertexMeshes.forEach(mesh => xzScene.remove(mesh));
            xzVertexMeshes = [];
            yzVertexMeshes.forEach(mesh => yzScene.remove(mesh));
            yzVertexMeshes = [];
            wzVertexMeshes.forEach(mesh => wzScene.remove(mesh));
            wzVertexMeshes = [];
            
            uvl_vertices.forEach((pos, i) => {
                // UVL 3D Camera Sensor
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(pos);
                scene.add(mesh);
                vertexMeshes.push(mesh);
            });
                
            xz_vertices.forEach((pos, i) => {
                // XZ projection (top view - looking down Y axis)
                const xzGeometry = new THREE.CircleGeometry(0.3, 16);
                const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                const xzMesh = new THREE.Mesh(xzGeometry, material);
                xzMesh.position.set(pos.x, pos.y, pos.z);
                xzMesh.rotation.y = Math.PI / 2;
                xzScene.add(xzMesh);
                xzVertexMeshes.push(xzMesh);
            });

            yz_vertices.forEach((pos, i) => {
                // YZ projection (side view - looking from X axis)
                const yzGeometry = new THREE.CircleGeometry(0.3, 16);
                const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                const yzMesh = new THREE.Mesh(yzGeometry, material);
                yzMesh.position.set(pos.x, pos.y, pos.z);
                yzMesh.rotation.y = Math.PI / 2;
                yzScene.add(yzMesh);
                yzVertexMeshes.push(yzMesh);
            });

            wz_vertices.forEach((pos, i) => {
                // WZ projection (AnaKata view - looking from W axis)
                const wzGeometry = new THREE.CircleGeometry(0.3, 16);
                const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                const wzMesh = new THREE.Mesh(wzGeometry, material);
                wzMesh.position.set(pos.x, pos.y, pos.z);
                wzMesh.rotation.y = Math.PI / 2;
                wzScene.add(wzMesh);
                wzVertexMeshes.push(wzMesh);
            });

            // Create edge meshes
            // Clear existing edges
            edgeMeshes.forEach(mesh => scene.remove(mesh));
            edgeMeshes = [];
            xzEdgeMeshes.forEach(mesh => xzScene.remove(mesh));
            xzEdgeMeshes = [];
            yzEdgeMeshes.forEach(mesh => yzScene.remove(mesh));
            yzEdgeMeshes = [];
            wzEdgeMeshes.forEach(mesh => wzScene.remove(mesh));
            wzEdgeMeshes = [];
            
            uvl_edges.forEach(([i, j]) => {
                // Main 3D scene
                const points = [uvl_vertices[i], uvl_vertices[j]];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, edgeMaterial);
                scene.add(line);
                edgeMeshes.push(line);
            });
                
            xz_edges.forEach(([i, j]) => {
                // XZ projection
                const xzPoints = [
                    new THREE.Vector3(xz_vertices[i].x, xz_vertices[i].y, xz_vertices[i].z),
                    new THREE.Vector3(xz_vertices[j].x, xz_vertices[j].y, xz_vertices[j].z)
                ];
                const xzGeometry = new THREE.BufferGeometry().setFromPoints(xzPoints);
                const xzLine = new THREE.Line(xzGeometry, edgeMaterial);
                xzScene.add(xzLine);
                xzEdgeMeshes.push(xzLine);
            });

            yz_edges.forEach(([i, j]) => {
                // YZ projection
                const yzPoints = [
                    new THREE.Vector3(yz_vertices[i].x, yz_vertices[i].y, yz_vertices[i].z),
                    new THREE.Vector3(yz_vertices[j].x, yz_vertices[j].y, yz_vertices[j].z)
                ];
                const yzGeometry = new THREE.BufferGeometry().setFromPoints(yzPoints);
                const yzLine = new THREE.Line(yzGeometry, edgeMaterial);
                yzScene.add(yzLine);
                yzEdgeMeshes.push(yzLine);
            });

            wz_edges.forEach(([i, j]) => {
                // WZ projection
                const wzPoints = [
                    new THREE.Vector3(wz_vertices[i].x, wz_vertices[i].y, wz_vertices[i].z),
                    new THREE.Vector3(wz_vertices[j].x, wz_vertices[j].y, wz_vertices[j].z)
                ];
                const wzGeometry = new THREE.BufferGeometry().setFromPoints(wzPoints);
                const wzLine = new THREE.Line(wzGeometry, edgeMaterial);
                wzScene.add(wzLine);
                wzEdgeMeshes.push(wzLine);
            });
        }

        // Update the entire graph
        function updateGraph() {
            createThreeJSPrimitivesFromScene();
        }

        // Keyboard controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse controls for vertex selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            // Ignore clicks during drag
            if (event.button !== 0) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vertexMeshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                selectedVertexIndex = vertexMeshes.indexOf(clickedMesh);
                document.getElementById('selected').textContent = `Vertex ${selectedVertexIndex}`;
                updateGraph();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Movement speed
        const moveSpeed = 0.1;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Handle WASD movement for selected vertex
            if (world_vertices.length > 0 && selectedVertexIndex < world_vertices.length) {
                let moved = false;
                
                if (keys['w']) {
                    world_vertices[selectedVertexIndex].y += moveSpeed;
                    moved = true;
                }
                if (keys['s']) {
                    world_vertices[selectedVertexIndex].y -= moveSpeed;
                    moved = true;
                }
                if (keys['a']) {
                    world_vertices[selectedVertexIndex].x -= moveSpeed;
                    moved = true;
                }
                if (keys['d']) {
                    world_vertices[selectedVertexIndex].x += moveSpeed;
                    moved = true;
                }
                if (keys['q']) {
                    world_vertices[selectedVertexIndex].z += moveSpeed;
                    moved = true;
                }
                if (keys['e']) {
                    world_vertices[selectedVertexIndex].z -= moveSpeed;
                    moved = true;
                }
                
                if (moved) {
                    updateGraph();
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
            xzRenderer.render(xzScene, xzCamera);
            yzRenderer.render(yzScene, yzCamera);
            wzRenderer.render(wzScene, wzCamera);
        }

        // Initialize
        updateGraph();
        document.getElementById('selected').textContent = `Vertex ${selectedVertexIndex}`;
        animate();
    </script>
</body>
</html>
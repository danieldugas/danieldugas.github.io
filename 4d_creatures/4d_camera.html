<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypercamera</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #projection-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
        }
        .projection-view {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        .projection-label {
            color: white;
            text-align: center;
            padding: 5px;
            background: rgba(0, 0, 0, 0.9);
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        You are looking at the 3D sensor of a 4D hypercamera.<br>
        WASD: Move camera forwards, sideways<br>
        Q/E: Move camera in ana, kata directions<br>
        IJKL: Rotate camera up/down, left/right<br>
        U/O: Rotate camera in wx plane<br>
        Y/P: Rotate camera in wy plane<br>
        Mouse drag: Rotate sensor view<br>
        Mouse wheel: Zoom<br>
        Click: Select vertex<br>
        Selected: <span id="selected">None</span>
    </div>
    <div id="main-canvas"></div>
    <div id="projection-container">
        <div class="projection-view">
            <div class="projection-label">XZ Projection (Side View)</div>
            <div id="xz-canvas"></div>
        </div>
        <div class="projection-view">
            <div class="projection-label">YZ Projection (Back View)</div>
            <div id="yz-canvas"></div>
        </div>
        <div class="projection-view">
            <div class="projection-label">WZ Projection (AnaKata View)</div>
            <div id="wz-canvas"></div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>

        // 4D transform class prototype (just implement init, and origin() for now)
        class Vector4D {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            add(v) {
                return new Vector4D(this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w);
            }
            subtract(v) {
                return new Vector4D(this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w);
            }
            multiply_by_scalar(s) {
                return new Vector4D(this.x * s, this.y * s, this.z * s, this.w * s);
            }
        }
        class Transform4D {
            // constructor() {
            //     this.matrix = [
            //         [1, 0, 0, 0, 0],
            //         [0, 1, 0, 0, 0],
            //         [0, 0, 1, 0, 0],
            //         [0, 0, 0, 1, 0],
            //         [0, 0, 0, 0, 1]
            //     ];
            // }
            constructor(matrix) {
                this.matrix = matrix;
            }

            origin() {
                return new Vector4D(this.matrix[0][4], this.matrix[1][4], this.matrix[2][4], this.matrix[3][4]);
            }

            // transform_point(v: Vector4D): Vector4D
            transform_point(v) {
                let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w + this.matrix[0][4];
                let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w + this.matrix[1][4];
                let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w + this.matrix[2][4];
                let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w + this.matrix[3][4];
                return new Vector4D(x, y, z, w);
            }

            transform_vector(v) {
                let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w;
                let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w;
                let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w;
                let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w;
                return new Vector4D(x, y, z, w);
            }

            transform_transform(T) {
                // matrix multiplication: this.matrix * T.matrix
                // inC_T_B * inB_T_A  -> inC_T_A
                // inC_T_B.transform_transform(inB_T_A) -> inC_T_A
                let Tl = this.matrix;
                let Tr = T.matrix;
                let Tn = [
                    [
                        Tl[0][0] * Tr[0][0] + Tl[0][1] * Tr[1][0] + Tl[0][2] * Tr[2][0] + Tl[0][3] * Tr[3][0],
                        Tl[0][0] * Tr[0][1] + Tl[0][1] * Tr[1][1] + Tl[0][2] * Tr[2][1] + Tl[0][3] * Tr[3][1],
                        Tl[0][0] * Tr[0][2] + Tl[0][1] * Tr[1][2] + Tl[0][2] * Tr[2][2] + Tl[0][3] * Tr[3][2],
                        Tl[0][0] * Tr[0][3] + Tl[0][1] * Tr[1][3] + Tl[0][2] * Tr[2][3] + Tl[0][3] * Tr[3][3],
                        Tl[0][0] * Tr[0][4] + Tl[0][1] * Tr[1][4] + Tl[0][2] * Tr[2][4] + Tl[0][3] * Tr[3][4] + Tl[0][4]
                    ],
                    [
                        Tl[1][0] * Tr[0][0] + Tl[1][1] * Tr[1][0] + Tl[1][2] * Tr[2][0] + Tl[1][3] * Tr[3][0],
                        Tl[1][0] * Tr[0][1] + Tl[1][1] * Tr[1][1] + Tl[1][2] * Tr[2][1] + Tl[1][3] * Tr[3][1],
                        Tl[1][0] * Tr[0][2] + Tl[1][1] * Tr[1][2] + Tl[1][2] * Tr[2][2] + Tl[1][3] * Tr[3][2],
                        Tl[1][0] * Tr[0][3] + Tl[1][1] * Tr[1][3] + Tl[1][2] * Tr[2][3] + Tl[1][3] * Tr[3][3],
                        Tl[1][0] * Tr[0][4] + Tl[1][1] * Tr[1][4] + Tl[1][2] * Tr[2][4] + Tl[1][3] * Tr[3][4] + Tl[1][4]
                    ],
                    [
                        Tl[2][0] * Tr[0][0] + Tl[2][1] * Tr[1][0] + Tl[2][2] * Tr[2][0] + Tl[2][3] * Tr[3][0],
                        Tl[2][0] * Tr[0][1] + Tl[2][1] * Tr[1][1] + Tl[2][2] * Tr[2][1] + Tl[2][3] * Tr[3][1],
                        Tl[2][0] * Tr[0][2] + Tl[2][1] * Tr[1][2] + Tl[2][2] * Tr[2][2] + Tl[2][3] * Tr[3][2],
                        Tl[2][0] * Tr[0][3] + Tl[2][1] * Tr[1][3] + Tl[2][2] * Tr[2][3] + Tl[2][3] * Tr[3][3],
                        Tl[2][0] * Tr[0][4] + Tl[2][1] * Tr[1][4] + Tl[2][2] * Tr[2][4] + Tl[2][3] * Tr[3][4] + Tl[2][4]
                    ],
                    [
                        Tl[3][0] * Tr[0][0] + Tl[3][1] * Tr[1][0] + Tl[3][2] * Tr[2][0] + Tl[3][3] * Tr[3][0],
                        Tl[3][0] * Tr[0][1] + Tl[3][1] * Tr[1][1] + Tl[3][2] * Tr[2][1] + Tl[3][3] * Tr[3][1],
                        Tl[3][0] * Tr[0][2] + Tl[3][1] * Tr[1][2] + Tl[3][2] * Tr[2][2] + Tl[3][3] * Tr[3][2],
                        Tl[3][0] * Tr[0][3] + Tl[3][1] * Tr[1][3] + Tl[3][2] * Tr[2][3] + Tl[3][3] * Tr[3][3],
                        Tl[3][0] * Tr[0][4] + Tl[3][1] * Tr[1][4] + Tl[3][2] * Tr[2][4] + Tl[3][3] * Tr[3][4] + Tl[3][4]
                    ],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(Tn);
            }


            translate_self_by_delta(dx, dy, dz, dw, is_in_own_frame) {
                if (is_in_own_frame) {
                    // translation in own frame
                    let delta_in_parent = this.transform_vector(new Vector4D(dx, dy, dz, dw));
                    this.matrix[0][4] += delta_in_parent.x;
                    this.matrix[1][4] += delta_in_parent.y;
                    this.matrix[2][4] += delta_in_parent.z;
                    this.matrix[3][4] += delta_in_parent.w;
                } else {
                    // translation in parent frame
                    this.matrix[0][4] += dx;
                    this.matrix[1][4] += dy;
                    this.matrix[2][4] += dz;
                    this.matrix[3][4] += dw;
                }
            }

            rotate_self_by_delta(plane_string, angle_rad, is_in_own_frame) {
                // plane string: 'XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'
                let c = Math.cos(angle_rad);
                let s = Math.sin(angle_rad);
                let R = [
                    [1, 0, 0, 0,  0],
                    [0, 1, 0, 0,  0],
                    [0, 0, 1, 0,  0],
                    [0, 0, 0, 1,  0],

                    [0, 0, 0, 0,  1]
                ];
                switch (plane_string) {
                    case 'XY':
                        R[0][0] = c; R[0][1] = -s;
                        R[1][0] = s; R[1][1] = c;
                        break;
                    case 'XZ':
                        R[0][0] = c; R[0][2] = -s;
                        R[2][0] = s; R[2][2] = c;
                        break;
                    case 'XW':
                        R[0][0] = c; R[0][3] = -s;
                        R[3][0] = s; R[3][3] = c;
                        break;
                    case 'YZ':
                        R[1][1] = c; R[1][2] = -s;
                        R[2][1] = s; R[2][2] = c;
                        break;
                    case 'YW':
                        R[1][1] = c; R[1][3] = -s;
                        R[3][1] = s; R[3][3] = c;
                        break;
                    case 'ZW':
                        R[2][2] = c; R[2][3] = -s;
                        R[3][2] = s; R[3][3] = c;
                        break;
                    default:
                        console.error('Invalid plane string for rotation');
                        return;
                }
                // let newT = this.transform_transform(new Transform4D(R));
                // this.matrix = newT.matrix;
                let Rdelta = new Transform4D(R);
                if (is_in_own_frame) {
                    // Apply rotation in own frame
                    let newT = this.transform_transform(Rdelta);
                    this.matrix = newT.matrix;
                } else {
                    // Apply rotation in parent frame
                    let newT = Rdelta.transform_transform(this);
                    // this.matrix = newT.matrix;
                    // only copy the rotation part, keep the translation part
                    // without rotation_only, we rotate around the parent origin instead of our own origin
                    this.matrix = [
                        [newT.matrix[0][0], newT.matrix[0][1], newT.matrix[0][2], newT.matrix[0][3], this.matrix[0][4]],
                        [newT.matrix[1][0], newT.matrix[1][1], newT.matrix[1][2], newT.matrix[1][3], this.matrix[1][4]],
                        [newT.matrix[2][0], newT.matrix[2][1], newT.matrix[2][2], newT.matrix[2][3], this.matrix[2][4]],
                        [newT.matrix[3][0], newT.matrix[3][1], newT.matrix[3][2], newT.matrix[3][3], this.matrix[3][4]],
                        [0, 0, 0, 0, 1]
                    ];
                }
            }
                    

            

            rotation_only() {
                let R = [
                    [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3], 0],
                    [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3], 0],
                    [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3], 0],
                    [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3], 0],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(R);
            }

            inverse() {
                // separate rotation and translation
                let R = [
                    [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3]],
                    [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3]],
                    [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3]],
                    [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3]]
                ];
                let t = [
                    this.matrix[0][4],
                    this.matrix[1][4],
                    this.matrix[2][4],
                    this.matrix[3][4]
                ];
                // transpose rotation
                let R_inv = [
                    [R[0][0], R[1][0], R[2][0], R[3][0]],
                    [R[0][1], R[1][1], R[2][1], R[3][1]],
                    [R[0][2], R[1][2], R[2][2], R[3][2]],
                    [R[0][3], R[1][3], R[2][3], R[3][3]]
                ];
                // new translation
                let t_inv = [
                    -(R_inv[0][0] * t[0] + R_inv[0][1] * t[1] + R_inv[0][2] * t[2] + R_inv[0][3] * t[3]),
                    -(R_inv[1][0] * t[0] + R_inv[1][1] * t[1] + R_inv[1][2] * t[2] + R_inv[1][3] * t[3]),
                    -(R_inv[2][0] * t[0] + R_inv[2][1] * t[1] + R_inv[2][2] * t[2] + R_inv[2][3] * t[3]),
                    -(R_inv[3][0] * t[0] + R_inv[3][1] * t[1] + R_inv[3][2] * t[2] + R_inv[3][3] * t[3])
                ];
                // combine into new matrix
                let invMatrix = [
                    [R_inv[0][0], R_inv[0][1], R_inv[0][2], R_inv[0][3], t_inv[0]],
                    [R_inv[1][0], R_inv[1][1], R_inv[1][2], R_inv[1][3], t_inv[1]],
                    [R_inv[2][0], R_inv[2][1], R_inv[2][2], R_inv[2][3], t_inv[2]],
                    [R_inv[3][0], R_inv[3][1], R_inv[3][2], R_inv[3][3], t_inv[3]],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(invMatrix);
            }
        }

        // params
        let SIMULATE_PHYSICS = true;

        // Hyperscene and Hypercam definition
        // 4D Scene Bodies
        let scene_bound = 10.0;
        const hypercamera_height_above_ground = 1.0;
        let hypercamera_T = new Transform4D([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
        ]); // hypercam in world
        // let hf = 1.0; // hyper focal length
        // let hypercamera_intrinsics = [
            // [hf, 0, 0, 0],
            // [0, hf, 0, 0],
            // [0, 0, hf, 0],
            // [0, 0, 0, 1]
        // ];
        let hypercamera_sensor_uvl_range = [-1, 1, -1, 1, -1, 1]; // u_min, u_max, v_min, v_max, l_min, l_max
        let hypercamera_is_unit_sensor = true;
        // define a hypercube object
        let hypercube = {
            vertices_in_world: [
                new Vector4D(-1, -1, -1, -1),
                new Vector4D( 1, -1, -1, -1),
                new Vector4D( 1,  1, -1, -1),
                new Vector4D(-1,  1, -1, -1),
                new Vector4D(-1, -1,  1, -1),
                new Vector4D( 1, -1,  1, -1),
                new Vector4D( 1,  1,  1, -1),
                new Vector4D(-1,  1,  1, -1),
                new Vector4D(-1, -1, -1,  1),
                new Vector4D( 1, -1, -1,  1),
                new Vector4D( 1,  1, -1,  1),
                new Vector4D(-1,  1, -1,  1),
                new Vector4D(-1, -1,  1,  1),
                new Vector4D( 1, -1,  1,  1),
                new Vector4D( 1,  1,  1,  1),
                new Vector4D(-1,  1,  1,  1)
            ],
            edges: [
                [0,1],[1,2],[2,3],[3,0],
                [4,5],[5,6],[6,7],[7,4],
                [0,4],[1,5],[2,6],[3,7],
                [8,9],[9,10],[10,11],[11,8],
                [12,13],[13,14],[14,15],[15,12],
                [8,12],[9,13],[10,14],[11,15],
                [0,8],[1,9],[2,10],[3,11],
                [4,12],[5,13],[6,14],[7,15]
            ],
            velocity_in_world: new Vector4D(0, 0, 0, 0),
            rotational_velocity: {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0},
            mass: 1.0
        };
        // Manually move hypercube by x+ and y+
        hypercube.vertices_in_world.forEach(v => {
            v.x += 4;
            // v.y += 3;
        });
        // Define a hyperpyramid object
        let hyperpyramid = {
            vertices_in_world: [
                new Vector4D(0, 0, 1, 0),
                new Vector4D(1, 1, -1, 1),
                new Vector4D(1, -1, -1, -1),
                new Vector4D(-1, 1, -1, -1),
                new Vector4D(-1, -1, -1, 1)
            ],
            edges: [
                [0,1],[0,2],[0,3],[0,4],
                [1,2],[1,3],[1,4],
                [2,3],[2,4],
                [3,4]
            ],
            velocity_in_world: new Vector4D(0, 0, 0, 0),
            rotational_velocity: {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0},
            mass: 1.0
        };
        // Manually move to hyperpyramid by x- and y-
        hyperpyramid.vertices_in_world.forEach(v => {
            v.x -= 4;
            v.y -= 3;
            v.w += 4;
        });

        // build a hyperfloor surface (triangle mesh)
        // 1. assign a z for each (x,y,w) grid point
        // 2. build triangles between grid points
        const GRID_LIMS = {
            x_min: -scene_bound,
            x_max: scene_bound,
            y_min: -scene_bound,
            y_max: scene_bound,
            z_min: -scene_bound,
            z_max: scene_bound,
            w_min: -scene_bound,
            w_max: scene_bound
        };
        const N_TILES = 2;
        const GRID_RES = 2 * scene_bound / N_TILES; // grid resolution
        const n_i = Math.floor((GRID_LIMS.x_max - GRID_LIMS.x_min) / GRID_RES) + 1;
        const n_j = Math.floor((GRID_LIMS.y_max - GRID_LIMS.y_min) / GRID_RES) + 1;
        const n_k = Math.floor((GRID_LIMS.w_max - GRID_LIMS.w_min) / GRID_RES) + 1;
        function floor_heightmap(x, y, w) {
            return -2 + x * 0.1; // flat floor at z = -2
        }
        let grid_vertices = [];
        let grid_edges = [];
        for (let i = 0; i < n_i; i++) {
            for (let j = 0; j < n_j; j++) {
                for (let k = 0; k < n_k; k++) {
                    let x = GRID_LIMS.x_min + i * GRID_RES;
                    let y = GRID_LIMS.y_min + j * GRID_RES;
                    let w = GRID_LIMS.w_min + k * GRID_RES;
                    // let z = Math.sin(0.2 * x) * Math.cos(0.2 * y) * 5; // example height function
                    let z = floor_heightmap(x, y, w);
                    grid_vertices.push(new Vector4D(x, y, z, w));
                    // add an edge to the next vertex in x
                    if (i < n_i - 1) {
                        let next_index = grid_vertices.length + (n_j * n_k) - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in y
                    if (j < n_j - 1) {
                        let next_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in w
                    if (k < n_k - 1) {
                        let next_index = grid_vertices.length;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge between next x and next y
                    if (i < n_i - 1 && j < n_j - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_y_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([next_x_index, next_y_index]);
                    }
                    // add an edge between next x and next w
                    if (i < n_i - 1 && k < n_k - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_x_index, next_w_index]);
                    }
                    // add an edge between next y and next w
                    if (j < n_j - 1 && k < n_k - 1) {
                        let next_y_index = grid_vertices.length + n_k - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_y_index, next_w_index]);
                    }
                }
            }
        }
        let hyperfloor = {
            vertices_in_world: grid_vertices,
            edges: grid_edges
        };

        let hyperscene_visible_objects = [hypercube, hyperpyramid];

        // OrbitControls implementation
        THREE.OrbitControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.enabled = true;
            this.target = new THREE.Vector3();
            
            const scope = this;
            const rotateSpeed = 1.0;
            const zoomSpeed = 1.0;
            
            let rotateStart = new THREE.Vector2();
            let rotateEnd = new THREE.Vector2();
            let rotateDelta = new THREE.Vector2();
            
            let spherical = new THREE.Spherical();
            let sphericalDelta = new THREE.Spherical();
            
            let scale = 1;
            const EPS = 0.000001;
            
            this.update = function() {
                const offset = new THREE.Vector3();
                offset.copy(scope.camera.position).sub(scope.target);
                
                spherical.setFromVector3(offset);
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
                spherical.phi = Math.max(EPS, Math.min(Math.PI - EPS, spherical.phi));
                spherical.radius *= scale;
                
                offset.setFromSpherical(spherical);
                scope.camera.position.copy(scope.target).add(offset);
                scope.camera.lookAt(scope.target);
                
                sphericalDelta.set(0, 0, 0);
                scale = 1;
            };
            
            function onMouseDown(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                rotateStart.set(event.clientX, event.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            
            function onMouseMove(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                rotateEnd.set(event.clientX, event.clientY);
                rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(rotateSpeed);
                
                sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight;
                sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight;
                
                rotateStart.copy(rotateEnd);
                scope.update();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            function onMouseWheel(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                if (event.deltaY < 0) {
                    scale /= 0.95;
                } else if (event.deltaY > 0) {
                    scale *= 0.95;
                }
                scope.update();
            }
            
            this.domElement.addEventListener('mousedown', onMouseDown);
            this.domElement.addEventListener('wheel', onMouseWheel);
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 2, 2);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('main-canvas').appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement); // Add OrbitControls
        
        // Create bounding box
        const UVLBoxSize = 2; // we assume the UVL range is -1 to 1 in each dimension (see hypercamera_sensor_uvl_range)
        const boxGeometry = new THREE.BoxGeometry(UVLBoxSize, UVLBoxSize, UVLBoxSize);
        const boxEdges = new THREE.EdgesGeometry(boxGeometry);
        const boxMaterial = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
        const boundingBox = new THREE.LineSegments(boxEdges, boxMaterial);
        scene.add(boundingBox);

        // Setup XZ projection (top view)
        const projectionSize = 200;
        const xzScene = new THREE.Scene();
        const CSZ = scene_bound * 1.2;
        xzScene.background = new THREE.Color(0x0a0a1a);
        const xzCamera = new THREE.OrthographicCamera(-CSZ, CSZ, CSZ, -CSZ, 0.1, 100);
        xzCamera.position.set(20, 0, 0);
        xzCamera.lookAt(0, 0, 0);
        const xzRenderer = new THREE.WebGLRenderer({ antialias: true });
        xzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('xz-canvas').appendChild(xzRenderer.domElement);

        // Setup YZ projection (side view)
        const yzScene = new THREE.Scene();
        yzScene.background = new THREE.Color(0x0a0a1a);
        const yzCamera = new THREE.OrthographicCamera(-CSZ, CSZ, CSZ, -CSZ, 0.1, 100);
        yzCamera.position.set(20, 0, 0);
        yzCamera.lookAt(0, 0, 0);
        const yzRenderer = new THREE.WebGLRenderer({ antialias: true });
        yzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('yz-canvas').appendChild(yzRenderer.domElement);

        // Setup WZ projection (AnaKata view)
        const wzScene = new THREE.Scene();
        wzScene.background = new THREE.Color(0x0a0a1a);
        const wzCamera = new THREE.OrthographicCamera(-CSZ, CSZ, CSZ, -CSZ, 0.1, 100);
        wzCamera.position.set(20, 0, 0);
        wzCamera.lookAt(0, 0, 0);
        const wzRenderer = new THREE.WebGLRenderer({ antialias: true });
        wzRenderer.setSize(projectionSize, projectionSize);
        document.getElementById('wz-canvas').appendChild(wzRenderer.domElement);

        // Add bounding boxes to projections
        const boxSize = scene_bound * 2;
        const xzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        xzBox.rotation.y = Math.PI / 2;
        xzScene.add(xzBox);

        const yzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        yzBox.rotation.y = Math.PI / 2;
        yzScene.add(yzBox);

        const wzBox = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(boxSize, boxSize)),
            new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 })
        );
        wzBox.rotation.y = Math.PI / 2;
        wzScene.add(wzBox);


        let selectedVertexIndex = 0;

        // Materials
        const vertexMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
        const selectedVertexMaterial = new THREE.MeshBasicMaterial({ color: 0xff3366 });
        const outOfSensorVertexMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x4477ff, linewidth: 2 });
        const outOfSensorEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x444444, linewidth: 1 });
        const frustrumMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 1 });
        const frustrumFarMaterial = new THREE.LineBasicMaterial({ color: 0x777700, linewidth: 1 });

        // Threejs Mesh objects
        let vertexMeshes = [];
        let edgeMeshes = [];
        let xzVertexMeshes = [];
        let xzEdgeMeshes = [];
        let yzVertexMeshes = [];
        let yzEdgeMeshes = [];
        let wzVertexMeshes = [];
        let wzEdgeMeshes = [];


        // Create vertex meshes
        function createThreeJSPrimitivesFromScene() {

            // Clear existing meshes
            vertexMeshes.forEach(mesh => mesh.geometry.dispose());
            vertexMeshes.forEach(mesh => mesh.material.dispose());
            vertexMeshes.forEach(mesh => scene.remove(mesh));
            vertexMeshes = [];
            xzVertexMeshes.forEach(mesh => mesh.geometry.dispose());
            xzVertexMeshes.forEach(mesh => mesh.material.dispose());
            xzVertexMeshes.forEach(mesh => xzScene.remove(mesh));
            xzVertexMeshes = [];
            yzVertexMeshes.forEach(mesh => mesh.geometry.dispose());
            yzVertexMeshes.forEach(mesh => mesh.material.dispose());
            yzVertexMeshes.forEach(mesh => yzScene.remove(mesh));
            yzVertexMeshes = [];
            wzVertexMeshes.forEach(mesh => mesh.geometry.dispose());
            wzVertexMeshes.forEach(mesh => mesh.material.dispose());
            wzVertexMeshes.forEach(mesh => wzScene.remove(mesh));
            wzVertexMeshes = [];
            // Clear existing edges
            edgeMeshes.forEach(mesh => mesh.geometry.dispose());
            edgeMeshes.forEach(mesh => mesh.material.dispose());
            edgeMeshes.forEach(mesh => scene.remove(mesh));
            edgeMeshes = [];
            xzEdgeMeshes.forEach(mesh => mesh.geometry.dispose());
            xzEdgeMeshes.forEach(mesh => mesh.material.dispose());
            xzEdgeMeshes.forEach(mesh => xzScene.remove(mesh));
            xzEdgeMeshes = [];
            yzEdgeMeshes.forEach(mesh => mesh.geometry.dispose());
            yzEdgeMeshes.forEach(mesh => mesh.material.dispose());
            yzEdgeMeshes.forEach(mesh => yzScene.remove(mesh));
            yzEdgeMeshes = [];
            wzEdgeMeshes.forEach(mesh => mesh.geometry.dispose());
            wzEdgeMeshes.forEach(mesh => mesh.material.dispose());
            wzEdgeMeshes.forEach(mesh => wzScene.remove(mesh));
            wzEdgeMeshes = [];

            // Graph data structure
            // meshes reprojected "inside" the camera sensor

            // Create camera frustum
            // origin to (1, u-, v-, l-), (1, u+, v-, l-), ... reprojected to camera frame, reprojected to world
            let camera_edges_in_suvl = [
                [[0, 0, 0, 0], [1, -1, -1, -1]],
                [[0, 0, 0, 0], [1,  1, -1, -1]],
                [[0, 0, 0, 0], [1,  1,  1, -1]],
                [[0, 0, 0, 0], [1, -1,  1, -1]],
                [[0, 0, 0, 0], [1, -1, -1,  1]],
                [[0, 0, 0, 0], [1,  1, -1,  1]],
                [[0, 0, 0, 0], [1,  1,  1,  1]],
                [[0, 0, 0, 0], [1, -1,  1,  1]]
            ];
            let camera_edges_in_world = [];
            for (let [start, end] of camera_edges_in_suvl) {
                let start_in_cam = new Vector4D(start[0], start[1], start[2], start[3]); // TODO: apply reverse intrinsics
                let end_in_cam = new Vector4D(end[0], end[1], end[2], end[3]); // TODO: apply reverse intrinsics
                let start_in_world = hypercamera_T.transform_point(start_in_cam); // TODO: apply reverse camera transform
                let end_in_world = hypercamera_T.transform_point(end_in_cam); // TODO: apply reverse camera transform
                camera_edges_in_world.push([start_in_world, end_in_world]);
            }

            // Project 4D Scene into 2D Orthogonal Views
            // XZ projection
            for (let hyperobject of hyperscene_visible_objects) {
                let xz_vertices = [];
                let xz_edges = [];
                xz_vertices = [];
                xz_edges = [];
                // hyperobject
                for (let v of hyperobject.vertices_in_world) {
                    xz_vertices.push(new THREE.Vector3(0, v.z, -v.x));
                }
                for (let [i, j] of hyperobject.edges) {
                    xz_edges.push([i, j]);
                }
                xz_vertices.forEach((pos, i) => {
                    const xzGeometry = new THREE.CircleGeometry(0.3, 16);
                    const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                    const xzMesh = new THREE.Mesh(xzGeometry, material);
                    xzMesh.position.set(pos.x, pos.y, pos.z);
                    xzMesh.rotation.y = Math.PI / 2;
                    xzScene.add(xzMesh);
                    xzVertexMeshes.push(xzMesh);
                });
                xz_edges.forEach(([i, j]) => {
                    const xzPoints = [
                        new THREE.Vector3(xz_vertices[i].x, xz_vertices[i].y, xz_vertices[i].z),
                        new THREE.Vector3(xz_vertices[j].x, xz_vertices[j].y, xz_vertices[j].z)
                    ];
                    const xzGeometry = new THREE.BufferGeometry().setFromPoints(xzPoints);
                    const xzLine = new THREE.Line(xzGeometry, edgeMaterial);
                    xzScene.add(xzLine);
                    xzEdgeMeshes.push(xzLine);
                });
            }
            // hyperfloor
            for (let [i, j] of hyperfloor.edges) {
                vi_xz = new THREE.Vector3(0, hyperfloor.vertices_in_world[i].z, -hyperfloor.vertices_in_world[i].x);
                vj_xz = new THREE.Vector3(0, hyperfloor.vertices_in_world[j].z, -hyperfloor.vertices_in_world[j].x);
                const xzPoints = [
                    new THREE.Vector3(vi_xz.x, vi_xz.y, vi_xz.z),
                    new THREE.Vector3(vj_xz.x, vj_xz.y, vj_xz.z)
                ];
                const xzGeometry = new THREE.BufferGeometry().setFromPoints(xzPoints);
                const xzLine = new THREE.Line(xzGeometry, edgeMaterial);
                xzScene.add(xzLine);
                xzEdgeMeshes.push(xzLine);
            }
            // camera frustrum
            camera_edges_in_world.forEach(([start, end]) => {
                const xzPoints = [
                    new THREE.Vector3(0, start.z, -start.x),
                    new THREE.Vector3(0, end.z, -end.x)
                ];
                const xzGeometry = new THREE.BufferGeometry().setFromPoints(xzPoints);
                const is_closest_4 = end.y > start.y;
                const material = is_closest_4 ? frustrumMaterial : frustrumFarMaterial;
                const xzLine = new THREE.Line(xzGeometry, material);
                xzScene.add(xzLine);
                xzEdgeMeshes.push(xzLine);
            });

            // YZ projection
            // hyperobjects
            for (let hyperobject of hyperscene_visible_objects) {
                let yz_vertices = [];
                let yz_edges = [];
                yz_vertices = [];
                for (let v of hyperobject.vertices_in_world) {
                    yz_vertices.push(new THREE.Vector3(0, v.z, -v.y));
                }
                yz_edges = hyperobject.edges.slice();
                yz_vertices.forEach((pos, i) => {
                    const yzGeometry = new THREE.CircleGeometry(0.3, 16);
                    const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                    const yzMesh = new THREE.Mesh(yzGeometry, material);
                    yzMesh.position.set(pos.x, pos.y, pos.z);
                    yzMesh.rotation.y = Math.PI / 2;
                    yzScene.add(yzMesh);
                    yzVertexMeshes.push(yzMesh);
                });
                yz_edges.forEach(([i, j]) => {
                    const yzPoints = [
                        new THREE.Vector3(yz_vertices[i].x, yz_vertices[i].y, yz_vertices[i].z),
                        new THREE.Vector3(yz_vertices[j].x, yz_vertices[j].y, yz_vertices[j].z)
                    ];
                    const yzGeometry = new THREE.BufferGeometry().setFromPoints(yzPoints);
                    const yzLine = new THREE.Line(yzGeometry, edgeMaterial);
                    yzScene.add(yzLine);
                    yzEdgeMeshes.push(yzLine);
                });
            }
            // hyperfloor
            for (let [i, j] of hyperfloor.edges) {
                vi_yz = new THREE.Vector3(0, hyperfloor.vertices_in_world[i].z, -hyperfloor.vertices_in_world[i].y);
                vj_yz = new THREE.Vector3(0, hyperfloor.vertices_in_world[j].z, -hyperfloor.vertices_in_world[j].y);
                const yzPoints = [
                    new THREE.Vector3(vi_yz.x, vi_yz.y, vi_yz.z),
                    new THREE.Vector3(vj_yz.x, vj_yz.y, vj_yz.z)
                ];
                const yzGeometry = new THREE.BufferGeometry().setFromPoints(yzPoints);
                const yzLine = new THREE.Line(yzGeometry, edgeMaterial);
                yzScene.add(yzLine);
                yzEdgeMeshes.push(yzLine);
            }
            // camera frustrum
            camera_edges_in_world.forEach(([start, end]) => {
                const yzPoints = [
                    new THREE.Vector3(0, start.z, -start.y),
                    new THREE.Vector3(0, end.z, -end.y)
                ];
                const yzGeometry = new THREE.BufferGeometry().setFromPoints(yzPoints);
                const is_closest_4 = -end.x > -start.x;
                const material = is_closest_4 ? frustrumMaterial : frustrumFarMaterial;
                const yzLine = new THREE.Line(yzGeometry, material);
                yzScene.add(yzLine);
                yzEdgeMeshes.push(yzLine);
            });

            // WZ projection
            for (let hyperobject of hyperscene_visible_objects) {
                let wz_vertices = [];
                let wz_edges = [];
                wz_vertices = [];
                for (let v of hyperobject.vertices_in_world) {
                    wz_vertices.push(new THREE.Vector3(0, v.z, -v.w));
                }
                wz_edges = hyperobject.edges.slice();
                wz_vertices.forEach((pos, i) => {
                    const wzGeometry = new THREE.CircleGeometry(0.3, 16);
                    const material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                    const wzMesh = new THREE.Mesh(wzGeometry, material);
                    wzMesh.position.set(pos.x, pos.y, pos.z);
                    wzMesh.rotation.y = Math.PI / 2;
                    wzScene.add(wzMesh);
                    wzVertexMeshes.push(wzMesh);
                });
                wz_edges.forEach(([i, j]) => {
                    const wzPoints = [
                        new THREE.Vector3(wz_vertices[i].x, wz_vertices[i].y, wz_vertices[i].z),
                        new THREE.Vector3(wz_vertices[j].x, wz_vertices[j].y, wz_vertices[j].z)
                    ];
                    const wzGeometry = new THREE.BufferGeometry().setFromPoints(wzPoints);
                    const wzLine = new THREE.Line(wzGeometry, edgeMaterial);
                    wzScene.add(wzLine);
                    wzEdgeMeshes.push(wzLine);
                });
            }
            // hyperfloor
            for (let [i, j] of hyperfloor.edges) {
                vi_wz = new THREE.Vector3(0, hyperfloor.vertices_in_world[i].z, -hyperfloor.vertices_in_world[i].w);
                vj_wz = new THREE.Vector3(0, hyperfloor.vertices_in_world[j].z, -hyperfloor.vertices_in_world[j].w);
                const wzPoints = [
                    new THREE.Vector3(vi_wz.x, vi_wz.y, vi_wz.z),
                    new THREE.Vector3(vj_wz.x, vj_wz.y, vj_wz.z)
                ];
                const wzGeometry = new THREE.BufferGeometry().setFromPoints(wzPoints);
                const wzLine = new THREE.Line(wzGeometry, edgeMaterial);
                wzScene.add(wzLine);
                wzEdgeMeshes.push(wzLine);
            }
            // camera frustrum
            camera_edges_in_world.forEach(([start, end]) => {
                const wzPoints = [
                    new THREE.Vector3(0, start.z, -start.w),
                    new THREE.Vector3(0, end.z, -end.w)
                ];
                const wzGeometry = new THREE.BufferGeometry().setFromPoints(wzPoints);
                const is_closest_4 = end.y > start.y;
                const material = is_closest_4 ? frustrumMaterial : frustrumFarMaterial;
                const wzLine = new THREE.Line(wzGeometry, material);
                wzScene.add(wzLine);
                wzEdgeMeshes.push(wzLine);
            });

            // Project Meshes into 3D Camera Sensor
            for (let hyperobject of hyperscene_visible_objects) {
                let uvl_vertices = [];
                let uvl_vertices_s = []; // scaling factors
                let uvl_edges = [];
                uvl_vertices = [];
                uvl_vertices_s = []; // scaling, a.k.a distance from camera sensor (>1 means further, <0 means behind, <1 means closer)
                for (let v of hyperobject.vertices_in_world) {
                    // Camera equation uvl ~= K * [R|t] * XYZW
                    // we define x as the depth axis here (aka camera cube sensor is at x=1)
                    // let xyzw_camframe = new Vector4D(v.x, v.y, v.z, v.w); // TODO do actual transform to camera frame
                    let xyzw_camframe = hypercamera_T.inverse().transform_point(v);
                    let suvl = [ xyzw_camframe.x, xyzw_camframe.y, xyzw_camframe.z, xyzw_camframe.w ]; // TODO: apply intrinsics
                    let uvl = [ suvl[1] / suvl[0], suvl[2] / suvl[0], suvl[3] / suvl[0] ]; // perspective divide
                    uvl_vertices.push(new THREE.Vector3(uvl[0], uvl[1], uvl[2]));
                    uvl_vertices_s.push(suvl[0]);
                }
                uvl_edges = hyperobject.edges.slice();
                uvl_vertices.forEach((pos, i) => {
                    // UVL 3D Camera Sensor
                    const s = uvl_vertices_s[i];
                    // Only render if in front of camera
                    const is_in_front = s > 0;
                    const is_inside_sensor = (
                        pos.x >= hypercamera_sensor_uvl_range[0] &&
                        pos.x <= hypercamera_sensor_uvl_range[1] &&
                        pos.y >= hypercamera_sensor_uvl_range[2] &&
                        pos.y <= hypercamera_sensor_uvl_range[3] &&
                        pos.z >= hypercamera_sensor_uvl_range[4] &&
                        pos.z <= hypercamera_sensor_uvl_range[5]
                    );
                    if (s > 0) {
                        const geometry = new THREE.SphereGeometry(0.03, 16, 16);
                        let material = i === selectedVertexIndex ? selectedVertexMaterial : vertexMaterial;
                        if (!is_inside_sensor) {
                            material = outOfSensorVertexMaterial;
                        }
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(pos);
                        mesh.selectable_idx = i;
                        scene.add(mesh);
                        vertexMeshes.push(mesh);
                    }
                });
                uvl_edges.forEach(([i, j]) => {
                    // Main 3D scene
                    const are_both_vertices_in_front = (uvl_vertices_s[i] > 0 && uvl_vertices_s[j] > 0);
                    const are_both_vertices_inside_sensor = (
                        uvl_vertices[i].x >= hypercamera_sensor_uvl_range[0] &&
                        uvl_vertices[i].x <= hypercamera_sensor_uvl_range[1] &&
                        uvl_vertices[i].y >= hypercamera_sensor_uvl_range[2] &&
                        uvl_vertices[i].y <= hypercamera_sensor_uvl_range[3] &&
                        uvl_vertices[i].z >= hypercamera_sensor_uvl_range[4] &&
                        uvl_vertices[i].z <= hypercamera_sensor_uvl_range[5] &&
                        uvl_vertices[j].x >= hypercamera_sensor_uvl_range[0] &&
                        uvl_vertices[j].x <= hypercamera_sensor_uvl_range[1] &&
                        uvl_vertices[j].y >= hypercamera_sensor_uvl_range[2] &&
                        uvl_vertices[j].y <= hypercamera_sensor_uvl_range[3] &&
                        uvl_vertices[j].z >= hypercamera_sensor_uvl_range[4] &&
                        uvl_vertices[j].z <= hypercamera_sensor_uvl_range[5]
                    );
                    if (uvl_vertices_s[i] > 0 && uvl_vertices_s[j] > 0) {
                        const points = [uvl_vertices[i], uvl_vertices[j]];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        let material = edgeMaterial;
                        if (!are_both_vertices_inside_sensor) {
                            material = outOfSensorEdgeMaterial;
                        }
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        edgeMeshes.push(line);
                    }
                });
            }
            // hyperfloor
            let uvl_vertices = [];
            let uvl_vertices_s = []; // scaling factors
            let uvl_edges = [];
            uvl_vertices = [];
            uvl_vertices_s = []; // scaling, a.k.a distance from camera sensor (>1 means further, <0 means behind, <1 means closer)
            for (let v of hyperfloor.vertices_in_world) {
                // Camera equation uvl ~= K * [R|t] * XYZW
                // we define x as the depth axis here (aka camera cube sensor is at x=1)
                // let xyzw_camframe = new Vector4D(v.x, v.y, v.z, v.w); // TODO do actual transform to camera frame
                let xyzw_camframe = hypercamera_T.inverse().transform_point(v);
                let suvl = [ xyzw_camframe.x, xyzw_camframe.y, xyzw_camframe.z, xyzw_camframe.w ]; // TODO: apply intrinsics
                let uvl = [ suvl[1] / suvl[0], suvl[2] / suvl[0], suvl[3] / suvl[0] ]; // perspective divide
                uvl_vertices.push(new THREE.Vector3(uvl[0], uvl[1], uvl[2]));
                uvl_vertices_s.push(suvl[0]);
            }
            uvl_edges = hyperfloor.edges.slice();
            uvl_edges.forEach(([i, j]) => {
                // Main 3D scene
                const are_both_vertices_in_front = (uvl_vertices_s[i] > 0 && uvl_vertices_s[j] > 0);
                const are_both_vertices_inside_sensor = (
                    uvl_vertices[i].x >= hypercamera_sensor_uvl_range[0] &&
                    uvl_vertices[i].x <= hypercamera_sensor_uvl_range[1] &&
                    uvl_vertices[i].y >= hypercamera_sensor_uvl_range[2] &&
                    uvl_vertices[i].y <= hypercamera_sensor_uvl_range[3] &&
                    uvl_vertices[i].z >= hypercamera_sensor_uvl_range[4] &&
                    uvl_vertices[i].z <= hypercamera_sensor_uvl_range[5] &&
                    uvl_vertices[j].x >= hypercamera_sensor_uvl_range[0] &&
                    uvl_vertices[j].x <= hypercamera_sensor_uvl_range[1] &&
                    uvl_vertices[j].y >= hypercamera_sensor_uvl_range[2] &&
                    uvl_vertices[j].y <= hypercamera_sensor_uvl_range[3] &&
                    uvl_vertices[j].z >= hypercamera_sensor_uvl_range[4] &&
                    uvl_vertices[j].z <= hypercamera_sensor_uvl_range[5]
                );
                if (uvl_vertices_s[i] > 0 && uvl_vertices_s[j] > 0) {
                    const points = [uvl_vertices[i], uvl_vertices[j]];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    let material = edgeMaterial;
                    if (!are_both_vertices_inside_sensor) {
                        material = outOfSensorEdgeMaterial;
                    }
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    edgeMeshes.push(line);
                }
            });

        }

        // Update the entire graph
        function updateGraph() {
            createThreeJSPrimitivesFromScene();
        }

        // Keyboard controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse controls for vertex selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            // Ignore clicks during drag
            if (event.button !== 0) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vertexMeshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                selectedVertexIndex = clickedMesh.selectable_idx;
                document.getElementById('selected').textContent = `Vertex ${selectedVertexIndex}`;
                updateGraph();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Movement speed
        const moveSpeed = 0.1;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            let moved = false;

            // Simulate physics
            if (SIMULATE_PHYSICS) {
                moved = true;

                const FLOOR_HEIGHT = -2;
                const FLOOR_STIFFNESS = 100;
                const FLOOR_DAMPING = 10;
                const GRAVITY = -9.81;

                for (let hyperobject of hyperscene_visible_objects) {

                    // calculate hyperobject center of mass 
                    let hyperobject_com = new Vector4D(0, 0, 0, 0);
                    for (let v of hyperobject.vertices_in_world) {
                        hyperobject_com = hyperobject_com.add(v);
                    }
                    hyperobject_com = new Vector4D(
                        hyperobject_com.x / hyperobject.vertices_in_world.length,
                        hyperobject_com.y / hyperobject.vertices_in_world.length,
                        hyperobject_com.z / hyperobject.vertices_in_world.length,
                        hyperobject_com.w / hyperobject.vertices_in_world.length
                    );
                    
                    // mujoco-style forward/backward
                    // 1. apply gravity
                    // 2. apply collision to c.o.m based on vertices penetrating the floor (use z=-2 as the floor height)
                    // 3. resolve c.o.m velocity and rotational velocity
                    // 4. update vertex positions based on c.o.m and rotational velocity
                    
                    // force and torque accumulators
                    let com_force = new Vector4D(0, 0, GRAVITY * hyperobject.mass, 0);
                    let com_torque = {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0};

                    // If object com is within 1 unit of camera, push it away with small force
                    let to_camera = hyperobject_com.subtract(hypercamera_T.origin());
                    let distance_to_camera = Math.sqrt(to_camera.x**2 + to_camera.y**2 + to_camera.z**2 + to_camera.w**2);
                    if (distance_to_camera < 2.0 && distance_to_camera > 0.01) {
                        // let push_strength = 50 * (1.0 - distance_to_camera);
                        let min_push_strength = 50;
                        let max_push_strength = 500;
                        let push_01 = (2.0 - distance_to_camera) / 2.0;
                        let push_strength = min_push_strength + (max_push_strength - min_push_strength) * push_01;
                        let push_direction = to_camera.multiply_by_scalar(1.0 / distance_to_camera); // normalize
                        let push_force = push_direction.multiply_by_scalar(push_strength);
                        com_force = com_force.add(push_force);
                    }

                    // Add a general friction force
                    const FRICTION_COEFFICIENT = 1.0;
                    let friction_force = hyperobject.velocity_in_world.multiply_by_scalar(-FRICTION_COEFFICIENT);
                    com_force = com_force.add(friction_force);

                    
                    
                    // 2. Check for collisions with floor and accumulate forces/torques
                    for (let v of hyperobject.vertices_in_world) {
                        let floor_height = floor_heightmap(v.x, v.y, v.w);
                        let penetration = floor_height - v.z;
                        if (penetration > 0) {
                            // Position relative to CoM
                            let r = v.subtract(hyperobject_com); // position relative to CoM
                            
                            // Calculate velocity of this vertex in world frame
                            let vertex_velocity = new Vector4D(0, 0, 0, 0);

                            // Linear velocity from CoM
                            vertex_velocity = vertex_velocity.add(hyperobject.velocity_in_world)

                            // Velocity due to rotation (v_rot = omega  r in 4D)
                            // let v_rot = new Vector4D(
                                // hyperobject.rotational_velocity.xy * r.y - hyperobject.rotational_velocity.xz * r.z - hyperobject.rotational_velocity.xw * r.w,
                                // -hyperobject.rotational_velocity.xy * r.x + hyperobject.rotational_velocity.yz * r.z + hyperobject.rotational_velocity.yw * r.w,
                                // hyperobject.rotational_velocity.xz * r.x - hyperobject.rotational_velocity.yz * r.y + hyperobject.rotational_velocity.zw * r.w,
                                // hyperobject.rotational_velocity.xw * r.x - hyperobject.rotational_velocity.yw * r.y - hyperobject.rotational_velocity.zw * r.z
                            // );
                            // vertex_velocity = vertex_velocity.add(v_rot);
                            
                            
                            
                            // Spring-damper force (normal direction only, z-axis)
                            let normal_force_z = FLOOR_STIFFNESS * penetration - FLOOR_DAMPING * vertex_velocity.z;
                            
                            let contact_force = new Vector4D(0, 0, normal_force_z, 0);

                            // Add side friction to contact force
                            const SIDE_FRICTION_COEFFICIENT = 1;
                            let lateral_velocity = new Vector4D(vertex_velocity.x, vertex_velocity.y, 0, vertex_velocity.w);
                            let lateral_speed = Math.sqrt(lateral_velocity.x**2 + lateral_velocity.y**2 + lateral_velocity.w**2);
                            if (lateral_speed > 0.01) {
                                let lateral_direction = lateral_velocity.multiply_by_scalar(1.0 / lateral_speed); // normalize
                                let lateral_friction_magnitude = SIDE_FRICTION_COEFFICIENT * Math.abs(normal_force_z);
                                let lateral_friction = lateral_direction.multiply_by_scalar(-lateral_friction_magnitude);
                                contact_force = contact_force.add(lateral_friction);
                            }
                            
                            // Accumulate force on CoM
                            com_force = com_force.add(contact_force);

                            // Debug
                            if (v.z < -4) {
                                let aaa = 1;
                            }
                            
                            // Accumulate torque (r  F in 4D gives bivector with 6 components)
                            com_torque.xy += r.x * contact_force.y - r.y * contact_force.x;
                            com_torque.xz += r.x * contact_force.z - r.z * contact_force.x;
                            com_torque.xw += r.x * contact_force.w - r.w * contact_force.x;
                            com_torque.yz += r.y * contact_force.z - r.z * contact_force.y;
                            com_torque.yw += r.y * contact_force.w - r.w * contact_force.y;
                            com_torque.zw += r.z * contact_force.w - r.w * contact_force.z;
                        }
                    }
                    
                    // 3. Integrate velocities (simple Euler integration)
                    const dt = 0.016; // ~60fps
                    
                    // Linear velocity update: v += (F/m) * dt
                    hyperobject.velocity_in_world = hyperobject.velocity_in_world.add(
                        new Vector4D(
                            com_force.x / hyperobject.mass * dt,
                            com_force.y / hyperobject.mass * dt,
                            com_force.z / hyperobject.mass * dt,
                            com_force.w / hyperobject.mass * dt
                        )
                    );
                    
                    // Angular velocity update: omega += (torque / I) * dt
                    // For uniform hyperobject with edge length 2: I = (2/3) * mass
                    const I = (2/3) * hyperobject.mass;
                    hyperobject.rotational_velocity.xy += (com_torque.xy / I) * dt;
                    hyperobject.rotational_velocity.xz += (com_torque.xz / I) * dt;
                    hyperobject.rotational_velocity.xw += (com_torque.xw / I) * dt;
                    hyperobject.rotational_velocity.yz += (com_torque.yz / I) * dt;
                    hyperobject.rotational_velocity.yw += (com_torque.yw / I) * dt;
                    hyperobject.rotational_velocity.zw += (com_torque.zw / I) * dt;
                    
                    // 4. Update vertex positions based on CoM and rotation
                    for (let i = 0; i < hyperobject.vertices_in_world.length; i++) {
                        let r = hyperobject.vertices_in_world[i].subtract(hyperobject_com); // current position relative to new CoM
                        
                        // Apply rotation: r' = r + (omega  r) * dt
                        let dr = new Vector4D(0, 0, 0, 0);

                        // dr = dr.add(new Vector4D(
                            // (hyperobject.rotational_velocity.xy * r.y - hyperobject.rotational_velocity.xz * r.z - hyperobject.rotational_velocity.xw * r.w) * dt,
                            // (-hyperobject.rotational_velocity.xy * r.x + hyperobject.rotational_velocity.yz * r.z + hyperobject.rotational_velocity.yw * r.w) * dt,
                            // (hyperobject.rotational_velocity.xz * r.x - hyperobject.rotational_velocity.yz * r.y + hyperobject.rotational_velocity.zw * r.w) * dt,
                            // (hyperobject.rotational_velocity.xw * r.x - hyperobject.rotational_velocity.yw * r.y - hyperobject.rotational_velocity.zw * r.z) * dt
                        // ));

                        // Apply CoM velocity
                        r = r.add(new Vector4D(
                            hyperobject.velocity_in_world.x * dt,
                            hyperobject.velocity_in_world.y * dt,
                            hyperobject.velocity_in_world.z * dt,
                            hyperobject.velocity_in_world.w * dt
                        ));
                        
                        // New vertex position = new CoM + rotated relative position
                        hyperobject.vertices_in_world[i] = hyperobject_com.add(r.add(dr));
                    }
                }
            }
            
            // Handle WASD movement for selected vertex
            if (true) {
                
                // Move individual vertices
                // if (keys['w']) {
                //     if (hypercube.vertices_in_world.length > 0 && selectedVertexIndex < hypercube.vertices_in_world.length) {
                //         hypercube.vertices_in_world[selectedVertexIndex].x += moveSpeed;
                //         moved = true;
                //     }
                // }

                const RELATIVE_MOVEMENT = true;
                if (keys['w']) {
                    hypercamera_T.translate_self_by_delta(moveSpeed, 0, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['s']) {
                    hypercamera_T.translate_self_by_delta(-moveSpeed, 0, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['a']) {
                    hypercamera_T.translate_self_by_delta(0, -moveSpeed, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['d']) {
                    hypercamera_T.translate_self_by_delta(0, moveSpeed, 0, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['q']) {
                    hypercamera_T.translate_self_by_delta(0, 0, 0, -moveSpeed, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['e']) {
                    hypercamera_T.translate_self_by_delta(0, 0, 0, moveSpeed, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['r']) {
                    hypercamera_T.translate_self_by_delta(0, 0, moveSpeed, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['f']) {
                    hypercamera_T.translate_self_by_delta(0, 0, -moveSpeed, 0, RELATIVE_MOVEMENT);
                    moved = true;
                }
                // reset camera z to 0
                hypercamera_T.matrix[2][4] = floor_heightmap(
                    hypercamera_T.matrix[0][4],
                    hypercamera_T.matrix[1][4],
                    hypercamera_T.matrix[3][4]
                ) + hypercamera_height_above_ground;

                if (keys['i']) {
                    hypercamera_T.rotate_self_by_delta('XZ', 0.05, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['k']) {
                    hypercamera_T.rotate_self_by_delta('XZ', -0.05, RELATIVE_MOVEMENT);
                    moved = true;
                }
                if (keys['j']) {
                    hypercamera_T.rotate_self_by_delta('XY', -0.05, false);
                    moved = true;
                }
                if (keys['l']) {
                    hypercamera_T.rotate_self_by_delta('XY', 0.05, false);
                    moved = true;
                }
                if (keys['u']) {
                    hypercamera_T.rotate_self_by_delta('XW', -0.05, false);
                    moved = true;
                }
                if (keys['o']) {
                    hypercamera_T.rotate_self_by_delta('XW', 0.05, false);
                    moved = true;
                }
                if (keys['y']) {
                    hypercamera_T.rotate_self_by_delta('YW', -0.05, false);
                    moved = true;
                }
                if (keys['p']) {
                    hypercamera_T.rotate_self_by_delta('YW', 0.05, false);
                    moved = true;
                }
            }
            
            // update threejs scene since hyperscene has changed
            if (moved) {
                updateGraph();
            }

            controls.update();
            renderer.render(scene, camera);
            xzRenderer.render(xzScene, xzCamera);
            yzRenderer.render(yzScene, yzCamera);
            wzRenderer.render(wzScene, wzCamera);
        }

        // Initialize
        updateGraph();
        document.getElementById('selected').textContent = `Vertex ${selectedVertexIndex}`;
        animate();
    </script>
</body>
</html>
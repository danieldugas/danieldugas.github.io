<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tripod Gait Bug</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    <strong>Tripod Gait Animation</strong><br>
    Alternating sets of 3 legs move together
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let bug = { body: null, legs: [] };
    let time = 0;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 5);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.4);
      directional.position.set(5, 10, 5);
      scene.add(directional);

      // Ground
      const groundGeo = new THREE.PlaneGeometry(20, 20);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x90ee90 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      scene.add(ground);

      // Create bug
      createBug();

      window.addEventListener('resize', onResize);
      animate();
    }

    function createBug() {
      // Body (abdomen sphere)
      const bodyGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      bug.body = new THREE.Mesh(bodyGeo, bodyMat);
      bug.body.position.y = 1;
      scene.add(bug.body);

      // Create 6 legs (3 on each side)
      const legPositions = [
        { side: 1, angle: 0.5 },   // Right front
        { side: 1, angle: 0 },     // Right middle
        { side: 1, angle: -0.5 },  // Right back
        { side: -1, angle: 0.5 },  // Left front
        { side: -1, angle: 0 },    // Left middle
        { side: -1, angle: -0.5 }  // Left back
      ];

      legPositions.forEach((pos, i) => {
        const leg = createLeg(pos.side, pos.angle, i);
        bug.legs.push(leg);
        scene.add(leg.upper);
        scene.add(leg.lower);
        scene.add(leg.knee);
        scene.add(leg.foot);
      });
    }

    function createLeg(side, angleOffset, index) {
      const attachAngle = side * Math.PI / 3 + angleOffset;
      const attachX = Math.cos(attachAngle) * 0.4;
      const attachZ = Math.sin(attachAngle) * 0.4;

      // Materials
      const lineMat = new THREE.LineBasicMaterial({ color: 0x654321 });
      const jointMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const footMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

      // Upper leg
      const upperGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, -0.8, 0)
      ]);
      const upper = new THREE.Line(upperGeo, lineMat);

      // Knee joint
      const kneeGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const knee = new THREE.Mesh(kneeGeo, jointMat);

      // Lower leg
      const lowerGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, -0.8, 0)
      ]);
      const lower = new THREE.Line(lowerGeo, lineMat);

      // Foot
      const footGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const foot = new THREE.Mesh(footGeo, footMat);

      return {
        upper, lower, knee, foot,
        attachX, attachZ, attachAngle,
        side, index
      };
    }

    function updateLeg(leg, phase) {
      // Tripod gait: legs 0,2,4 move together, legs 1,3,5 move together
      const group = leg.index % 2;
      const cyclePhase = (phase + group * Math.PI) % (Math.PI * 2);
      
      // Lift leg when in swing phase
      const isSwing = Math.sin(cyclePhase) > 0;
      const liftHeight = isSwing ? Math.abs(Math.sin(cyclePhase)) * 0.3 : 0;
      
      // Forward/backward motion
      const stride = Math.cos(cyclePhase) * 0.4;
      
      // Leg position
      const baseX = bug.body.position.x + leg.attachX;
      const baseZ = bug.body.position.z + leg.attachZ;
      const baseY = bug.body.position.y;
      
      // Upper leg attachment point
      leg.upper.position.set(baseX, baseY, baseZ);
      
      // Foot target position
      const footX = baseX + Math.cos(leg.attachAngle) * (1.2 + stride);
      const footZ = baseZ + Math.sin(leg.attachAngle) * (1.2 + stride);
      const footY = 0 + liftHeight;
      
      // Calculate knee position (midpoint, slightly outward)
      const kneeX = (baseX + footX) / 2 + Math.cos(leg.attachAngle) * 0.2;
      const kneeZ = (baseZ + footZ) / 2 + Math.sin(leg.attachAngle) * 0.2;
      const kneeY = (baseY + footY) / 2;
      
      leg.knee.position.set(kneeX, kneeY, kneeZ);
      leg.foot.position.set(footX, footY, footZ);
      
      // Update line segments
      const upperPoints = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(kneeX - baseX, kneeY - baseY, kneeZ - baseZ)
      ];
      leg.upper.geometry.setFromPoints(upperPoints);
      
      leg.lower.position.copy(leg.knee.position);
      const lowerPoints = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(footX - kneeX, footY - kneeY, footZ - kneeZ)
      ];
      leg.lower.geometry.setFromPoints(lowerPoints);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.02;
      
      // Update all legs
      bug.legs.forEach(leg => updateLeg(leg, time));
      
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
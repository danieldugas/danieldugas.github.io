<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DDA Voxel Ray Tracer</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: monospace;
            color: #fff;
        }
        #container {
            text-align: center;
        }
        canvas {
            border: 2px solid #444;
            image-rendering: pixelated;
        }
        #info {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        canvas {
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div id="info">64×64×64 voxel grid • DDA ray traversal with alpha blending</div>
    </div>
    <!-- Floating div with timing infos -->
    <div id="timingsinfo" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px; font-size: 10px; color: #0f0;">
        Timing info will appear here.
    </div>
    <script>
            // 4D transform class prototype (just implement init, and origin() for now)
        class Vector4D {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            add(v) {
                return new Vector4D(this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w);
            }
            subtract(v) {
                return new Vector4D(this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w);
            }
            normalize() {
                let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                if (mag === 0) return new Vector4D(0, 0, 0, 0);
                return new Vector4D(this.x / mag, this.y / mag, this.z / mag, this.w / mag);
            }
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            }
            multiply_by_scalar(s) {
                return new Vector4D(this.x * s, this.y * s, this.z * s, this.w * s);
            }
        }
        class Transform4D {
            // constructor() {
            //     this.matrix = [
            //         [1, 0, 0, 0, 0],
            //         [0, 1, 0, 0, 0],
            //         [0, 0, 1, 0, 0],
            //         [0, 0, 0, 1, 0],
            //         [0, 0, 0, 0, 1]
            //     ];
            // }
            constructor(matrix) {
                this.matrix = matrix;
            }

            origin() {
                return new Vector4D(this.matrix[0][4], this.matrix[1][4], this.matrix[2][4], this.matrix[3][4]);
            }

            // transform_point(v: Vector4D): Vector4D
            transform_point(v) {
                let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w + this.matrix[0][4];
                let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w + this.matrix[1][4];
                let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w + this.matrix[2][4];
                let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w + this.matrix[3][4];
                return new Vector4D(x, y, z, w);
            }

            transform_vector(v) {
                let x = this.matrix[0][0] * v.x + this.matrix[0][1] * v.y + this.matrix[0][2] * v.z + this.matrix[0][3] * v.w;
                let y = this.matrix[1][0] * v.x + this.matrix[1][1] * v.y + this.matrix[1][2] * v.z + this.matrix[1][3] * v.w;
                let z = this.matrix[2][0] * v.x + this.matrix[2][1] * v.y + this.matrix[2][2] * v.z + this.matrix[2][3] * v.w;
                let w = this.matrix[3][0] * v.x + this.matrix[3][1] * v.y + this.matrix[3][2] * v.z + this.matrix[3][3] * v.w;
                return new Vector4D(x, y, z, w);
            }

            transform_transform(T) {
                // matrix multiplication: this.matrix * T.matrix
                // inC_T_B * inB_T_A  -> inC_T_A
                // inC_T_B.transform_transform(inB_T_A) -> inC_T_A
                let Tl = this.matrix;
                let Tr = T.matrix;
                let Tn = [
                    [
                        Tl[0][0] * Tr[0][0] + Tl[0][1] * Tr[1][0] + Tl[0][2] * Tr[2][0] + Tl[0][3] * Tr[3][0],
                        Tl[0][0] * Tr[0][1] + Tl[0][1] * Tr[1][1] + Tl[0][2] * Tr[2][1] + Tl[0][3] * Tr[3][1],
                        Tl[0][0] * Tr[0][2] + Tl[0][1] * Tr[1][2] + Tl[0][2] * Tr[2][2] + Tl[0][3] * Tr[3][2],
                        Tl[0][0] * Tr[0][3] + Tl[0][1] * Tr[1][3] + Tl[0][2] * Tr[2][3] + Tl[0][3] * Tr[3][3],
                        Tl[0][0] * Tr[0][4] + Tl[0][1] * Tr[1][4] + Tl[0][2] * Tr[2][4] + Tl[0][3] * Tr[3][4] + Tl[0][4]
                    ],
                    [
                        Tl[1][0] * Tr[0][0] + Tl[1][1] * Tr[1][0] + Tl[1][2] * Tr[2][0] + Tl[1][3] * Tr[3][0],
                        Tl[1][0] * Tr[0][1] + Tl[1][1] * Tr[1][1] + Tl[1][2] * Tr[2][1] + Tl[1][3] * Tr[3][1],
                        Tl[1][0] * Tr[0][2] + Tl[1][1] * Tr[1][2] + Tl[1][2] * Tr[2][2] + Tl[1][3] * Tr[3][2],
                        Tl[1][0] * Tr[0][3] + Tl[1][1] * Tr[1][3] + Tl[1][2] * Tr[2][3] + Tl[1][3] * Tr[3][3],
                        Tl[1][0] * Tr[0][4] + Tl[1][1] * Tr[1][4] + Tl[1][2] * Tr[2][4] + Tl[1][3] * Tr[3][4] + Tl[1][4]
                    ],
                    [
                        Tl[2][0] * Tr[0][0] + Tl[2][1] * Tr[1][0] + Tl[2][2] * Tr[2][0] + Tl[2][3] * Tr[3][0],
                        Tl[2][0] * Tr[0][1] + Tl[2][1] * Tr[1][1] + Tl[2][2] * Tr[2][1] + Tl[2][3] * Tr[3][1],
                        Tl[2][0] * Tr[0][2] + Tl[2][1] * Tr[1][2] + Tl[2][2] * Tr[2][2] + Tl[2][3] * Tr[3][2],
                        Tl[2][0] * Tr[0][3] + Tl[2][1] * Tr[1][3] + Tl[2][2] * Tr[2][3] + Tl[2][3] * Tr[3][3],
                        Tl[2][0] * Tr[0][4] + Tl[2][1] * Tr[1][4] + Tl[2][2] * Tr[2][4] + Tl[2][3] * Tr[3][4] + Tl[2][4]
                    ],
                    [
                        Tl[3][0] * Tr[0][0] + Tl[3][1] * Tr[1][0] + Tl[3][2] * Tr[2][0] + Tl[3][3] * Tr[3][0],
                        Tl[3][0] * Tr[0][1] + Tl[3][1] * Tr[1][1] + Tl[3][2] * Tr[2][1] + Tl[3][3] * Tr[3][1],
                        Tl[3][0] * Tr[0][2] + Tl[3][1] * Tr[1][2] + Tl[3][2] * Tr[2][2] + Tl[3][3] * Tr[3][2],
                        Tl[3][0] * Tr[0][3] + Tl[3][1] * Tr[1][3] + Tl[3][2] * Tr[2][3] + Tl[3][3] * Tr[3][3],
                        Tl[3][0] * Tr[0][4] + Tl[3][1] * Tr[1][4] + Tl[3][2] * Tr[2][4] + Tl[3][3] * Tr[3][4] + Tl[3][4]
                    ],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(Tn);
            }


            translate_self_by_delta(dx, dy, dz, dw, is_in_own_frame) {
                if (is_in_own_frame) {
                    // translation in own frame
                    let delta_in_parent = this.transform_vector(new Vector4D(dx, dy, dz, dw));
                    this.matrix[0][4] += delta_in_parent.x;
                    this.matrix[1][4] += delta_in_parent.y;
                    this.matrix[2][4] += delta_in_parent.z;
                    this.matrix[3][4] += delta_in_parent.w;
                } else {
                    // translation in parent frame
                    this.matrix[0][4] += dx;
                    this.matrix[1][4] += dy;
                    this.matrix[2][4] += dz;
                    this.matrix[3][4] += dw;
                }
            }

            rotate_self_by_delta(plane_string, angle_rad, is_in_own_frame) {
                // plane string: 'XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'
                let c = Math.cos(angle_rad);
                let s = Math.sin(angle_rad);
                let R = [
                    [1, 0, 0, 0,  0],
                    [0, 1, 0, 0,  0],
                    [0, 0, 1, 0,  0],
                    [0, 0, 0, 1,  0],

                    [0, 0, 0, 0,  1]
                ];
                switch (plane_string) {
                    case 'XY':
                        R[0][0] = c; R[0][1] = -s;
                        R[1][0] = s; R[1][1] = c;
                        break;
                    case 'XZ':
                        R[0][0] = c; R[0][2] = -s;
                        R[2][0] = s; R[2][2] = c;
                        break;
                    case 'XW':
                        R[0][0] = c; R[0][3] = -s;
                        R[3][0] = s; R[3][3] = c;
                        break;
                    case 'YZ':
                        R[1][1] = c; R[1][2] = -s;
                        R[2][1] = s; R[2][2] = c;
                        break;
                    case 'YW':
                        R[1][1] = c; R[1][3] = -s;
                        R[3][1] = s; R[3][3] = c;
                        break;
                    case 'ZW':
                        R[2][2] = c; R[2][3] = -s;
                        R[3][2] = s; R[3][3] = c;
                        break;
                    default:
                        console.error('Invalid plane string for rotation');
                        return;
                }
                // let newT = this.transform_transform(new Transform4D(R));
                // this.matrix = newT.matrix;
                let Rdelta = new Transform4D(R);
                if (is_in_own_frame) {
                    // Apply rotation in own frame
                    let newT = this.transform_transform(Rdelta);
                    this.matrix = newT.matrix;
                } else {
                    // Apply rotation in parent frame
                    let newT = Rdelta.transform_transform(this);
                    // this.matrix = newT.matrix;
                    // only copy the rotation part, keep the translation part
                    // without rotation_only, we rotate around the parent origin instead of our own origin
                    this.matrix = [
                        [newT.matrix[0][0], newT.matrix[0][1], newT.matrix[0][2], newT.matrix[0][3], this.matrix[0][4]],
                        [newT.matrix[1][0], newT.matrix[1][1], newT.matrix[1][2], newT.matrix[1][3], this.matrix[1][4]],
                        [newT.matrix[2][0], newT.matrix[2][1], newT.matrix[2][2], newT.matrix[2][3], this.matrix[2][4]],
                        [newT.matrix[3][0], newT.matrix[3][1], newT.matrix[3][2], newT.matrix[3][3], this.matrix[3][4]],
                        [0, 0, 0, 0, 1]
                    ];
                }
            }
                    

            

            rotation_only() {
                let R = [
                    [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3], 0],
                    [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3], 0],
                    [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3], 0],
                    [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3], 0],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(R);
            }

            inverse() {
                // separate rotation and translation
                let R = [
                    [this.matrix[0][0], this.matrix[0][1], this.matrix[0][2], this.matrix[0][3]],
                    [this.matrix[1][0], this.matrix[1][1], this.matrix[1][2], this.matrix[1][3]],
                    [this.matrix[2][0], this.matrix[2][1], this.matrix[2][2], this.matrix[2][3]],
                    [this.matrix[3][0], this.matrix[3][1], this.matrix[3][2], this.matrix[3][3]]
                ];
                let t = [
                    this.matrix[0][4],
                    this.matrix[1][4],
                    this.matrix[2][4],
                    this.matrix[3][4]
                ];
                // transpose rotation
                let R_inv = [
                    [R[0][0], R[1][0], R[2][0], R[3][0]],
                    [R[0][1], R[1][1], R[2][1], R[3][1]],
                    [R[0][2], R[1][2], R[2][2], R[3][2]],
                    [R[0][3], R[1][3], R[2][3], R[3][3]]
                ];
                // new translation
                let t_inv = [
                    -(R_inv[0][0] * t[0] + R_inv[0][1] * t[1] + R_inv[0][2] * t[2] + R_inv[0][3] * t[3]),
                    -(R_inv[1][0] * t[0] + R_inv[1][1] * t[1] + R_inv[1][2] * t[2] + R_inv[1][3] * t[3]),
                    -(R_inv[2][0] * t[0] + R_inv[2][1] * t[1] + R_inv[2][2] * t[2] + R_inv[2][3] * t[3]),
                    -(R_inv[3][0] * t[0] + R_inv[3][1] * t[1] + R_inv[3][2] * t[2] + R_inv[3][3] * t[3])
                ];
                // combine into new matrix
                let invMatrix = [
                    [R_inv[0][0], R_inv[0][1], R_inv[0][2], R_inv[0][3], t_inv[0]],
                    [R_inv[1][0], R_inv[1][1], R_inv[1][2], R_inv[1][3], t_inv[1]],
                    [R_inv[2][0], R_inv[2][1], R_inv[2][2], R_inv[2][3], t_inv[2]],
                    [R_inv[3][0], R_inv[3][1], R_inv[3][2], R_inv[3][3], t_inv[3]],
                    [0, 0, 0, 0, 1]
                ];
                return new Transform4D(invMatrix);
            }
        }

        // Helper: vector subtraction
        function vecsub(u, v) {
            // console.log("Subtraction u, v:", u, v);
            return [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
        }
        // Helper: cross product
        function veccross(u, v) {
            return [
                u[1]*v[2] - u[2]*v[1],
                u[2]*v[0] - u[0]*v[2],
                u[0]*v[1] - u[1]*v[0]
            ];
        }
        // Helper: dot product
        function vecdot(u, v) {
            return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
        }
        // Signed volume of tetrahedron (A,B,C,D)
        function signedVolume(a, b, c, d) {
            const ab = vecsub(b, a);
            const ac = vecsub(c, a);
            const ad = vecsub(d, a);
            // console.log("Vectors ab, ac, ad:", ab, ac, ad);
            return vecdot(veccross(ab, ac), ad) / 6;
        }
        // Compute barycentric coordinates of P in tetrahedron ABCD
        function barycentricCoordinates(P, A, B, C, D) {
            const V = signedVolume(A, B, C, D);
            // console.log("Total volume V:", V);

            const alpha = signedVolume(P, B, C, D) / V;
            const beta  = signedVolume(A, P, C, D) / V;
            const gamma = signedVolume(A, B, P, D) / V;
            const delta = signedVolume(A, B, C, P) / V;

            return { alpha, beta, gamma, delta };
        }
        function testBarycentric3D() {
            // Example usage
            const A = [0,0,0];
            const B = [1,0,0];
            const C = [0,1,0];
            const D = [0,0,1];
            let bary = null;
            let P = [0.2, 0.2, 0.2];
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));

            P = [2.0, 2.0, 2.0];
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));

            P = A;
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));

            P = B;
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));

            P = C;
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));

            P = D;
            bary = barycentricCoordinates(P, A, B, C, D);
            console.log(bary);
            console.log("Inside tetrahedron?", Object.values(bary).every(v => v >= 0 && v <= 1));
        }

        class Hyperobject {
            constructor(vertices_in_object, edges, tetras, color, simulate_physics, show_vertices, mass, pose, name) {
                this.vertices_in_object = vertices_in_object; // in object frame
                this.edges = edges;
                this.tetras = tetras;
                this.color = color;
                this.simulate_physics = simulate_physics; // if true, object gets affected by physics
                this.show_vertices = show_vertices;
                this.mass = mass;
                this.pose = pose; // Transform4D from object frame to world frame
                this.name = name;
                // variables
                this.velocity_in_world = new Vector4D(0, 0, 0, 0);
                this.rotational_velocity = {xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0};
                // computed properties
                this.update_vertices_in_world();
            }

            update_vertices_in_world() {
                this.vertices_in_world = [];
                for (let v of this.vertices_in_object) {
                    let v_world = this.pose.transform_point(v);
                    this.vertices_in_world.push(v_world);
                }
            }

            get_com() {
                return this.pose.origin();
            }
        }

        // Hyperscene and Hypercam definition
        // 4D Scene Bodies
        let scene_bound = 10.0; // +10 means the scene goes from -10 to +10 in all dimensions
        const hypercamera_height_above_ground = 1.0;
        let hypercamera_T = new Transform4D([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 1],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
        ]); // hypercam in world
        // let hf = 1.0; // hyper focal length
        // let hypercamera_intrinsics = [
            // [hf, 0, 0, 0],
            // [0, hf, 0, 0],
            // [0, 0, hf, 0],
            // [0, 0, 0, 1]
        // ]; // see TODO s , for now assume identity intrinsics
        let hypercamera_sensor_size = 1
        let hypercamera_sensor_uvl_range = [-1, 1, -1, 1, -1, 1]; // u_min, u_max, v_min, v_max, l_min, l_max
        let hypercamera_is_unit_sensor = true;
        let hypercamera_sensor_resolution = 64;
        // Initialize random colored voxels with low alpha
        let voxels = []; // s-buffer
        function fillVoxelsRandom() {
            const gridSize = hypercamera_sensor_resolution;
            for (let x = 0; x < gridSize; x++) {
                voxels[x] = [];
                for (let y = 0; y < gridSize; y++) {
                    voxels[x][y] = [];
                    for (let z = 0; z < gridSize; z++) {
                        if ((x === 0) || (y === 0) || (z === 0) || (x === gridSize - 1) || (y === gridSize - 1) || (z === gridSize - 1)) {
                            // make border voxels transparent
                            voxels[x][y][z] = {
                                r: 200,
                                g: 200,
                                b: 200,
                                a: 0.1,
                                s: Infinity
                            };
                            continue;
                        }
                        voxels[x][y][z] = {
                            r: Math.floor(Math.random() * 256),
                            g: Math.floor(Math.random() * 256),
                            b: Math.floor(Math.random() * 256),
                            a: 0.0,
                            s: Infinity
                        };
                    }
                }
            }
        }
        fillVoxelsRandom();

        // build a hyperfloor surface (triangle mesh)
        // 1. assign a z for each (x,y,w) grid point
        // 2. build triangles between grid points
        const GRID_LIMS = {
            x_min: -scene_bound,
            x_max: scene_bound,
            y_min: -scene_bound,
            y_max: scene_bound,
            z_min: -scene_bound,
            z_max: scene_bound,
            w_min: -scene_bound,
            w_max: scene_bound
        };
        const N_TILES = 20;
        const GRID_RES = 2 * scene_bound / N_TILES; // grid resolution
        const n_i = Math.floor((GRID_LIMS.x_max - GRID_LIMS.x_min) / GRID_RES) + 1;
        const n_j = Math.floor((GRID_LIMS.y_max - GRID_LIMS.y_min) / GRID_RES) + 1;
        const n_k = Math.floor((GRID_LIMS.w_max - GRID_LIMS.w_min) / GRID_RES) + 1;
        function floor_heightmap(x, y, w) {
            return 0 + x * 0.1;
        }
        let grid_vertices = [];
        let grid_edges = [];
        let grid_tetras = [];
        for (let i = 0; i < n_i; i++) {
            for (let j = 0; j < n_j; j++) {
                for (let k = 0; k < n_k; k++) {
                    let x = GRID_LIMS.x_min + i * GRID_RES;
                    let y = GRID_LIMS.y_min + j * GRID_RES;
                    let w = GRID_LIMS.w_min + k * GRID_RES;
                    // let z = Math.sin(0.2 * x) * Math.cos(0.2 * y) * 5; // example height function
                    let z = floor_heightmap(x, y, w);
                    grid_vertices.push(new Vector4D(x, y, z, w));
                    // add an edge to the next vertex in x
                    if (i < n_i - 1) {
                        let next_index = grid_vertices.length + (n_j * n_k) - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in y
                    if (j < n_j - 1) {
                        let next_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge to the next vertex in w
                    if (k < n_k - 1) {
                        let next_index = grid_vertices.length;
                        grid_edges.push([grid_vertices.length - 1, next_index]);
                    }
                    // add an edge between next x and next y
                    if (i < n_i - 1 && j < n_j - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_y_index = grid_vertices.length + n_k - 1;
                        grid_edges.push([next_x_index, next_y_index]);
                    }
                    // add an edge between next x and next w
                    if (i < n_i - 1 && k < n_k - 1) {
                        let next_x_index = grid_vertices.length + (n_j * n_k) - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_x_index, next_w_index]);
                    }
                    // add an edge between next y and next w
                    if (j < n_j - 1 && k < n_k - 1) {
                        let next_y_index = grid_vertices.length + n_k - 1;
                        let next_w_index = grid_vertices.length;
                        grid_edges.push([next_y_index, next_w_index]);
                    }
                    // add 5 tetras between this grid point and the next in x,y,w
                    if (i < n_i - 1 && j < n_j - 1 && k < n_k - 1) {
                        let nnn = i * n_j * n_k + j * n_k + k;
                        let pnn = (i + 1) * n_j * n_k + j * n_k + k;
                        let npn = i * n_j * n_k + (j + 1) * n_k + k;
                        let ppn = (i + 1) * n_j * n_k + (j + 1) * n_k + k;
                        let nnp = i * n_j * n_k + j * n_k + (k + 1);
                        let pnp = (i + 1) * n_j * n_k + j * n_k + (k + 1);
                        let npp = i * n_j * n_k + (j + 1) * n_k + (k + 1);
                        let ppp = (i + 1) * n_j * n_k + (j + 1) * n_k + (k + 1);
                        let cell_tetras = [
                            [pnn, nnn, ppn, pnp], // tet at corner p n n
                            [npn, ppn, nnn, npp], // tet at corner n p n
                            [nnp, pnp, npp, nnn], // tet at corner n n p
                            [ppp, npp, pnp, ppn], // tet at corner p p p
                            [nnn, ppn, npp, pnp]  // tet at center
                        ];
                        for (let tet of cell_tetras) { grid_tetras.push(tet); }
                    }
                }
            }
        }
        // create the class
        let hyperfloor = new Hyperobject(
            // vertices in object frame
            grid_vertices,
            // edges
            grid_edges,
            // tetras
            grid_tetras,
            // color
            0x000088,
            // simulate_physics
            false,
            // show_vertices
            false,
            // mass
            1.0,
            // pose (Transform4D)
            new Transform4D([
                [1, 0, 0, 0, 0],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ]),
            // name
            "Hyperfloor"
        );

        // define a hypercube object
        const OSZ = floor_heightmap(0, 0, 0) + 3.0; // object spawn z
        const const_hypercube_vertices = [ 
                new Vector4D(-1, -1, -1, -1),
                new Vector4D( 1, -1, -1, -1),
                new Vector4D( 1,  1, -1, -1),
                new Vector4D(-1,  1, -1, -1),
                new Vector4D(-1, -1,  1, -1),
                new Vector4D( 1, -1,  1, -1),
                new Vector4D( 1,  1,  1, -1),
                new Vector4D(-1,  1,  1, -1),
                new Vector4D(-1, -1, -1,  1),
                new Vector4D( 1, -1, -1,  1),
                new Vector4D( 1,  1, -1,  1),
                new Vector4D(-1,  1, -1,  1),
                new Vector4D(-1, -1,  1,  1),
                new Vector4D( 1, -1,  1,  1),
                new Vector4D( 1,  1,  1,  1),
                new Vector4D(-1,  1,  1,  1)
            ];
        // Tetrahedras
        function create_40_tetrahedra_tiling_of_hypercube(cube_vertices) {
            // cube_vertices need to all be -1 or 1 values (i.e. in unit cube coord system) for this to work!
            const p = 1.0;
            const n = -1.0;
            // for the 3D cube, these are the tetrahedra vertices
            // [[p, n, n], [n, n, n], [p, p, n], [p, n, p]], // tet at corner p n n
            // [[n, p, n], [p, p, n], [n, n, n], [n, p, p]], // tet at corner n p n
            // [[n, n, p], [p, n, p], [n, p, p], [n, n, n]], // tet at corner n n p
            // [[p, p, p], [n, p, p], [p, n, p], [p, p, n]], // tet at corner p p p
            // [[n, n, n], [p, p, n], [n, p, p], [p, n, p]]  // tet at center

            // to create 5 tet at each of the 8 cubes in the hypercube, we set one of the 4dims to either p or n and fill the remaining 3 with the above
            // for example if we tetrahedralize the cube at z = n, we set z = n and fill x=0, y=1, w=2 with the above
            // [[p, n, z, n], [n, n, z, n], [p, p, z, n], [p, n, z, p]]
            const xn = -1.0; // fixed x for this cube
            const xp = 1.0;  // fixed x for this cube
            const yn = -1.0; // fixed y for this cube
            const yp = 1.0;  // fixed y for this cube
            const zn = -1.0; // fixed z for this cube
            const zp = 1.0;  // fixed z for this cube
            const wn = -1.0; // fixed w for this cube
            const wp = 1.0;  // fixed w for this cube
            const tetrahedron_40_tiling_of_hypercube = [
                // cube at x = n
                [[xn, p, n, n], [xn, n, n, n], [xn, p, p, n], [xn, p, n, p]], // tet at corner p n n
                [[xn, n, p, n], [xn, p, p, n], [xn, n, n, n], [xn, n, p, p]], // tet at corner n p n
                [[xn, n, n, p], [xn, p, n, p], [xn, n, p, p], [xn, n, n, n]], // tet at corner n n p
                [[xn, p, p, p], [xn, n, p, p], [xn, p, n, p], [xn, p, p, n]], // tet at corner p p p
                [[xn, n, n, n], [xn, p, p, n], [xn, n, p, p], [xn, p, n, p]], // tet at center
                // cube at x = p
                [[xp, p, n, n], [xp, n, n, n], [xp, p, p, n], [xp, p, n, p]], // tet at corner p n n
                [[xp, n, p, n], [xp, p, p, n], [xp, n, n, n], [xp, n, p, p]], // tet at corner n p n
                [[xp, n, n, p], [xp, p, n, p], [xp, n, p, p], [xp, n, n, n]], // tet at corner n n p
                [[xp, p, p, p], [xp, n, p, p], [xp, p, n, p], [xp, p, p, n]], // tet at corner p p p
                [[xp, n, n, n], [xp, p, p, n], [xp, n, p, p], [xp, p, n, p]], // tet at center
                // cube at y = n
                [[p, yn, n, n], [n, yn, n, n], [p, yn, p, n], [p, yn, n, p]], // tet at corner p n n
                [[n, yn, p, n], [p, yn, p, n], [n, yn, n, n], [n, yn, p, p]], // tet at corner n p n
                [[n, yn, n, p], [p, yn, n, p], [n, yn, p, p], [n, yn, n, n]], // tet at corner n n p
                [[p, yn, p, p], [n, yn, p, p], [p, yn, n, p], [p, yn, p, n]], // tet at corner p p p
                [[n, yn, n, n], [p, yn, p, n], [n, yn, p, p], [p, yn, n, p]], // tet at center
                // cube at y = p
                [[p, yp, n, n], [n, yp, n, n], [p, yp, p, n], [p, yp, n, p]], // tet at corner p n n
                [[n, yp, p, n], [p, yp, p, n], [n, yp, n, n], [n, yp, p, p]], // tet at corner n p n
                [[n, yp, n, p], [p, yp, n, p], [n, yp, p, p], [n, yp, n, n]], // tet at corner n n p
                [[p, yp, p, p], [n, yp, p, p], [p, yp, n, p], [p, yp, p, n]], // tet at corner p p p
                [[n, yp, n, n], [p, yp, p, n], [n, yp, p, p], [p, yp, n, p]], // tet at center
                // cube at z = n
                [[p, n, zn, n], [n, n, zn, n], [p, p, zn, n], [p, n, zn, p]], // tet at corner p n n
                [[n, p, zn, n], [p, p, zn, n], [n, n, zn, n], [n, p, zn, p]], // tet at corner n p n
                [[n, n, zn, p], [p, n, zn, p], [n, p, zn, p], [n, n, zn, n]], // tet at corner n n p
                [[p, p, zn, p], [n, p, zn, p], [p, n, zn, p], [p, p, zn, n]], // tet at corner p p p
                [[n, n, zn, n], [p, p, zn, n], [n, p, zn, p], [p, n, zn, p]], // tet at center
                // cube at z = p 
                [[p, n, zp, n], [n, n, zp, n], [p, p, zp, n], [p, n, zp, p]], // tet at corner p n n
                [[n, p, zp, n], [p, p, zp, n], [n, n, zp, n], [n, p, zp, p]], // tet at corner n p n
                [[n, n, zp, p], [p, n, zp, p], [n, p, zp, p], [n, n, zp, n]], // tet at corner n n p
                [[p, p, zp, p], [n, p, zp, p], [p, n, zp, p], [p, p, zp, n]], // tet at corner p p p
                [[n, n, zp, n], [p, p, zp, n], [n, p, zp, p], [p, n, zp, p]], // tet at center
                // cube at w = n
                [[p, n, n, wn], [n, n, n, wn], [p, p, n, wn], [p, n, p, wn]], // tet at corner p n n
                [[n, p, n, wn], [p, p, n, wn], [n, n, n, wn], [n, p, p, wn]], // tet at corner n p n
                [[n, n, p, wn], [p, n, p, wn], [n, p, p, wn], [n, n, n, wn]], // tet at corner n n p
                [[p, p, p, wn], [n, p, p, wn], [p, n, p, wn], [p, p, n, wn]], // tet at corner p p p
                [[n, n, n, wn], [p, p, n, wn], [n, p, p, wn], [p, n, p, wn]], // tet at center
                // cube at w = p
                [[p, n, n, wp], [n, n, n, wp], [p, p, n, wp], [p, n, p, wp]], // tet at corner p n n
                [[n, p, n, wp], [p, p, n, wp], [n, n, n, wp], [n, p, p, wp]], // tet at corner n p n
                [[n, n, p, wp], [p, n, p, wp], [n, p, p, wp], [n, n, n, wp]], // tet at corner n n p
                [[p, p, p, wp], [n, p, p, wp], [p, n, p, wp], [p, p, n, wp]], // tet at corner p p p
                [[n, n, n, wp], [p, p, n, wp], [n, p, p, wp], [p, n, p, wp]]  // tet at center
            ];

            // convert to index
            let tetrahedra_indices = [];
            for (let tet of tetrahedron_40_tiling_of_hypercube) {
                let tet_indices = [];
                for (let v of tet) {
                    // find index in cube_vertices
                    for (let i = 0; i < cube_vertices.length; i++) {
                        let cv = cube_vertices[i];
                        if (cv.x === v[0] && cv.y === v[1] && cv.z === v[2] && cv.w === v[3]) {
                            tet_indices.push(i);
                            break;
                        }
                    }
                }
                if (tet_indices.length !== 4) {
                    console.error("Error creating tetrahedra indices");
                }
                tetrahedra_indices.push(tet_indices);
            }
            return tetrahedra_indices;
        }
        let hypercube = new Hyperobject(
            // vertices in object frame
            const_hypercube_vertices,
            // edges:
            [
                [0,1],[1,2],[2,3],[3,0],
                [4,5],[5,6],[6,7],[7,4],
                [0,4],[1,5],[2,6],[3,7],
                [8,9],[9,10],[10,11],[11,8],
                [12,13],[13,14],[14,15],[15,12],
                [8,12],[9,13],[10,14],[11,15],
                [0,8],[1,9],[2,10],[3,11],
                [4,12],[5,13],[6,14],[7,15]
            ],
            // tetras
            create_40_tetrahedra_tiling_of_hypercube(const_hypercube_vertices),
            // color
            0xff0000,
            // simulate_physics
            true,
            // show_vertices
            true,
            // mass
            1.0,
            // pose (Transform4D)
            new Transform4D([
                [1, 0, 0, 0, 4],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, OSZ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ]),
            // name
            "Hypercube"
        );

        // define a hyperpyramid object
        let hyperpyramid = new Hyperobject(
            // vertices in object frame
            [
                new Vector4D(0, 0, 1, 0),
                new Vector4D(1, 1, -1, 1),
                new Vector4D(1, -1, -1, -1),
                new Vector4D(-1, 1, -1, -1),
                new Vector4D(-1, -1, -1, 1)
            ],
            // edges
            [
                [0,1],[0,2],[0,3],[0,4],
                [1,2],[1,3],[1,4],
                [2,3],[2,4],
                [3,4]
            ],
            // tetras
            [
                [0,1,2,3],
                [0,1,2,4],
                [0,1,3,4],
                [0,2,3,4],
                [1,2,3,4]
            ],
            // color
            0x00ff00,
            // simulate_physics
            true,
            // show_vertices
            true,
            // mass
            1.0,
            // pose (Transform4D)
            new Transform4D([
                [1, 0, 0, 0, 4],
                [0, 1, 0, 0, 2],
                [0, 0, 1, 0, OSZ],
                [0, 0, 0, 1, 2],
                [0, 0, 0, 0, 1]
            ]),
            // name
            "Hyperpyramid"
        );

        let timingsInfosHtml = "";

    (async function main() {
        // Stage 0: Create buffers and gather all vertices and tetras from visible hyperobjects
        const s0_start = performance.now();
        let visibleHyperobjects = [hypercube, hyperpyramid, hyperfloor];
        // let vertices_in_world = hypercube.vertices_in_world;
        // let tetras = hypercube.tetras.map(tetra => ({ indices: tetra, color: hypercube.color }));
        let vertices_in_world = [];
        let tetras = [];
        for (let obj of visibleHyperobjects) {
            const base_index = vertices_in_world.length;
            // add vertices
            for (let v of obj.vertices_in_world) {
                vertices_in_world.push(v);
            }
            // add tetras with adjusted indices
            for (let tet of obj.tetras) {
                tetras.push({ indices: tet.map(vi => vi + base_index), color: obj.color });
            }
        }
        const s0_end = performance.now();
        console.log(`Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms`);
        timingsInfosHtml += `<p>Stage 0: Gathered vertices and tetras from visible hyperobjects in ${(s0_end - s0_start).toFixed(2)} ms</p>`;

        // ---------------------------------------------------------------------------------
        // Stage 1: Per-vertex - Transform vertices from world to camera space
        const s1_start = performance.now();
        let vertices_in_suvl = new Array(vertices_in_world.length);
        let vertices_in_1uvl = new Array(vertices_in_world.length);
        const camera_inverse = hypercamera_T.inverse();
        function perVertex(vertex_index, vertices_in_world, vertices_in_suvl, vertices_in_1uvl) {
            const vert_suvl = camera_inverse.transform_point(vertices_in_world[vertex_index]);
            vertices_in_suvl[vertex_index] = vert_suvl;
            vertices_in_1uvl[vertex_index] = new Vector4D(1.0, vert_suvl.y / vert_suvl.x, vert_suvl.z / vert_suvl.x, vert_suvl.w / vert_suvl.x);
        }
        for (let vi = 0; vi < vertices_in_world.length; vi++) { perVertex(vi, vertices_in_world, vertices_in_suvl, vertices_in_1uvl); } // run the "shader"
        const s1_end = performance.now();
        console.log("Stage 1: # of vertices transformed to camera space:", vertices_in_world.length, `in ${(s1_end - s1_start).toFixed(2)} ms`);
        timingsInfosHtml += `<p>Stage 1: # of vertices transformed to camera space: ${vertices_in_world.length} in ${(s1_end - s1_start).toFixed(2)} ms</p>`;

        // ---------------------------------------------------------------------------------
        // Stage 2: (CPU) Per-tetra - Exclude tetras with any vertex behind camera
        const s2_start = performance.now();
        let valid_tetras = [];
        function perTetra(tetra_index, tetras, vertices_in_suvl, valid_tetras) {
            let tetra = tetras[tetra_index];
            let behind_camera = false;
            for (let vi of tetra.indices) {
                if (vertices_in_suvl[vi].x <= 0) { // S coordinate
                    behind_camera = true;
                    break;
                }
            }
            if (!behind_camera) {
                valid_tetras.push(tetra);
            }
        }
        for (let ti = 0; ti < tetras.length; ti++) { perTetra(ti, tetras, vertices_in_suvl, valid_tetras); } // run the "shader"
        const s2_end = performance.now();
        console.log("Stage 2: # of valid tetras:", valid_tetras.length, `from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms`);
        timingsInfosHtml += `<p>Stage 2: # of valid tetras: ${valid_tetras.length} from ${tetras.length} in ${(s2_end - s2_start).toFixed(2)} ms</p>`;

        // ---------------------------------------------------------------------------------
        // Stage 3: Per-tetra - Rasterize tetras to 1UVL fragments
        // The simple way is to loop over all voxels and all tetras and do a test (is voxel inside tetra)
        // but for 200k voxels and 10k tetras this is 2 billion tests, which is too slow.
        // Several optimizations are possible:
        //   per tetra:
        // - compute bounding box of tetra in 1UVL to only test voxels inside that box
        // - store tetra assignment to tiles in 1UVL space to only test voxels in those tiles
        //   per voxel:
        // - only test tetras that are assigned to that voxel / tile
        const s3_start = performance.now();
 // Add WebGPU initialization at the top of the script, after the document structure
let device, gpuContext;

async function initWebGPU() {
    if (!navigator.gpu) {
        throw new Error("WebGPU not supported");
    }
    
    const adapter = await navigator.gpu.requestAdapter();
    device = await adapter.requestDevice();
    
    return device;
}

// Replace the entire Stage 3 section with this:
async function stage3WebGPU(valid_tetras, vertices_in_suvl, vertices_in_1uvl, voxels) {
    if (!device) {
        await initWebGPU();
    }
    
    const s3_start = performance.now();
    
    const RES = hypercamera_sensor_resolution;
    const TILE_SZ = 1;
    const TILE_RES = RES / TILE_SZ;
    
    // ===== PART 1: Build Acceleration Structure =====
    
    // Create shader module for building accel structure
    const buildAccelStructureShader = device.createShaderModule({
        code: `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices_1uvl: array<Vector4D>;
@group(0) @binding(2) var<storage, read_write> cell_counts: array<atomic<u32>>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // num_tetras, TILE_RES, RES, unused

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tetra_index = global_id.x;
    let num_tetras = params.x;
    let TILE_RES = params.y;
    
    if (tetra_index >= num_tetras) {
        return;
    }
    
    let tetra = tetras[tetra_index];
    let v0_1uvl = vertices_1uvl[tetra.i0];
    let v1_1uvl = vertices_1uvl[tetra.i1];
    let v2_1uvl = vertices_1uvl[tetra.i2];
    let v3_1uvl = vertices_1uvl[tetra.i3];
    
    let u_min = min(min(v0_1uvl.y, v1_1uvl.y), min(v2_1uvl.y, v3_1uvl.y));
    let u_max = max(max(v0_1uvl.y, v1_1uvl.y), max(v2_1uvl.y, v3_1uvl.y));
    let v_min = min(min(v0_1uvl.z, v1_1uvl.z), min(v2_1uvl.z, v3_1uvl.z));
    let v_max = max(max(v0_1uvl.z, v1_1uvl.z), max(v2_1uvl.z, v3_1uvl.z));
    let l_min = min(min(v0_1uvl.w, v1_1uvl.w), min(v2_1uvl.w, v3_1uvl.w));
    let l_max = max(max(v0_1uvl.w, v1_1uvl.w), max(v2_1uvl.w, v3_1uvl.w));
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let TU_min = u32(clamp(floor((u_min - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TU_max = u32(clamp(ceil((u_max - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_min = u32(clamp(floor((v_min - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_max = u32(clamp(ceil((v_max - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_min = u32(clamp(floor((l_min - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_max = u32(clamp(ceil((l_max - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    
    for (var TU = TU_min; TU <= TU_max; TU++) {
        for (var TV = TV_min; TV <= TV_max; TV++) {
            for (var TL = TL_min; TL <= TL_max; TL++) {
                let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
                atomicAdd(&cell_counts[CELL_ID], 1u);
            }
        }
    }
}
`
    });
    
    // Create shader module for filling tetra indices
    const fillIndicesShader = device.createShaderModule({
        code: `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices_1uvl: array<Vector4D>;
@group(0) @binding(2) var<storage, read> cell_offsets: array<u32>;
@group(0) @binding(3) var<storage, read_write> cell_counters: array<atomic<u32>>;
@group(0) @binding(4) var<storage, read_write> cell_tetra_indices: array<u32>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // num_tetras, TILE_RES, RES, unused

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tetra_index = global_id.x;
    let num_tetras = params.x;
    let TILE_RES = params.y;
    
    if (tetra_index >= num_tetras) {
        return;
    }
    
    let tetra = tetras[tetra_index];
    let v0_1uvl = vertices_1uvl[tetra.i0];
    let v1_1uvl = vertices_1uvl[tetra.i1];
    let v2_1uvl = vertices_1uvl[tetra.i2];
    let v3_1uvl = vertices_1uvl[tetra.i3];
    
    let u_min = min(min(v0_1uvl.y, v1_1uvl.y), min(v2_1uvl.y, v3_1uvl.y));
    let u_max = max(max(v0_1uvl.y, v1_1uvl.y), max(v2_1uvl.y, v3_1uvl.y));
    let v_min = min(min(v0_1uvl.z, v1_1uvl.z), min(v2_1uvl.z, v3_1uvl.z));
    let v_max = max(max(v0_1uvl.z, v1_1uvl.z), max(v2_1uvl.z, v3_1uvl.z));
    let l_min = min(min(v0_1uvl.w, v1_1uvl.w), min(v2_1uvl.w, v3_1uvl.w));
    let l_max = max(max(v0_1uvl.w, v1_1uvl.w), max(v2_1uvl.w, v3_1uvl.w));
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let TU_min = u32(clamp(floor((u_min - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TU_max = u32(clamp(ceil((u_max - S_U_START) / S_U_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_min = u32(clamp(floor((v_min - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TV_max = u32(clamp(ceil((v_max - S_V_START) / S_V_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_min = u32(clamp(floor((l_min - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    let TL_max = u32(clamp(ceil((l_max - S_L_START) / S_L_RANGE * f32(TILE_RES)), 0.0, f32(TILE_RES - 1)));
    
    for (var TU = TU_min; TU <= TU_max; TU++) {
        for (var TV = TV_min; TV <= TV_max; TV++) {
            for (var TL = TL_min; TL <= TL_max; TL++) {
                let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
                let offset = cell_offsets[CELL_ID];
                let local_index = atomicAdd(&cell_counters[CELL_ID], 1u);
                cell_tetra_indices[offset + local_index] = tetra_index;
            }
        }
    }
}
`
    });
    
    // Prepare tetra data
    const tetraData = new Uint32Array(valid_tetras.length * 5);
    for (let i = 0; i < valid_tetras.length; i++) {
        const tetra = valid_tetras[i];
        tetraData[i * 5 + 0] = tetra.indices[0];
        tetraData[i * 5 + 1] = tetra.indices[1];
        tetraData[i * 5 + 2] = tetra.indices[2];
        tetraData[i * 5 + 3] = tetra.indices[3];
        tetraData[i * 5 + 4] = tetra.color;
    }
    
    // Prepare vertex data
    const vertices1UVLData = new Float32Array(vertices_in_1uvl.length * 4);
    for (let i = 0; i < vertices_in_1uvl.length; i++) {
        const v = vertices_in_1uvl[i];
        vertices1UVLData[i * 4 + 0] = v.x;
        vertices1UVLData[i * 4 + 1] = v.y;
        vertices1UVLData[i * 4 + 2] = v.z;
        vertices1UVLData[i * 4 + 3] = v.w;
    }
    
    // Create buffers
    const tetraBuffer = device.createBuffer({
        size: tetraData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(tetraBuffer, 0, tetraData);
    
    const vertices1UVLBuffer = device.createBuffer({
        size: vertices1UVLData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(vertices1UVLBuffer, 0, vertices1UVLData);
    
    const cellCountsBuffer = device.createBuffer({
        size: TILE_RES * TILE_RES * TILE_RES * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    
    const paramsData = new Uint32Array([valid_tetras.length, TILE_RES, RES, 0]);
    const paramsBuffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(paramsBuffer, 0, paramsData);
    
    // Create bind group layout and pipeline for counting
    const countBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
        ]
    });
    
    const paramsBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
        ]
    });
    
    const countPipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [countBindGroupLayout, paramsBindGroupLayout]
    });
    
    const countPipeline = device.createComputePipeline({
        layout: countPipelineLayout,
        compute: {
            module: buildAccelStructureShader,
            entryPoint: 'main'
        }
    });
    
    const countBindGroup = device.createBindGroup({
        layout: countBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: tetraBuffer } },
            { binding: 1, resource: { buffer: vertices1UVLBuffer } },
            { binding: 2, resource: { buffer: cellCountsBuffer } }
        ]
    });
    
    const paramsBindGroup = device.createBindGroup({
        layout: paramsBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: paramsBuffer } }
        ]
    });
    
    // Execute counting pass
    const countEncoder = device.createCommandEncoder();
    const countPass = countEncoder.beginComputePass();
    countPass.setPipeline(countPipeline);
    countPass.setBindGroup(0, countBindGroup);
    countPass.setBindGroup(1, paramsBindGroup);
    const workgroupsCount = Math.ceil(valid_tetras.length / 64);
    countPass.dispatchWorkgroups(workgroupsCount);
    countPass.end();
    device.queue.submit([countEncoder.finish()]);
    
    // Read back cell counts to compute offsets
    const cellCountsReadBuffer = device.createBuffer({
        size: TILE_RES * TILE_RES * TILE_RES * 4,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    
    const copyEncoder = device.createCommandEncoder();
    copyEncoder.copyBufferToBuffer(cellCountsBuffer, 0, cellCountsReadBuffer, 0, TILE_RES * TILE_RES * TILE_RES * 4);
    device.queue.submit([copyEncoder.finish()]);
    
    await cellCountsReadBuffer.mapAsync(GPUMapMode.READ);
    const cellCountsArray = new Uint32Array(cellCountsReadBuffer.getMappedRange());
    const cellCountsCopy = new Uint32Array(cellCountsArray);
    cellCountsReadBuffer.unmap();
    
    // Compute offsets on CPU
    const cellOffsets = new Uint32Array(TILE_RES * TILE_RES * TILE_RES);
    let runningOffset = 0;
    for (let i = 0; i < cellOffsets.length; i++) {
        cellOffsets[i] = runningOffset;
        runningOffset += cellCountsCopy[i];
    }
    const totalEntries = runningOffset;
    
    const s3p1_end = performance.now();
    console.log(`Stage 3 Part 1 (WebGPU): ${valid_tetras.length} tetras mapped to ${totalEntries} entries in ${(s3p1_end - s3_start).toFixed(2)} ms`);
    
    // ===== PART 2: Fill tetra indices =====
    
    const cellOffsetsBuffer = device.createBuffer({
        size: cellOffsets.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellOffsetsBuffer, 0, cellOffsets);
    
    const cellCountersBuffer = device.createBuffer({
        size: TILE_RES * TILE_RES * TILE_RES * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(cellCountersBuffer, 0, new Uint32Array(TILE_RES * TILE_RES * TILE_RES));
    
    const cellTetraIndicesBuffer = device.createBuffer({
        size: totalEntries * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    
    const fillBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
        ]
    });
    
    const fillPipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [fillBindGroupLayout, paramsBindGroupLayout]
    });
    
    const fillPipeline = device.createComputePipeline({
        layout: fillPipelineLayout,
        compute: {
            module: fillIndicesShader,
            entryPoint: 'main'
        }
    });
    
    const fillBindGroup = device.createBindGroup({
        layout: fillBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: tetraBuffer } },
            { binding: 1, resource: { buffer: vertices1UVLBuffer } },
            { binding: 2, resource: { buffer: cellOffsetsBuffer } },
            { binding: 3, resource: { buffer: cellCountersBuffer } },
            { binding: 4, resource: { buffer: cellTetraIndicesBuffer } }
        ]
    });
    
    const fillEncoder = device.createCommandEncoder();
    const fillPass = fillEncoder.beginComputePass();
    fillPass.setPipeline(fillPipeline);
    fillPass.setBindGroup(0, fillBindGroup);
    fillPass.setBindGroup(1, paramsBindGroup);
    fillPass.dispatchWorkgroups(workgroupsCount);
    fillPass.end();
    device.queue.submit([fillEncoder.finish()]);
    
    // ===== PART 3: Rasterize voxels =====
    
    const rasterizeShader = device.createShaderModule({
        code: `
struct TetraData {
    i0: u32,
    i1: u32,
    i2: u32,
    i3: u32,
    color: u32,
}

struct Vector4D {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

struct Voxel {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
    s: f32,
    _pad: u32,
    _pad2: u32,
    _pad3: u32,
}

@group(0) @binding(0) var<storage, read> tetras: array<TetraData>;
@group(0) @binding(1) var<storage, read> vertices_suvl: array<Vector4D>;
@group(0) @binding(2) var<storage, read> vertices_1uvl: array<Vector4D>;
@group(0) @binding(3) var<storage, read> cell_offsets: array<u32>;
@group(0) @binding(4) var<storage, read> cell_counts: array<u32>;
@group(0) @binding(5) var<storage, read> cell_tetra_indices: array<u32>;
@group(0) @binding(6) var<storage, read_write> voxels: array<Voxel>;

@group(1) @binding(0) var<uniform> params: vec4<u32>; // RES, TILE_RES, TILE_SZ, unused

fn signedVolume(a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> f32 {
    let ab = b - a;
    let ac = c - a;
    let ad = d - a;
    return dot(cross(ab, ac), ad) / 6.0;
}

fn barycentricCoordinates(P: vec3<f32>, A: vec3<f32>, B: vec3<f32>, C: vec3<f32>, D: vec3<f32>) -> vec4<f32> {
    let V = signedVolume(A, B, C, D);
    if (abs(V) < 1e-10) {
        return vec4<f32>(-1.0);
    }
    let alpha = signedVolume(P, B, C, D) / V;
    let beta = signedVolume(A, P, C, D) / V;
    let gamma = signedVolume(A, B, P, D) / V;
    let delta = signedVolume(A, B, C, P) / V;
    return vec4<f32>(alpha, beta, gamma, delta);
}

@compute @workgroup_size(4, 4, 4)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let RES = params.x;
    let TILE_RES = params.y;
    let TILE_SZ = params.z;
    
    let U = global_id.x;
    let V = global_id.y;
    let L = global_id.z;
    
    if (U >= RES || V >= RES || L >= RES) {
        return;
    }
    
    let TU = U / TILE_SZ;
    let TV = V / TILE_SZ;
    let TL = L / TILE_SZ;
    
    let S_U_START = -1.0;
    let S_U_RANGE = 2.0;
    let S_V_START = -1.0;
    let S_V_RANGE = 2.0;
    let S_L_START = -1.0;
    let S_L_RANGE = 2.0;
    
    let u = S_U_START + (f32(U) + 0.5) / f32(RES) * S_U_RANGE;
    let v = S_V_START + (f32(V) + 0.5) / f32(RES) * S_V_RANGE;
    let l = S_L_START + (f32(L) + 0.5) / f32(RES) * S_L_RANGE;
    
    let CELL_ID = TU + TV * TILE_RES + TL * TILE_RES * TILE_RES;
    let cell_offset = cell_offsets[CELL_ID];
    let cell_count = cell_counts[CELL_ID];
    
    let voxel_index = U + V * RES + L * RES * RES;
    var best_voxel = voxels[voxel_index];
    
    for (var i = 0u; i < cell_count; i++) {
        let tetra_index = cell_tetra_indices[cell_offset + i];
        let tetra = tetras[tetra_index];
        
        let v0_1uvl = vertices_1uvl[tetra.i0];
        let v1_1uvl = vertices_1uvl[tetra.i1];
        let v2_1uvl = vertices_1uvl[tetra.i2];
        let v3_1uvl = vertices_1uvl[tetra.i3];
        
        let v0_s = vertices_suvl[tetra.i0].x;
        let v1_s = vertices_suvl[tetra.i1].x;
        let v2_s = vertices_suvl[tetra.i2].x;
        let v3_s = vertices_suvl[tetra.i3].x;
        
        let A = vec3<f32>(v0_1uvl.y, v0_1uvl.z, v0_1uvl.w);
        let B = vec3<f32>(v1_1uvl.y, v1_1uvl.z, v1_1uvl.w);
        let C = vec3<f32>(v2_1uvl.y, v2_1uvl.z, v2_1uvl.w);
        let D = vec3<f32>(v3_1uvl.y, v3_1uvl.z, v3_1uvl.w);
        let P = vec3<f32>(u, v, l);
        
        let u_min = min(min(v0_1uvl.y, v1_1uvl.y), min(v2_1uvl.y, v3_1uvl.y));
        let u_max = max(max(v0_1uvl.y, v1_1uvl.y), max(v2_1uvl.y, v3_1uvl.y));
        let v_min = min(min(v0_1uvl.z, v1_1uvl.z), min(v2_1uvl.z, v3_1uvl.z));
        let v_max = max(max(v0_1uvl.z, v1_1uvl.z), max(v2_1uvl.z, v3_1uvl.z));
        let l_min = min(min(v0_1uvl.w, v1_1uvl.w), min(v2_1uvl.w, v3_1uvl.w));
        let l_max = max(max(v0_1uvl.w, v1_1uvl.w), max(v2_1uvl.w, v3_1uvl.w));
        
        if (u < u_min || u > u_max || v < v_min || v > v_max || l < l_min || l > l_max) {
            continue;
        }
        
        let bary = barycentricCoordinates(P, A, B, C, D);
        
        if (all(bary >= vec4<f32>(0.0)) && all(bary <= vec4<f32>(1.0))) {
            let s = bary.x * v0_s + bary.y * v1_s + bary.z * v2_s + bary.w * v3_s;
            
            if (s < best_voxel.s) {
                best_voxel.r = f32(((tetra_index + 1u) * 53u) % 256u);
                best_voxel.g = f32(((tetra_index + 1u) * 97u) % 256u);
                best_voxel.b = f32(((tetra_index + 1u) * 193u) % 256u);
                best_voxel.a = 0.1;
                best_voxel.s = s;
            }
        }
    }
    
    voxels[voxel_index] = best_voxel;
}
`
    });
    
    // Prepare SUVL vertex data
    const verticesSUVLData = new Float32Array(vertices_in_suvl.length * 4);
    for (let i = 0; i < vertices_in_suvl.length; i++) {
        const v = vertices_in_suvl[i];
        verticesSUVLData[i * 4 + 0] = v.x;
        verticesSUVLData[i * 4 + 1] = v.y;
        verticesSUVLData[i * 4 + 2] = v.z;
        verticesSUVLData[i * 4 + 3] = v.w;
    }
    
    const verticesSUVLBuffer = device.createBuffer({
        size: verticesSUVLData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(verticesSUVLBuffer, 0, verticesSUVLData);
    
    // Prepare voxel data
    const voxelData = new Float32Array(RES * RES * RES * 8); // 8 floats per voxel (with padding)
    for (let x = 0; x < RES; x++) {
        for (let y = 0; y < RES; y++) {
            for (let z = 0; z < RES; z++) {
                const idx = (x + y * RES + z * RES * RES) * 8;
                const voxel = voxels[x][y][z];
                voxelData[idx + 0] = voxel.r;
                voxelData[idx + 1] = voxel.g;
                voxelData[idx + 2] = voxel.b;
                voxelData[idx + 3] = voxel.a;
                voxelData[idx + 4] = voxel.s;
                voxelData[idx + 5] = 0; // padding
                voxelData[idx + 6] = 0;
                voxelData[idx + 7] = 0;
            }
        }
    }

const voxelsBuffer = device.createBuffer({
    size: voxelData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
});
device.queue.writeBuffer(voxelsBuffer, 0, voxelData);

// Update params for rasterization
const rasterParamsData = new Uint32Array([RES, TILE_RES, TILE_SZ, 0]);
const rasterParamsBuffer = device.createBuffer({
    size: 16,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});
device.queue.writeBuffer(rasterParamsBuffer, 0, rasterParamsData);

const rasterBindGroupLayout = device.createBindGroupLayout({
    entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
    ]
});

const rasterParamsBindGroupLayout = device.createBindGroupLayout({
    entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }
    ]
});

const rasterPipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [rasterBindGroupLayout, rasterParamsBindGroupLayout]
});

const rasterPipeline = device.createComputePipeline({
    layout: rasterPipelineLayout,
    compute: {
        module: rasterizeShader,
        entryPoint: 'main'
    }
});

const rasterBindGroup = device.createBindGroup({
    layout: rasterBindGroupLayout,
    entries: [
        { binding: 0, resource: { buffer: tetraBuffer } },
        { binding: 1, resource: { buffer: verticesSUVLBuffer } },
        { binding: 2, resource: { buffer: vertices1UVLBuffer } },
        { binding: 3, resource: { buffer: cellOffsetsBuffer } },
        { binding: 4, resource: { buffer: cellCountsBuffer } },
        { binding: 5, resource: { buffer: cellTetraIndicesBuffer } },
        { binding: 6, resource: { buffer: voxelsBuffer } }
    ]
});

const rasterParamsBindGroup = device.createBindGroup({
    layout: rasterParamsBindGroupLayout,
    entries: [
        { binding: 0, resource: { buffer: rasterParamsBuffer } }
    ]
});

const rasterEncoder = device.createCommandEncoder();
const rasterPass = rasterEncoder.beginComputePass();
rasterPass.setPipeline(rasterPipeline);
rasterPass.setBindGroup(0, rasterBindGroup);
rasterPass.setBindGroup(1, rasterParamsBindGroup);
const workgroupsX = Math.ceil(RES / 4);
const workgroupsY = Math.ceil(RES / 4);
const workgroupsZ = Math.ceil(RES / 4);
rasterPass.dispatchWorkgroups(workgroupsX, workgroupsY, workgroupsZ);
rasterPass.end();
device.queue.submit([rasterEncoder.finish()]);

// Read back voxel data
const voxelsReadBuffer = device.createBuffer({
    size: voxelData.byteLength,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
});

const readEncoder = device.createCommandEncoder();
readEncoder.copyBufferToBuffer(voxelsBuffer, 0, voxelsReadBuffer, 0, voxelData.byteLength);
device.queue.submit([readEncoder.finish()]);

await voxelsReadBuffer.mapAsync(GPUMapMode.READ);
const voxelsArray = new Float32Array(voxelsReadBuffer.getMappedRange());

// Copy back to CPU voxels array
let fragCount = 0;
for (let x = 0; x < RES; x++) {
    for (let y = 0; y < RES; y++) {
        for (let z = 0; z < RES; z++) {
            const idx = (x + y * RES + z * RES * RES) * 8;
            voxels[x][y][z] = {
                r: voxelsArray[idx + 0],
                g: voxelsArray[idx + 1],
                b: voxelsArray[idx + 2],
                a: voxelsArray[idx + 3],
                s: voxelsArray[idx + 4]
            };
            if (voxels[x][y][z].a > 0) fragCount++;
        }
    }
}

voxelsReadBuffer.unmap();

const s3_end = performance.now();

return {
    timingInfo: `Stage 3 (WebGPU): Processed ${RES * RES * RES} voxels with ${fragCount} fragments in ${(s3_end - s3_start).toFixed(2)} ms`,
    fragCount: fragCount,
    testCount: 0 // GPU doesn't report this
};
}

const s3Result = await stage3WebGPU(valid_tetras, vertices_in_suvl, vertices_in_1uvl, voxels);
timingsInfosHtml += `<p>${s3Result.timingInfo}</p>`;
fragCount = s3Result.fragCount;
testCount = s3Result.testCount;

        // ---------------------------------------------------------------------------------
        // Stage 4: Per-Pixel - DDA traversal through S-buffer to composite screen color
        
        let simTime = 0;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Camera setup
        const camera = {
            distance: hypercamera_sensor_resolution * 2., // Distance from center
            theta: Math.PI / 4, // Azimuth angle
            phi: Math.PI / 4, // Polar angle
            lookAt: { x: hypercamera_sensor_resolution / 2., y: hypercamera_sensor_resolution / 2., z: hypercamera_sensor_resolution / 2. },
            fov: 60
        };
        
        // Calculate camera position from spherical coordinates
        function getCameraPos() {
            return {
                x: camera.lookAt.x + camera.distance * Math.sin(camera.phi) * Math.cos(camera.theta),
                y: camera.lookAt.y + camera.distance * Math.cos(camera.phi),
                z: camera.lookAt.z + camera.distance * Math.sin(camera.phi) * Math.sin(camera.theta)
            };
        }
        
        // Vector operations
        function sub(a, b) {
            return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
        }
        
        function add(a, b) {
            return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
        }
        
        function scale(v, s) {
            return { x: v.x * s, y: v.y * s, z: v.z * s };
        }
        
        function length(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
        }
        
        function normalize(v) {
            const len = length(v);
            return len > 0 ? { x: v.x / len, y: v.y / len, z: v.z / len } : v;
        }
        
        function cross(a, b) {
            return {
                x: a.y * b.z - a.z * b.y,
                y: a.z * b.x - a.x * b.z,
                z: a.x * b.y - a.y * b.x
            };
        }
        
        // Calculate camera basis vectors
        function setupCamera() {
            const pos = getCameraPos();
            const forward = normalize(sub(camera.lookAt, pos));
            const right = normalize(cross({ x: 0, y: 1, z: 0 }, forward));
            const up = cross(forward, right);
            return { forward, right, up, pos };
        }
        
        // Ray-box intersection to find entry point into grid
        function rayBoxIntersection(origin, direction) {
            const boxMin = { x: 0, y: 0, z: 0 };
            const boxMax = { x: hypercamera_sensor_resolution, y: hypercamera_sensor_resolution, z: hypercamera_sensor_resolution };
            
            let tMin = -Infinity;
            let tMax = Infinity;
            
            for (const axis of ['x', 'y', 'z']) {
                if (Math.abs(direction[axis]) < 1e-10) {
                    if (origin[axis] < boxMin[axis] || origin[axis] > boxMax[axis]) {
                        return null;
                    }
                } else {
                    const t1 = (boxMin[axis] - origin[axis]) / direction[axis];
                    const t2 = (boxMax[axis] - origin[axis]) / direction[axis];
                    
                    tMin = Math.max(tMin, Math.min(t1, t2));
                    tMax = Math.min(tMax, Math.max(t1, t2));
                }
            }
            
            if (tMin > tMax || tMax < 0) return null;
            
            return tMin > 0 ? tMin : 0;
        }
        
        // DDA ray traversal
        function ddaRaycast(origin, direction) {
            // First, find where ray enters the grid
            const tEntry = rayBoxIntersection(origin, direction);
            if (tEntry === null) return [];
            
            // Start position at grid entry
            const startPos = {
                x: origin.x + direction.x * tEntry,
                y: origin.y + direction.y * tEntry,
                z: origin.z + direction.z * tEntry
            };
            
            // Clamp to grid bounds and get starting voxel
            let x = Math.floor(Math.max(0, Math.min(hypercamera_sensor_resolution - 0.001, startPos.x)));
            let y = Math.floor(Math.max(0, Math.min(hypercamera_sensor_resolution - 0.001, startPos.y)));
            let z = Math.floor(Math.max(0, Math.min(hypercamera_sensor_resolution - 0.001, startPos.z)));
            
            const stepX = direction.x >= 0 ? 1 : -1;
            const stepY = direction.y >= 0 ? 1 : -1;
            const stepZ = direction.z >= 0 ? 1 : -1;
            
            const tDeltaX = Math.abs(1 / direction.x);
            const tDeltaY = Math.abs(1 / direction.y);
            const tDeltaZ = Math.abs(1 / direction.z);
            
            let tMaxX = tDeltaX * (direction.x >= 0 ? (x + 1 - startPos.x) : (startPos.x - x));
            let tMaxY = tDeltaY * (direction.y >= 0 ? (y + 1 - startPos.y) : (startPos.y - y));
            let tMaxZ = tDeltaZ * (direction.z >= 0 ? (z + 1 - startPos.z) : (startPos.z - z));
            
            const hits = [];
            let t = 0;
            
            for (let i = 0; i < hypercamera_sensor_resolution * 3; i++) {
                if (x < 0 || x >= hypercamera_sensor_resolution || y < 0 || y >= hypercamera_sensor_resolution || z < 0 || z >= hypercamera_sensor_resolution) {
                    break;
                }

                // if we have more than 10 hits, break - we're likely already at max alpha
                if (hits.length > 10) {
                    break;
                }
                
                const tExit = Math.min(tMaxX, tMaxY, tMaxZ);
                const rayLength = tExit - t;
                
                const voxel = voxels[x][y][z];
                if (voxel.a > 0) {
                    hits.push({
                        voxel: voxel,
                        rayLength: rayLength
                    });
                }
                
                // Step to next voxel
                if (tMaxX < tMaxY) {
                    if (tMaxX < tMaxZ) {
                        t = tMaxX;
                        tMaxX += tDeltaX;
                        x += stepX;
                    } else {
                        t = tMaxZ;
                        tMaxZ += tDeltaZ;
                        z += stepZ;
                    }
                } else {
                    if (tMaxY < tMaxZ) {
                        t = tMaxY;
                        tMaxY += tDeltaY;
                        y += stepY;
                    } else {
                        t = tMaxZ;
                        tMaxZ += tDeltaZ;
                        z += stepZ;
                    }
                }
            }
            
            return hits;
        }
        
        // Composite colors with alpha blending based on ray length
        function compositeColors(hits) {
            let r = 0, g = 0, b = 0;
            let alpha = 0;
            
            for (const hit of hits) {
                const voxel = hit.voxel;
                const effectiveAlpha = Math.min(1, voxel.a); // * hit.rayLength * 3);
                const srcAlpha = effectiveAlpha * (1 - alpha);
                
                r += voxel.r * srcAlpha;
                g += voxel.g * srcAlpha;
                b += voxel.b * srcAlpha;
                alpha += srcAlpha;
                
                if (alpha >= 0.99) break;
            }
            
            // Background color
            const bgR = 20, bgG = 20, bgB = 20;
            r += bgR * (1 - alpha);
            g += bgG * (1 - alpha);
            b += bgB * (1 - alpha);
            
            return { r, g, b };
        }
        
        // Render the scene
        function render() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            const { forward, right, up, pos } = setupCamera();
            const aspectRatio = width / height;
            const fovScale = Math.tan(camera.fov * Math.PI / 360);
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const ndcX = (2 * px / width - 1) * aspectRatio * fovScale;
                    const ndcY = (1 - 2 * py / height) * fovScale;
                    
                    const rayDir = normalize(add(
                        add(forward, scale(right, ndcX)),
                        scale(up, ndcY)
                    ));
                    
                    const hits = ddaRaycast(pos, rayDir);
                    const color = compositeColors(hits);
                    
                    const idx = (py * width + px) * 4;
                    data[idx] = Math.min(255, color.r);
                    data[idx + 1] = Math.min(255, color.g);
                    data[idx + 2] = Math.min(255, color.b);
                    data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Mouse interaction
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            camera.theta += -deltaX * 0.01;
            camera.phi = Math.max(0.1, Math.min(Math.PI - 0.1, camera.phi - deltaY * 0.01));
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            render();
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Scrolling changes camera distance
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.distance += e.deltaY * 0.05;
            camera.distance = Math.max(5, Math.min(hypercamera_sensor_resolution * 4.0, camera.distance));
            render();
        });


        
        // fillVoxelsRandom();
        // Initial render
        // console.time('render');
        const s4_start = performance.now();
        render();
        const s4_end = performance.now();
        console.log(`Stage 4: Rendered initial frame in ${(s4_end - s4_start).toFixed(2)} ms`);
        timingsInfosHtml += `<p>Stage 4: Rendered initial frame in ${(s4_end - s4_start).toFixed(2)} ms</p>`;
        // console.timeEnd('render');

        document.getElementById('timingsinfo').innerHTML = timingsInfosHtml;
    })();


        // render at fixed rate
        // setInterval(() => {
        //     simTime += 0.1;
        //     // fillVoxelsAnimated();
        //     render();
        // }, 100);



        // testBarycentric3D();

    </script>
</body>
</html>

<!DOCTYPE html> <html>
  <head>
    <meta charset="utf-8">
    <title>3D TF Visualizer</title>
    <style>
      body { margin: 0; }


      /* sidepanel style */
      .sidepanel {
        flex-grow: 1;
        background-color: #ffffff;
        padding: 10px;
        border-right: 5px solid red;
        overflow-y: scroll;
        max-height: 98vh;
      }
      .rsidepanel {
        flex-grow: 1;
        background-color: #ffffff;
        padding: 10px;
        border-left: 5px solid red;
        overflow-y: scroll;
        max-height: 98vh;
      }
      .canvaspanel {
        flex-grow: 1;
        max-height: 100vh;
        overflow-y: clip;
        position: relative;
      }

      .canvaslabels {
        position: absolute;
        text-align: center;
        z-index: 100;
        width: 100%;
        height: 100%;
        display:block;
        pointer-events: none;
      }

      /* change font for whole page */
      body {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      /* hide dl and dl2 labels */
      .dl {
        display: none;
      }
      .dl2 {
        display: none;
      }

      /* make input boxes look good */
      input {
        border: 1px solid #cccccc;
        border-radius: 10px;
        padding: 3px;
        margin: 3px;
      }

      input {
        width: 70px;
      }
      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
          /* display: none; <- Crashes Chrome on hover */
          -webkit-appearance: none;
          margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
      }

      input[type=number] {
          -moz-appearance:textfield; /* Firefox */
      }
      /* make radio switch look good */
      input[type=radio] {
        border: 1px solid #cccccc;
        border-radius: 10px;
        padding: 3px;
        margin: 3px;
        width: 20px;
        height: 20px;
      }

      /* font color for units */
      .angleunit {
        color: #973434;
      }

      /* buttons looking flat design */
      button {
        background-color: #fdeded;
        border: 1px solid #ff9898;
        border-radius: 10px;
        padding: 10px;
        margin: 3px;
      }

      /* button color on click */
      button:active {
        background-color: #faf6f6;
      }

      /* dropdown looking flat */
      select {
        background-color: #fdeded;
        border: 1px solid #ff9898;
        border-radius: 10px;
        padding: 3px;
        margin: 3px;
      }
      
      /* Align slider with text */
      .slider {
        vertical-align: middle;
      }

      /* make the cheatsheet look like a paper */
      .cheatsheet {
        background-color: #ffffff;
        border: 1px solid #cccccc;
        border-radius: 10px;
        padding: 10px;
        margin: 10px;
      }

      /* border around tf inputs */
      .tfinput {
        border: 1px solid #cccccc;
        border-radius: 10px;
        padding: 10px;
        margin: 10px;
      }

      #tf_tree_disp {
        border: 1px solid #cccccc;
        border-radius: 10px;
        padding: 10px;
        margin: 10px;
      }

      /* smaller font */
      #debug_frame_infos {
        font-size: 0.8em;
      }
    </style>
  </head>
  <body>
    <div class="flex-container" style="display:flex">
      <div class="sidepanel">
        <p> 3D Transform Visualization tool made by <a href="http://dugas.ch">Daniel</a></p>
        <div class="dcol">
          <h2>Input</h2>
          <p>Angle format:
          <label><input type="radio" id="iformatrad" name="iformat" value="0" checked="" onchange="update(0, -1)">Radians</label>
          <label><input type="radio" id="iformatdeg" name="iformat" value="1" onchange="update(0, -1)">Degrees</label>
          </p>
          Transforms:
          <div id="TFInputs">
            <div id="T0">
              <h3>T0</h3>
              <input type="string" id="T0parent" value="parent" oninput="update(0, 7)">
              <input type="string" id="T0child" value="T0" oninput="update(0, 7)">
              <p class="pi" id="T0ip6">Translation vector (xyz)
              <br><span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T0t0" value="0" oninput="update(0, 6)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T0t1" value="0" oninput="update(0, 6)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T0t2" value="0" oninput="update(0, 6)">
              </p>
              <button type="button" onclick="eye(0);">Reset to Identity</button>
              <p class="pi" id="T0ip0">Rotation matrix
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m00" value="1" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m01" value="0" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m02" value="0" oninput="update(0, 0)"> &nbsp;
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m10" value="0" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m11" value="1" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m12" value="0" oninput="update(0, 0)"> &nbsp;
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m20" value="0" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m21" value="0" oninput="update(0, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T0m22" value="1" oninput="update(0, 0)">
              </p>
              <p class="pi" id="T0ip1">Quaternion (xyzw) 
              <br>
              <span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T0q0" value="0" oninput="update(0, 1)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T0q1" value="0" oninput="update(0, 1)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T0q2" value="0" oninput="update(0, 1)">
              <span class="dl">w</span><input type="number" pattern="\d+(\.\d*)?" id="T0q3" value="1" oninput="update(0, 1)">
              </p>
              <p class="pi" id="T0ip2">Axis-angle (xyz, angle)<span class="angleunit" name="spananglei"> (radians)</span>
              <br>
              <span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T0a0" value="0" oninput="update(0, 2)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T0a1" value="0" oninput="update(0, 2)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T0a2" value="0" oninput="update(0, 2)">
              <span class="dl">Angle<span class="angleunit" name="spananglei"> (radians)</span></span><input type="number" pattern="\d+(\.\d*)?" id="T0a3" value="0" oninput="update(0, 2)">
              </p>
              <p class="pi" id="T0ip3">Axis with angle magnitude<span class="angleunit" name="spananglei"> (radians)</span>
              <br><span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T0r0" value="0" oninput="update(0, 3)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T0r1" value="0" oninput="update(0, 3)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T0r2" value="0" oninput="update(0, 3)">
              </p>
              <p class="pi" id="T0ip4">Euler angles of multiple axis rotations<span class="angleunit" name="spananglei"> (radians)</span>
              <br>
              <span class="sel"><select id="T0euler" onchange="update(0, 4)">
              <option value="XYZ" selected="">XYZ</option>
              <option value="XZY">XZY</option>
              <option value="YXZ">YXZ</option>
              <option value="YZX">YZX</option>
              <option value="ZXY">ZXY</option>
              <option value="ZYX">ZYX</option>
              </select></span>
              <span class="dl2">x</span><input type="number" pattern="\d+(\.\d*)?" id="T0e0" value="0" oninput="update(0, 4)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T0e1" value="0" oninput="update(0, 4)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T0e2" value="0" oninput="update(0, 4)">
              </p>
            </div>
            <div id="T1">
              <h3>T1</h3>
              <input type="string" id="T1parent" value="parent" oninput="update(1, 7)">
              <input type="string" id="T1child" value="T1" oninput="update(1, 7)">
              <p class="pi" id="T1ip6">Translation vector (xyz)
              <br><span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T1T1" value="0" oninput="update(1, 6)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T1t1" value="0" oninput="update(1, 6)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T1t2" value="0" oninput="update(1, 6)">
              </p>
              <button type="button" onclick="eye(1);">Reset to Identity</button>
              <p class="pi" id="T1ip0">Rotation matrix
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m00" value="1" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m01" value="0" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m02" value="0" oninput="update(1, 0)"> &nbsp;
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m10" value="0" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m11" value="1" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m12" value="0" oninput="update(1, 0)"> &nbsp;
              <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m20" value="0" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m21" value="0" oninput="update(1, 0)">
              <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T1m22" value="1" oninput="update(1, 0)">
              </p>
              <p class="pi" id="T1ip1">Quaternion (xyzw) 
              <br>
              <span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T1q0" value="0" oninput="update(1, 1)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T1q1" value="0" oninput="update(1, 1)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T1q2" value="0" oninput="update(1, 1)">
              <span class="dl">w</span><input type="number" pattern="\d+(\.\d*)?" id="T1q3" value="1" oninput="update(1, 1)">
              </p>
              <p class="pi" id="T1ip2">Axis-angle (xyz, angle)<span class="angleunit" name="spananglei"> (radians)</span>
              <br>
              <span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T1a0" value="0" oninput="update(1, 2)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T1a1" value="0" oninput="update(1, 2)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T1a2" value="0" oninput="update(1, 2)">
              <span class="dl">Angle<span class="angleunit" name="spananglei"> (radians)</span></span><input type="number" pattern="\d+(\.\d*)?" id="T1a3" value="0" oninput="update(1, 2)">
              </p>
              <p class="pi" id="T1ip3">Axis with angle magnitude<span class="angleunit" name="spananglei"> (radians)</span>
              <br><span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T1r0" value="0" oninput="update(1, 3)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T1r1" value="0" oninput="update(1, 3)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T1r2" value="0" oninput="update(1, 3)">
              </p>
              <p class="pi" id="T1ip4">Euler angles of multiple axis rotations<span class="angleunit" name="spananglei"> (radians)</span>
              <br>
              <span class="sel"><select id="T1euler" onchange="update(1, 4)">
              <option value="XYZ" selected="">XYZ</option>
              <option value="XZY">XZY</option>
              <option value="YXZ">YXZ</option>
              <option value="YZX">YZX</option>
              <option value="ZXY">ZXY</option>
              <option value="ZYX">ZYX</option>
              </select></span>
              <span class="dl2">x</span><input type="number" pattern="\d+(\.\d*)?" id="T1e0" value="0" oninput="update(1, 4)">
              <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T1e1" value="0" oninput="update(1, 4)">
              <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T1e2" value="0" oninput="update(1, 4)">
              </p>
            </div>
          </div>
          <button type="button" onclick="add_transform();">Add Transform</button>
        </div>
        <h2>View Options</h2>
          <!-- axes scaling: make sure text is vertically centered -->
          <input type="range" min="0" max="100" value="100" class="slider" id="myRange">Scale Axes
          <label><input type="checkbox" id="showgrid" name="igrid" value="0" checked="" onchange="toggleGrid()">Grid</label>
        <button type="button" onclick="standardview();">Standard View</button>
        <button type="button" onclick="planeview(0);">X Plane View</button>
        <button type="button" onclick="planeview(1);">Y Plane View</button>
        <button type="button" onclick="planeview(2);">Z Plane View</button>
      </div>
      <div id="canvas" class="canvaspanel">
        <div id="canvaslabels" class="canvaslabels">
          <div class="label" style="color: rgb(144, 144, 144); position: absolute; user-select: none; transform: translate(1146.22px, 222.947px); z-index: 5;" draggable="false">C</div>
        </div>
      </div>
      <div class="rsidepanel">
        <h3>TF Tree</h3>
          <div id="tf_tree_errors"></div>
          <div id="tf_tree_disp"></div>
          <div id="test_tree_errors"></div>
          <div id="test_tree_disp"></div>
          Reference frame:
          <select id="reference_frame_dropdown" onchange="update_ref_frame()">
            <option value="0" selected="">parent</option>
            <option value="1">T0</option>
            <option value="2">T1</option>
            <option value="3">T2</option>
          </select>
          <select id="frameinfomode" onchange="update_ref_frame()"> <!-- update ref frame to force update of frame infos -->
            <option value="quaternion" selected="">quaternion (xyzw)</option>
            <!-- <option value="euler">euler</option> -->
            <!-- <option value="matrix">matrix</option> -->
            <!-- <option value="axisangle">axis-angle</option> -->
            <!-- <option value="axismagnitude">axis-magnitude</option> -->
            <option value="ABB">ABB</option>
            <option value="compas">compas</option>
          </select>
          <div><p id="debug_frame_infos"></p></div>
      </div>
    </div>

    <script src="js/three.min.js"></script>
    <script src="js/LoaderSupport.js"></script>
    <script src="js/OBJLoader2.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/FileSaver.js"></script>
    <script>
      // Our Javascript will go here.
      const CF = 0.5; // what percentage of the window horizontally the canvas should fill -> 500px for the sidebar, or 50/50 split if the screen is too small
      const DEBUGSHAPES = false;
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera( 75, window.innerWidth * CF / window.innerHeight, 0.1, 1000 );
      const orthocam = new THREE.OrthographicCamera(-15 / CF, 15 / CF, 15, -15, 0.1, 1000 );
      var activecamera = camera;
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth * CF, window.innerHeight);
      renderer.setClearColor( 0xffffff );
      // document.body.appendChild( renderer.domElement );
      document.getElementById("canvas").appendChild( renderer.domElement );
      camera.up.set(0, 0, 1);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040))
      var light = new THREE.PointLight( 0xffffff );
      light.position.set( 0, -1, 5 );
      scene.add(light);
      var grid = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
      grid.rotation.x = Math.PI / 2;
      scene.add(grid);

      function toggleGrid() {
        var show = document.getElementById("showgrid");
        grid.visible = show.checked;
      }

      function mat4_to_log(mat4) {
              var str = "";
              for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                  str += mat4.elements[i+ j * 4].toFixed(3) + " ";
                }
                str += "\n";
              }
              return str;
            }

      function standardview() {
        camera.position.y = -5;
        camera.position.z = 3;
        camera.position.x = 3
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 0);
        activecamera = camera;
        controls.object = camera;
        controls.target.set(0, 0, 0);
        controls.screenSpacePanning = false;
        controls.update();
      }
      standardview()

      function planeview(orient) {
        if (orient == 0) {
          orthocam.position.set(0, 100, 0);
          orthocam.up.set(0, 0, 1);
        }
        if (orient == 1) {
          orthocam.position.set(100, 0, 0);
          orthocam.up.set(0, 0, 1);
        }
        if (orient == 2) {
          orthocam.position.set(0, 0, 100);
        }
        orthocam.lookAt(0, 0, 0);
        controls.object = orthocam;
        activecamera = orthocam;
        controls.target.set(0, 0, 0);
        controls.screenSpacePanning = true;
        controls.update();
      }


      function eye4() {
        var mat4 = new THREE.Matrix4();
        mat4.identity();
        return mat4;
      }

      class TFRelationship {
        constructor(parent, child, tf, is_active=true) {
          this.parent = parent;
          this.child = child;
          this.tf = tf;
          this.is_active = is_active;
        }
      }

      class TreeBuildError {
        constructor(message) {
          this.message = message;
          this.name = "TreeBuildError";
        }
      }

      
      class TFTree {
        // TF Tree structure
      // root nodes (unparented transforms)
      // other nodes have exactly one parent
      // API
      //    get_unique_nodes() -> [node, node, ...]
      //        for each pair: Set().add(parent).add(child)
      //    get_root_nodes() -> [node, node, ...]
      //        for each node in get unique nodes(): set.add(root node(node))
      //    get_children_of(node) -> [node, node, ...]
      //        for each pair: if parent == node: set.add(child)
      //    get_parent_of(node) -> node
      //        for each pair: if child == node: return parent
      //    get_parent_tf_of(node) -> Matrix4
      //        for each pair: if child == node: return tf
      //    is_root_node(node) -> bool
      //        return get_parent(node) == None
      //    get_root_node_of(node) -> node
      //          get parent(A) -> F4
      //          ...
      //          get parent(F1) -> None
      //          return F1
      //    get_descendant_in_ancestor_tf(ancestor, descendant):
      //          var tf_chain = []
      //          current_child = descendant
      //          while true:
      //          current_parent = get_parent(current_child)
      //          tf = get_parent_tf(current_child)
      //          tf_chain.push(tf)
      //          if current_parent == ancestor: break
      //          return compose(tf_chain)

      // build tree from relationships ()
      //     for each relationship (rel.parent, rel.child, tf)
      //     detect dupes
      //          same as detect double parents
      //     detect double parents
      //          if rel.child is not root node, error
      //          get all relationships that try to parent child
      //     detect loops
      //          assuming no double parents, only way to get loop is descendant gets parented to its root (e.g (p:F6, c:F1))
      //          if rel.child == root_node(rel.parent) error
      //          relationship with F1 as child, and relationship with F6 as child get flagged
      //     add relationship to tree

      // get B in A (A, B)   
      //    
      //                        F6 - ...
      //                      /
      //   * F1 - F2 - F3 - F5 - B - ...
      //            \
      //              F4 - A - ...
      //
      //   * F7 - F8
      //
      //     - root node (A) != root node(B)? return null
      //     - MRCA (A, B)? (can use root node to simplify code, less efficient)
      //     - Descendant in Ancestor tf(A, MRCA) -> A in F1
      //     - Descendant in Ancestor tf(A, MRCA) -> B in F1
      //     - return compose([A in F1, F1 in B])

      // display tree
      //      list root nodes
      //      recurse get children(node)

      // examples
      // var relationships = [ // valid tree
      //   ["F1", "F2", eye4()],
      //   ["F2", "F3", eye4()],
      //   ["F3", "F5", eye4()],
      //   ["F5", "B", eye4()],
      //   ["F2", "F4", eye4()],
      //   ["F4", "A", eye4()],
      //   ["F7", "F8", eye4()],
      // ]
      // var errors = [];
      // var tree = build_tree(relationships, errors);

        constructor(relationship_list, errors) {
          this.relationships = [];
          this.build_tree(relationship_list, errors);
        }

        build_tree(relationship_list, errors) {
          this.relationships = [];
          for (var i = 0; i < relationship_list.length; i++) {
            var parent = relationship_list[i].parent;
            var child = relationship_list[i].child;
            var tf = relationship_list[i].tf;
            var is_active = relationship_list[i].is_active;
            if (is_active) {
              this.add_relationship(parent, child, tf, errors, i, false);
            }
          }
        }

        add_relationship(parent, child, tf, errors, error_rel_index, is_inverse) {
            var is_inverse_text = "";
            if (is_inverse) {
              is_inverse_text = " inverse";
            }
            if (parent == child) {
              errors.push(new TreeBuildError(`can't add${is_inverse_text} relationship ${error_rel_index}, as it would create a self-parenting node`))
              return false;
            }
            //     detect double parents
            //          if rel.child is not root node, error
            //          get all relationships that try to parent child
            //     detect dupes
            //          same as detect double parents
            if (!this.is_root_node(child)) {
              if (!is_inverse) { // try adding inverse relationship
                var inverse_tf = new THREE.Matrix4();
                inverse_tf.copy(tf);
                inverse_tf.getInverse(tf);
                if (this.add_relationship(child, parent, inverse_tf, errors, error_rel_index, true)) {
                  return true;
                }
                return false;
              }
              // TODO get all relationships that try to parent child
              errors.push(new TreeBuildError(`can't add${is_inverse_text} relationship ${error_rel_index}, as it would create a double-parent node`))
              return false;
            }
            //     detect loops
            //          assuming no double parents, only way to get loop is descendant gets parented to its root (e.g (p:F6, c:F1))
            //          if rel.child == root_node(rel.parent) error
            //          relationship with F1 as child, and relationship with F6 as child get flagged
            if (child == this.get_root_node_of(parent)) {
              errors.push(new TreeBuildError(`can't add${is_inverse_text} relationship ${error_rel_index}, as it would create a loop`))
              return false;
            }
            //     add relationship to tree
            this.relationships.push(new TFRelationship(parent, child, tf));
            return true;
        }

      // API
      // get_unique_nodes() -> [node, node, ...]
      //        for each pair: Set().add(parent).add(child)
        get_unique_nodes() {
          var nodes = new Set();
          for (var i = 0; i < this.relationships.length; i++) {
            nodes.add(this.relationships[i].parent);
            nodes.add(this.relationships[i].child);
          }
          return nodes;
        }
      //    get_children_of(node) -> [node, node, ...]
      //        for each pair: if parent == node: set.add(child)
        get_children_of(node) {
          var nodes = new Set();
          for (var i = 0; i < this.relationships.length; i++) {
            if (this.relationships[i].parent == node) {
              nodes.add(this.relationships[i].child);
            }
          }
          return nodes;
        }
      //    get_parent_of(node) -> node
      //        for each pair: if child == node: return parent
        get_parent_of(node) {
          for (var i = 0; i < this.relationships.length; i++) {
            if (this.relationships[i].child == node) {
              return this.relationships[i].parent;
            }
          }
          return null;
        }
      //    get_parent_tf_of(node) -> Matrix4
      //        for each pair: if child == node: return tf
        get_parent_tf_of(node) {
          for (var i = 0; i < this.relationships.length; i++) {
            if (this.relationships[i].child == node) {
              return this.relationships[i].tf;
            }
          }
          return null;
        }
      //    get_root_node_of(node) -> node
      //          get parent(A) -> F4
      //          ...
      //          get parent(F1) -> None
      //          return F1
        get_root_node_of(node) {
          var current_node = node;
          var iter = 0;
          while (true) {
            var parent = this.get_parent_of(current_node);
            if (parent == null) {
              return current_node;
            }
            if (iter++ > 10000) {
              throw new Error("get_root_node_of() infinite loop");
            }
            current_node = parent;
          }
        }
      //    get_root_nodes() -> [node, node, ...]
      //        for each node in get unique nodes(): set.add(root node(node))
        get_root_nodes() {
          var nodes = new Set();
          var unique_nodes = this.get_unique_nodes();
          for (var node of unique_nodes) {
            nodes.add(this.get_root_node_of(node));
          }
          return nodes;
        }
      //    is_root_node(node) -> bool
      //        return get_parent(node) == None
        is_root_node(node) {
          return this.get_parent_of(node) == null;
        }
      //    get_descendant_in_ancestor_tf(ancestor, descendant):
      //          var tf_chain = []
      //          current_child = descendant
      //          while true:
      //          current_parent = get_parent(current_child)
      //          tf = get_parent_tf(current_child)
      //          tf_chain.push(tf)
      //          if current_parent == ancestor: break
      //          return compose(tf_chain)
        get_descendant_in_ancestor_tf(ancestor, descendant) {
          if (ancestor == descendant) {
            return eye4();
          }
          var tf_chain = [];
          var current_child = descendant;
          var iter = 0;
          
          if (descendant == "DEBUG") { console.log("Debug descendant in ancestor:"); }
          while (true) {
            var current_parent = this.get_parent_of(current_child);
            var tf = this.get_parent_tf_of(current_child);
            
            if (descendant == "DEBUG") {
              console.log(i, `${current_child} in ${current_parent}` + "\n" + mat4_to_log(tf));
            }
            tf_chain.push(tf);
            if (current_parent == ancestor) {
              break;
            }
            if (iter++ > 10000) {
              throw new Error("get_root_node_of() infinite loop");
            }
            current_child = current_parent;
          }
          
          if (descendant == "DEBUG") { console.log("---------- debug end descendant in ancestor ----------"); }
          // tf chain [descendant in p1, p1 in p2, ..., pn in ancestor]
          var descendant_in_ancestor_tf = new THREE.Matrix4();
          descendant_in_ancestor_tf.copy(tf_chain[tf_chain.length - 1]);
          for (var i = tf_chain.length - 2; i >= 0; i--) {
            descendant_in_ancestor_tf.multiply(tf_chain[i]);
          }
          return descendant_in_ancestor_tf;
        }

        get_B_in_A_tf(A, B) {
          //    root node (A) != root node(B)? return null
          //     - MRCA (A, B)? (can use root node to simplify code, less efficient)
          //     - Descendant in Ancestor tf(A, MRCA) -> A in F1
          //     - Descendant in Ancestor tf(A, MRCA) -> B in F1
          //     - return compose([A in F1, F1 in B])
          var root_node_A = this.get_root_node_of(A);
          var root_node_B = this.get_root_node_of(B);
          if (root_node_A != root_node_B) {
            return null;
          }
          if (A == B) {
            return eye4();
          }
          var MRCA = root_node_A;
          var A_in_MRCA_tf = this.get_descendant_in_ancestor_tf(MRCA, A);
          var B_in_MRCA_tf = this.get_descendant_in_ancestor_tf(MRCA, B);
          var MRCA_in_A_tf = new THREE.Matrix4();
          MRCA_in_A_tf.copy(A_in_MRCA_tf);
          MRCA_in_A_tf.getInverse(A_in_MRCA_tf);
          var B_in_A_tf = new THREE.Matrix4();
          B_in_A_tf.multiply(MRCA_in_A_tf);
          B_in_A_tf.multiply(B_in_MRCA_tf);
          if (A == "DEBUG" || B == "DEBUG") {
            console.log("Debug A_in_B:");
            console.log(`${A}_in_${MRCA}_tf` + "\n" + mat4_to_log(A_in_MRCA_tf));
            console.log(`${B}_in_${MRCA}_tf` + "\n" + mat4_to_log(B_in_MRCA_tf));
            console.log(`${MRCA}_in_${A}_tf` + "\n" + mat4_to_log(MRCA_in_A_tf));
            console.log(`${B}_in_${A}_tf` + "\n" + mat4_to_log(B_in_A_tf));
          }
          return B_in_A_tf;
        }

        as_html() {
          var html = "";
          var root_nodes = this.get_root_nodes();
          for (var root_node of root_nodes) {
            html += this.as_html_helper(root_node, 0, []);
          }
          return html;
        }

        as_html_helper(node, depth, is_last_at_depth) {
          var html = "";
          for (var i = 0; i < depth; i++) {
            var is_last = is_last_at_depth[i];
            var belonging_char = "?"
            if (!is_last && i == (depth - 1)) { belonging_char = "├"; }
            if (is_last && i == (depth - 1)) { belonging_char = "└"; }
            if (is_last && i != (depth - 1)) { belonging_char = ""; }
            if (!is_last && i != (depth - 1)) { belonging_char = "│"; }
            html += "&nbsp;&nbsp;" + belonging_char;
          }
          html += node + "<br>";
          var children = this.get_children_of(node);
          for (var child of children) {
            var is_last_child = child == Array.from(children).pop();
            // copy is_last_at_depth and add is_last_child at the end
            var is_child_last_at_depth = is_last_at_depth.slice();
            is_child_last_at_depth.push(is_last_child);
            html += this.as_html_helper(child, depth + 1, is_child_last_at_depth);
          }
          return html;
        }

      } // TFTree

      // transform values
      // [xx, yx, zx, x]
      // [xy, yy, zy, y]
      // [xz, yz, zz, z]
      // [ 0,  0,  0, 1]
      var param = 0.0;
      // var tx = 0.0;
      // var ty = 0.0;
      // var tz = 0.0;
      // var xx = 1.0;
      // var xy = 0.0;
      // var xz = 0.0;
      // var yx = 0.0;
      // var yy = 1.0;
      // var yz = 0.0;
      // var zx = 0.0;
      // var zy = 0.0;
      // var zz = 1.0;
      var transform_relationships = []; // [(parent_name, child_name, tf, is_active), ...]
      const MAX_TFS = 10;
      const MAX_AXS = MAX_TFS * 2;
      
      // Create the input HTML
      var tfinputshtml = '';
      for (var Ti = 0; Ti < MAX_TFS; Ti++) {
        var divhtml = `<div class="tfinput" id="T${Ti}">
            <div style="display: flex; justify-content: space-between;">
              <div><b><span id="T${Ti}title">T${Ti}</span></b></div>
              <div>
              <button type="button" onclick="eye(${Ti});">Reset to Identity</button>
              <button type="button" onclick="delete_transform(${Ti});">Delete</button>
              </div>
            </div>
            <input type="string" id="T${Ti}child" value="child ${Ti}" oninput="update(${Ti}, 7)">
            in
            <input type="string" id="T${Ti}parent" value="parent" oninput="update(${Ti}, 7)">
            <select id="T${Ti}imode" onchange="update_which_inputs_are_visible(${Ti})">
              <option value="quaternion" selected="">quaternion</option>
              <option value="euler">euler</option>
              <option value="matrix">matrix</option>
              <option value="axisangle">axis-angle</option>
              <option value="axismagnitude">axis-magnitude</option>
              <option value="ABB">ABB</option>
              <option value="compas">compas</option>
            </select>
            <p class="pi" id="T${Ti}ip6">Translation vector (xyz)
            <br><span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}t0" value="0" oninput="update(${Ti}, 6)">
            <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}t1" value="0" oninput="update(${Ti}, 6)">
            <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}t2" value="0" oninput="update(${Ti}, 6)">
            </p>
            <p class="pi" id="T${Ti}ip0">Rotation matrix
            <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m00" value="1" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m01" value="0" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m02" value="0" oninput="update(${Ti}, 0)"> &nbsp;
            <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m10" value="0" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m11" value="1" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m12" value="0" oninput="update(${Ti}, 0)"> &nbsp;
            <br><span class="dl"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m20" value="0" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m21" value="0" oninput="update(${Ti}, 0)">
            <span class="dl2"></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}m22" value="1" oninput="update(${Ti}, 0)">
            </p>
            <p class="pi" id="T${Ti}ip1">Quaternion (xyzw) 
            <br>
            <span class="dl">x</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}q0" value="0" oninput="update(${Ti}, 1)">
            <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}q1" value="0" oninput="update(${Ti}, 1)">
            <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}q2" value="0" oninput="update(${Ti}, 1)">
            <span class="dl">w</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}q3" value="1" oninput="update(${Ti}, 1)">
            </p>
            <p class="pi" id="T${Ti}ip2">Axis-angle (xyz, angle)<span class="angleunit" name="spananglei"> (radians)</span>
            <br>
            <span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}a0" value="0" oninput="update(${Ti}, 2)">
            <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}a1" value="0" oninput="update(${Ti}, 2)">
            <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}a2" value="0" oninput="update(${Ti}, 2)">
            <span class="dl">Angle<span class="angleunit" name="spananglei"> (radians)</span></span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}a3" value="0" oninput="update(${Ti}, 2)">
            </p>
            <p class="pi" id="T${Ti}ip3">Axis with angle magnitude<span class="angleunit" name="spananglei"> (radians)</span>
            <br><span class="dl">Axis x</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}r0" value="0" oninput="update(${Ti}, 3)">
            <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}r1" value="0" oninput="update(${Ti}, 3)">
            <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}r2" value="0" oninput="update(${Ti}, 3)">
            </p>
            <p class="pi" id="T${Ti}ip4">Euler angles of multiple axis rotations<span class="angleunit" name="spananglei"> (radians)</span>
            <br>
            <span class="sel"><select id="T${Ti}euler" onchange="update(${Ti}, 4)">
            <option value="XYZ" selected="">XYZ</option>
            <option value="XZY">XZY</option>
            <option value="YXZ">YXZ</option>
            <option value="YZX">YZX</option>
            <option value="ZXY">ZXY</option>
            <option value="ZYX">ZYX</option>
            </select></span>
            <span class="dl2">x</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}e0" value="0" oninput="update(${Ti}, 4)">
            <span class="dl2">y</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}e1" value="0" oninput="update(${Ti}, 4)">
            <span class="dl2">z</span><input type="number" pattern="\d+(\.\d*)?" id="T${Ti}e2" value="0" oninput="update(${Ti}, 4)">
            </p>
            <p class="pi" id="T${Ti}ip8">
            ABB<input type="string" style="width: 98%;" id="T${Ti}abb" value="[[423.818, 46.092, 210.4], [0, 0.6087614, 0.7933533, 0]]" oninput="update(${Ti}, 8)">
            </p>
            <p class="pi" id="T${Ti}ip9">
            Compas<input type="string" style="width: 98%;" id="T${Ti}compas" value="Frame((3500, 400, 1200), (1.000, 0.000, 0.000), (0.000, 1.000, 0.000))" oninput="update(${Ti}, 9)">
            </p>
          </div>
        </div>`;
        tfinputshtml += divhtml;
      }
      document.getElementById("TFInputs").innerHTML = tfinputshtml;

      function create_axes(scene, axes_list, AXL, AXT) {
        const quat1 = new THREE.Quaternion();
        quat1.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
        const quat2 = new THREE.Quaternion();
        quat2.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2);  
        var xyz_axes = [];
        const xaxismaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        var xaxiscylindergeom = new THREE.CylinderGeometry(AXL * AXT, AXL * AXT, AXL, 32 );
        xaxiscylindergeom.vertices.forEach((v) => {v.y += AXL / 2;});
        xaxiscylindergeom.vertices.forEach((v) => {v.applyQuaternion(quat2);});
        const xaxis = new THREE.Mesh(xaxiscylindergeom, xaxismaterial);
        xaxis.position.set(0, 0, 0);
        scene.add(xaxis);
        const yaxismaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
        var yaxiscylindergeom = new THREE.CylinderGeometry(AXL * AXT, AXL * AXT, AXL, 32 );
        yaxiscylindergeom.vertices.forEach((v) => {v.y += AXL / 2;});
        const yaxis = new THREE.Mesh(yaxiscylindergeom, yaxismaterial);
        yaxis.position.set(0, 0, 0);
        scene.add(yaxis);
        const zaxismaterial = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
        var zaxiscylindergeom = new THREE.CylinderGeometry(AXL * AXT, AXL * AXT, AXL, 32 );
        zaxiscylindergeom.vertices.forEach((v) => {v.y += AXL / 2;});
        zaxiscylindergeom.vertices.forEach((v) => {v.applyQuaternion(quat1);});
        const zaxis = new THREE.Mesh(zaxiscylindergeom, zaxismaterial);
        zaxis.position.set(0, 0, 0);
        scene.add(zaxis);
        xyz_axes.push(xaxis);
        xyz_axes.push(yaxis);
        xyz_axes.push(zaxis);
        axes_list.push(xyz_axes);
      }
      // Creates the origin axes instances
      var orig_axes = [];
      create_axes(scene, orig_axes, 1.0, 0.02);
      const origxaxis = orig_axes[0][0];
      const origyaxis = orig_axes[0][1];
      const origzaxis = orig_axes[0][2];
      // Creates the user axes instances
      var tf_axes = [];
      var axes_labels = [];
      var reference_frame = "parent";
      var visuals3d_need_update = false;
      for (var i = 0; i < MAX_AXS; i++) {
        create_axes(scene, tf_axes, 1.0, 0.02);
        axes_labels.push("");
      }
      for (var i = 0; i < MAX_TFS; i++) {
        var mat4 = new THREE.Matrix4();
        mat4.identity();
        var is_active = false
        transform_relationships.push(new TFRelationship("parent", "T" + i.toString(), mat4, is_active)); // initialize array to right size. update() will populate the fields.
      }
      var errors = [];
      var tf_tree = new TFTree(transform_relationships, errors);
      console.log(errors);

      // instantiate a loader
      const loader = new THREE.OBJLoader2();

      loader.load(
        'models/person.obj',
        (event) => {
          var newmaterial = new THREE.MeshBasicMaterial( { color: 0xcccccc } );
          const model = event.detail.loaderRootNode;
          model.rotation.x = Math.PI / 2;
          model.scale.set(0.01, 0.01, 0.01);
          model.position.sub(new THREE.Vector3(0.4, 0, 0));
          model.material = newmaterial;
          model.traverse(function(child){
            if (child.isMesh){
              child.material = newmaterial;
            }});
          model.name = "loaded";
          scene.add(model); 
        },
        function ( xhr ) {
          console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        },
        function ( error ) {
          console.log( 'An error happened' );
        }
      );

      


      if (false) {
        var relationships = [ // tree with loop
          new TFRelationship("F1", "F2", eye4()),
          new TFRelationship("F2", "F3", eye4()),
          new TFRelationship("F3", "F5", eye4()),
          new TFRelationship("F5", "B", eye4()),
          new TFRelationship("F5", "F6", eye4()),
          new TFRelationship("F2", "F4", eye4()),
          new TFRelationship("F4", "A", eye4()),
          new TFRelationship("F7", "F8", eye4()),
          new TFRelationship("F6", "F1", eye4()),
        ]
        var errors = [];
        var tree = new TFTree(relationships, errors);
        console.log(errors);
      }
      if (false) {
        var relationships = [ // valid tree
          new TFRelationship("F1", "F2", eye4()),
          new TFRelationship("F2", "F3", eye4()),
          new TFRelationship("F3", "F5", eye4()),
          new TFRelationship("F5", "B", eye4()),
          new TFRelationship("F5", "F6", eye4()),
          new TFRelationship("F2", "F4", eye4()),
          new TFRelationship("F4", "A", eye4()),
          new TFRelationship("F7", "F8", eye4()),
        ]
        var errors = [];
        var tree = new TFTree(relationships, errors);
        console.log(errors);
        console.log(tree.get_unique_nodes());
        console.log(tree.get_root_nodes());
        document.getElementById("test_tree_disp").innerHTML = tree.as_html();
        error_text = "";
        for (var error of errors) {
          error_text += error.message + "<br>";
        }
        document.getElementById("test_tree_errors").innerHTML = error_text;
      }

      function rebuild_tree() {
        var errors = [];
        tf_tree.build_tree(transform_relationships, errors);
        document.getElementById("tf_tree_disp").innerHTML = tf_tree.as_html();
        error_text = "";
        for (var error of errors) {
          error_text += error.message + "<br>";
        }
        document.getElementById("tf_tree_errors").innerHTML = error_text;
      }

      function parse_abb(to_parse) {
        // ABB style [[x_mm, y_mm, z_mm], [qw, qx, qy, qz]]
        var tx_ty_tz_qx_qy_qz_qw = null;
        // strip outer brackets
        function strip_brackets(string) {
          var output = "";
          // first, remove spaces around brackets
          output = string.replace(/\s*\[\s*/g, "[");
          output = output.replace(/\s*\]\s*/g, "]");
          output = output.replace(/^\[/, "");
          output = output.replace(/\]$/, "");
          return output;
        }
        to_parse = strip_brackets(to_parse);
        // split into two parts
        var parts = to_parse.split("],[");
        if (parts.length != 2) {
          console.log("ERROR: ABB style transform must have two parts");
          return tx_ty_tz_qx_qy_qz_qw;
        }
        // first part is translation
        var translation = strip_brackets(parts[0]);
        var translation_parts = translation.split(",");
        // second is wxyz
        var quaternion = strip_brackets(parts[1]);
        var quaternion_parts = quaternion.split(",");
        if (translation_parts.length != 3) {
          console.log("ERROR: ABB style translation must have three parts");
          return tx_ty_tz_qx_qy_qz_qw;
        }
        if (quaternion_parts.length != 4) {
          console.log("ERROR: ABB style quaternion must have four parts");
          return tx_ty_tz_qx_qy_qz_qw;
        }
        // convert string to decimal
        tx = parseFloat(translation_parts[0]) / 1000.0;
        ty = parseFloat(translation_parts[1]) / 1000.0;
        tz = parseFloat(translation_parts[2]) / 1000.0;
        // convert string to decimal
        qw = parseFloat(quaternion_parts[0]);
        qx = parseFloat(quaternion_parts[1]);
        qy = parseFloat(quaternion_parts[2]);
        qz = parseFloat(quaternion_parts[3]);
        return [tx, ty, tz, qx, qy, qz, qw];
      }

      function to_abb(tx, ty, tz, qx, qy, qz, qw) {
        return `[[${tx * 1000}, ${ty * 1000}, ${tz * 1000}], [${qw}, ${qx}, ${qy}, ${qz}]]`;
      }

      function parse_compas(to_parse) {
        // Compas style Frame((x, y, z), (xx, xy, xz), (yx, yy, yz))
        var tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz = null;
        to_parse = to_parse.replace("Frame", "");
        // strip outer brackets
        function strip_paren(string) {
          var output = "";
          // first, remove spaces around brackets
          output = string.replace(/\s*\(\s*/g, "(");
          output = output.replace(/\s*\)\s*/g, ")");
          output = output.replace(/^\(/, "");
          output = output.replace(/\)$/, "");
          return output;
        }
        to_parse = strip_paren(to_parse);
        // split into two parts
        var parts = to_parse.split("),(");
        if (parts.length != 3) {
          console.log("ERROR: compas style frame must have three parts");
          return tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz;
        }
        // first part is translation
        var translation = strip_paren(parts[0]);
        var translation_parts = translation.split(",");
        // second is x axis
        var xvec = strip_paren(parts[1]);
        var xvec_parts = xvec.split(",");
        // third is y axis
        var yvec = strip_paren(parts[2]);
        var yvec_parts = yvec.split(",");
        if (translation_parts.length != 3) {
          console.log("ERROR: compas style translation must have three parts");
          return tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz;
        }
        if (xvec_parts.length != 3) {
          console.log("ERROR: compas style x axis must have three parts");
          return tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz;
        }
        if (yvec_parts.length != 3) {
          console.log("ERROR: compas style y axis must have three parts");
          return tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz;
        }
        // convert string to decimal
        tx = parseFloat(translation_parts[0]);
        ty = parseFloat(translation_parts[1]);
        tz = parseFloat(translation_parts[2]);
        // convert string to decimal
        xx = parseFloat(xvec_parts[0]);
        xy = parseFloat(xvec_parts[1]);
        xz = parseFloat(xvec_parts[2]);
        // convert string to decimal
        yx = parseFloat(yvec_parts[0]);
        yy = parseFloat(yvec_parts[1]);
        yz = parseFloat(yvec_parts[2]);
        // z axis is x cross y
        zx = xy * yz - xz * yy;
        zy = xz * yx - xx * yz;
        zz = xx * yy - xy * yx;
        return [tx, ty, tz, xx, xy, xz, yx, yy, yz, zx, zy, zz];
      }

      function to_compas(tx, ty, tz, xx, xy, xz, yx, yy, yz) {
        return `Frame((${tx}, ${ty}, ${tz}), (${xx}, ${xy}, ${xz}), (${yx}, ${yy}, ${yz}))`;
      }

      function quaternion_to_mat4(qx, qy, qz, qw) {
        // rot matrix from quaternion
        // [1 - 2 * qy * qy - 2 * qz * qz,     2 * qx * qy - 2 * qz * qw,     2 * qx * qz + 2 * qy * qw, 0]
        // [    2 * qx * qy + 2 * qz * qw, 1 - 2 * qx * qx - 2 * qz * qz,     2 * qy * qz - 2 * qx * qw, 0]
        // [    2 * qx * qz - 2 * qy * qw,     2 * qy * qz + 2 * qx * qw, 1 - 2 * qx * qx - 2 * qy * qy, 0]
        // [0, 0, 0, 1]
        var xx_xy_xz_yx_yy_yz_zx_zy_zz = [
          1 - 2 * qy * qy - 2 * qz * qz,
          2 * qx * qy + 2 * qz * qw,
          2 * qx * qz - 2 * qy * qw,
          2 * qx * qy - 2 * qz * qw,
          1 - 2 * qx * qx - 2 * qz * qz,
          2 * qy * qz + 2 * qx * qw,
          2 * qx * qz + 2 * qy * qw,
          2 * qy * qz - 2 * qx * qw,
          1 - 2 * qx * qx - 2 * qy * qy
        ]
        return xx_xy_xz_yx_yy_yz_zx_zy_zz
      }

      function mat4_to_quat_xyzw(xx, xy, xz, yx, yy, yz, zx, zy, zz) {
        var tempw = 0.5 * Math.sqrt(1 + xx + yy + zz);
        var quat = new THREE.Quaternion();
        var mat4 = new THREE.Matrix4();
        mat4.set(xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0, 0, 0, 1);
        quat.setFromRotationMatrix(mat4);
        return quat;
      }

      function add_transform() {
        // find first inactive transform and make it active
        for (var i = 0; i < MAX_TFS; i++) {
          if (!transform_relationships[i].is_active) {
            transform_relationships[i].is_active = true;
            update(i, -1);
            break;
          }
        }
        update_which_transforms_are_visible();
      }

      function delete_transform(Ti) {
        transform_relationships[Ti].is_active = false;
        eye(Ti);
        update_which_transforms_are_visible();
      }

      function update_which_transforms_are_visible(){
        for (var i = 0; i < MAX_TFS; i++) {
          if (transform_relationships[i].is_active) {
            document.getElementById("T" + i.toString()).style.display = "block";
          } else {
            document.getElementById("T" + i.toString()).style.display = "none";
          }
        }
        update_ref_frame_dropdown();
      }

      function update_ref_frame() {
        reference_frame = document.getElementById("reference_frame_dropdown").value;
        visuals3d_need_update = true;
      }
      
      function update_ref_frame_dropdown() {
        // Update reference frame dropdown choices
        var frames = tf_tree.get_unique_nodes();
        var options_html = "";
        for (var frame of frames) {
          var is_selected = (frame == reference_frame);
          var selected_text = ""
          if (is_selected) {
            selected_text = ` selected=""`
          }
          options_html = options_html + `<option value="${frame}"${selected_text}>${frame}</option>`
        }
        document.getElementById("reference_frame_dropdown").innerHTML = options_html;
        update_ref_frame(); // ensure that the dropdown and variable match, even in edge cases (deleting selected)
      }

      function update_which_inputs_are_visible(Ti) {
        var imode = document.getElementById("T" + Ti.toString() + "imode").value;
        //          mat   quat  axis  axismag  euler  ---    trans ---    ABB    compas 
        var show = [true, false, false, false, false, false, true, false, false, false];
        if (imode == "quaternion") {
          show = [false, true, false, false, false, false, true, false, false, false];
        } else if (imode == "euler") {
          show = [false, false, false, false, true, false, true, false, false, false];
        } else if (imode == "matrix") {
          show = [true, false, false, false, false, false, true, false, false, false];
        } else if (imode == "axisangle") {
          show = [false, false, true, false, false, false, true, false, false, false];
        } else if (imode == "axismagnitude") {
          show = [false, false, false, true, false, false, true, false, false, false];
        } else if (imode == "ABB") {
          show = [false, false, false, false, false, false, false, false, true, false];
        } else if (imode == "compas") {
          show = [false, false, false, false, false, false, false, false, false, true];
        }

        for (var i = 0; i < show.length; i++) {
          var element = document.getElementById("T" + Ti.toString() + "ip" + i.toString());
          if (element != null) {
            if (show[i]) {
              element.style.display = "block";
            } else {
              element.style.display = "none";
            }
          }
        }
      }
      // Called when a field gets updated by the user. Argument is the index of the form element which has been updated\
      // converts the input into the universal format (matrix4), then back into every other field
      function update(Ti, ipidx) {
        var xx = transform_relationships[Ti].tf.elements[0];
        var xy = transform_relationships[Ti].tf.elements[1];
        var xz = transform_relationships[Ti].tf.elements[2];
        var yx = transform_relationships[Ti].tf.elements[4];
        var yy = transform_relationships[Ti].tf.elements[5];
        var yz = transform_relationships[Ti].tf.elements[6];
        var zx = transform_relationships[Ti].tf.elements[8];
        var zy = transform_relationships[Ti].tf.elements[9];
        var zz = transform_relationships[Ti].tf.elements[10];
        var tx = transform_relationships[Ti].tf.elements[12];
        var ty = transform_relationships[Ti].tf.elements[13];
        var tz = transform_relationships[Ti].tf.elements[14];

          // convert any input into Matrix4
          if (ipidx == 6) {
            var t0 = document.getElementById("T" + Ti.toString() + "t0").value * 1.0;
            var t1 = document.getElementById("T" + Ti.toString() + "t1").value * 1.0;
            var t2 = document.getElementById("T" + Ti.toString() + "t2").value * 1.0;
            tx = t0;
            ty = t1;
            tz = t2;
          }
          if (ipidx == 0) {
            xx = document.getElementById("T" + Ti.toString() + "m00").value * 1.0;
            yx = document.getElementById("T" + Ti.toString() + "m01").value * 1.0;
            zx = document.getElementById("T" + Ti.toString() + "m02").value * 1.0;
            xy = document.getElementById("T" + Ti.toString() + "m10").value * 1.0;
            yy = document.getElementById("T" + Ti.toString() + "m11").value * 1.0;
            zy = document.getElementById("T" + Ti.toString() + "m12").value * 1.0;
            xz = document.getElementById("T" + Ti.toString() + "m20").value * 1.0;
            yz = document.getElementById("T" + Ti.toString() + "m21").value * 1.0;
            zz = document.getElementById("T" + Ti.toString() + "m22").value * 1.0;

          }
          if (ipidx == 1) {
            var qx = document.getElementById("T" + Ti.toString() + "q0").value * 1.0;
            var qy = document.getElementById("T" + Ti.toString() + "q1").value * 1.0;
            var qz = document.getElementById("T" + Ti.toString() + "q2").value * 1.0;
            var qw = document.getElementById("T" + Ti.toString() + "q3").value * 1.0;
            var xx_xy_xz_yx_yy_yz_zx_zy_zz = quaternion_to_mat4(qx, qy, qz, qw);
            xx = xx_xy_xz_yx_yy_yz_zx_zy_zz[0];
            xy = xx_xy_xz_yx_yy_yz_zx_zy_zz[1];
            xz = xx_xy_xz_yx_yy_yz_zx_zy_zz[2];
            yx = xx_xy_xz_yx_yy_yz_zx_zy_zz[3];
            yy = xx_xy_xz_yx_yy_yz_zx_zy_zz[4];
            yz = xx_xy_xz_yx_yy_yz_zx_zy_zz[5];
            zx = xx_xy_xz_yx_yy_yz_zx_zy_zz[6];
            zy = xx_xy_xz_yx_yy_yz_zx_zy_zz[7];
            zz = xx_xy_xz_yx_yy_yz_zx_zy_zz[8];
          }
          if (ipidx == 2) {
            // Axis angle
            // ux, uy, uz = axis
            // transform_matrix = np.array(
            //     [
            //         [ux * ux * (1 - np.cos(angle)) + np.cos(angle), ux * uy * (1 - np.cos(angle)) - uz * np.sin(angle), ux * uz * (1 - np.cos(angle)) + uy * np.sin(angle), 0],
            //         [uy * ux * (1 - np.cos(angle)) + uz * np.sin(angle), uy * uy * (1 - np.cos(angle)) + np.cos(angle), uy * uz * (1 - np.cos(angle)) - ux * np.sin(angle), 0],
            //         [uz * ux * (1 - np.cos(angle)) - uy * np.sin(angle), uz * uy * (1 - np.cos(angle)) + ux * np.sin(angle), uz * uz * (1 - np.cos(angle)) + np.cos(angle), 0],
            //         [0, 0, 0, 1],
            //     ]
            // )
            var ux = document.getElementById("T" + Ti.toString() + "a0").value * 1.0;
            var uy = document.getElementById("T" + Ti.toString() + "a1").value * 1.0;
            var uz = document.getElementById("T" + Ti.toString() + "a2").value * 1.0;
            norm = Math.sqrt(ux * ux + uy * uy + uz * uz);
            if (norm > 0) {
              ux /= norm;
              uy /= norm;
              uz /= norm;
            }
            var angle = InputToRad(document.getElementById("T" + Ti.toString() + "a3").value * 1.0);
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            xx = ux * ux * (1 - cos) + cos;
            xy = uy * ux * (1 - cos) + uz * sin;
            xz = uz * ux * (1 - cos) - uy * sin;
            yx = ux * uy * (1 - cos) - uz * sin;
            yy = uy * uy * (1 - cos) + cos;
            yz = uz * uy * (1 - cos) + ux * sin;
            zx = ux * uz * (1 - cos) + uy * sin;
            zy = uy * uz * (1 - cos) - ux * sin;
            zz = uz * uz * (1 - cos) + cos;
          }
          if (ipidx == 3) {
            // Axis
            var ux = document.getElementById("T" + Ti.toString() + "r0").value * 1.0;
            var uy = document.getElementById("T" + Ti.toString() + "r1").value * 1.0;
            var uz = document.getElementById("T" + Ti.toString() + "r2").value * 1.0;
            norm = Math.sqrt(ux * ux + uy * uy + uz * uz);
            if (norm > 0) {
              ux /= norm;
              uy /= norm;
              uz /= norm;
            }
            var angle = InputToRad(norm);
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            xx = ux * ux * (1 - cos) + cos;
            xy = uy * ux * (1 - cos) + uz * sin;
            xz = uz * ux * (1 - cos) - uy * sin;
            yx = ux * uy * (1 - cos) - uz * sin;
            yy = uy * uy * (1 - cos) + cos;
            yz = uz * uy * (1 - cos) + ux * sin;
            zx = ux * uz * (1 - cos) + uy * sin;
            zy = uy * uz * (1 - cos) - ux * sin;
            zz = uz * uz * (1 - cos) + cos;
          }
          if (ipidx == 4) {
            e0 = InputToRad(document.getElementById("T" + Ti.toString() + "e0").value * 1.0);
            e1 = InputToRad(document.getElementById("T" + Ti.toString() + "e1").value * 1.0);
            e2 = InputToRad(document.getElementById("T" + Ti.toString() + "e2").value * 1.0);
            var order = document.getElementById("T" + Ti.toString() + "euler").value;
            var euler = new THREE.Euler( e0, e1, e2, order);
            var quat = new THREE.Quaternion();
            quat.setFromEuler(euler); // TODO: find a more precise implementation (e.g. wrong for 180 deg)
            var qx = quat.x;
            var qy = quat.y;
            var qz = quat.z;
            var qw = quat.w;
            var xx_xy_xz_yx_yy_yz_zx_zy_zz = quaternion_to_mat4(qx, qy, qz, qw);
            xx = xx_xy_xz_yx_yy_yz_zx_zy_zz[0];
            xy = xx_xy_xz_yx_yy_yz_zx_zy_zz[1];
            xz = xx_xy_xz_yx_yy_yz_zx_zy_zz[2];
            yx = xx_xy_xz_yx_yy_yz_zx_zy_zz[3];
            yy = xx_xy_xz_yx_yy_yz_zx_zy_zz[4];
            yz = xx_xy_xz_yx_yy_yz_zx_zy_zz[5];
            zx = xx_xy_xz_yx_yy_yz_zx_zy_zz[6];
            zy = xx_xy_xz_yx_yy_yz_zx_zy_zz[7];
            zz = xx_xy_xz_yx_yy_yz_zx_zy_zz[8];
          }
          if (ipidx == 7) { // parent / child names
            transform_relationships[Ti].parent = document.getElementById("T" + Ti.toString() + "parent").value;
            transform_relationships[Ti].child = document.getElementById("T" + Ti.toString() + "child").value;
            document.getElementById("T" + Ti.toString() + "title").innerHTML = transform_relationships[Ti].child + " in " + transform_relationships[Ti].parent;
            rebuild_tree();
            update_ref_frame_dropdown();
          }
          if (ipidx == 8) { // ABB style [[x_mm, y_mm, z_mm], [qw, qx, qy, qz]]
            var to_parse = document.getElementById("T" + Ti.toString() + "abb").value;
            tx_ty_tz_qx_qy_qz_qw = parse_abb(to_parse);
            if (tx_ty_tz_qx_qy_qz_qw != null) {
              tx = tx_ty_tz_qx_qy_qz_qw[0];
              ty = tx_ty_tz_qx_qy_qz_qw[1];
              tz = tx_ty_tz_qx_qy_qz_qw[2];
              qx = tx_ty_tz_qx_qy_qz_qw[3];
              qy = tx_ty_tz_qx_qy_qz_qw[4];
              qz = tx_ty_tz_qx_qy_qz_qw[5];
              qw = tx_ty_tz_qx_qy_qz_qw[6];
              var xx_xy_xz_yx_yy_yz_zx_zy_zz = quaternion_to_mat4(qx, qy, qz, qw);
              xx = xx_xy_xz_yx_yy_yz_zx_zy_zz[0];
              xy = xx_xy_xz_yx_yy_yz_zx_zy_zz[1];
              xz = xx_xy_xz_yx_yy_yz_zx_zy_zz[2];
              yx = xx_xy_xz_yx_yy_yz_zx_zy_zz[3];
              yy = xx_xy_xz_yx_yy_yz_zx_zy_zz[4];
              yz = xx_xy_xz_yx_yy_yz_zx_zy_zz[5];
              zx = xx_xy_xz_yx_yy_yz_zx_zy_zz[6];
              zy = xx_xy_xz_yx_yy_yz_zx_zy_zz[7];
              zz = xx_xy_xz_yx_yy_yz_zx_zy_zz[8];
            }
          }
          if (ipidx == 9) { // compas style
            var to_parse = document.getElementById("T" + Ti.toString() + "compas").value;
            tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz = parse_compas(to_parse);
            if (tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz != null) {
              tx = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[0];
              ty = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[1];
              tz = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[2];
              xx = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[3];
              xy = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[4];
              xz = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[5];
              yx = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[6];
              yy = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[7];
              yz = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[8];
              zx = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[9];
              zy = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[10];
              zz = tx_ty_tz_xx_xy_xz_yx_yy_yz_zx_zy_zz[11];
            }
          }

          // ASSIGN -------------------------
          transform_relationships[Ti].tf.set(xx, yx, zx, tx, xy, yy, zy, ty, xz, yz, zz, tz, 0, 0, 0, 1);
          visuals3d_need_update = true;

          rebuild_tree(); // necessary because inverse transforms are stored as copies in the tree

          // OUTPUT  -----------------------
          // Convert Matrix 4 into any output and update displays
          if (ipidx != 6)
          {
            document.getElementById("T" + Ti.toString() + "t0").value = tx;
            document.getElementById("T" + Ti.toString() + "t1").value = ty;
            document.getElementById("T" + Ti.toString() + "t2").value = tz;
          }
          if (ipidx != 0)
          {
            document.getElementById("T" + Ti.toString() + "m00").value = xx;
            document.getElementById("T" + Ti.toString() + "m01").value = yx;
            document.getElementById("T" + Ti.toString() + "m02").value = zx;
            document.getElementById("T" + Ti.toString() + "m10").value = xy;
            document.getElementById("T" + Ti.toString() + "m11").value = yy;
            document.getElementById("T" + Ti.toString() + "m12").value = zy;
            document.getElementById("T" + Ti.toString() + "m20").value = xz;
            document.getElementById("T" + Ti.toString() + "m21").value = yz;
            document.getElementById("T" + Ti.toString() + "m22").value = zz;
          }

          if (ipidx != 1) {
            // to quaternion
            var tempw = 0.5 * Math.sqrt(1 + xx + yy + zz);
            var quat = new THREE.Quaternion();
            var mat4 = new THREE.Matrix4();
            mat4.set(xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0, 0, 0, 1);
            quat.setFromRotationMatrix(mat4)
            // document.getElementById("T" + Ti.toString() + "q0").value = -(zy - yz) / (4 * tempw);
            // document.getElementById("T" + Ti.toString() + "q1").value = -(xz - zx) / (4 * tempw);
            // document.getElementById("T" + Ti.toString() + "q2").value = -(yx - xy) / (4 * tempw);
            // document.getElementById("T" + Ti.toString() + "q3").value = tempw;
            document.getElementById("T" + Ti.toString() + "q0").value = quat.x;
            document.getElementById("T" + Ti.toString() + "q1").value = quat.y;
            document.getElementById("T" + Ti.toString() + "q2").value = quat.z;
            document.getElementById("T" + Ti.toString() + "q3").value = quat.w;
          }

          if (ipidx != 2) {
            // 00 01 02  xx yx zx  
            // 10 11 12  xy yy zy
            // 20 21 22  xz yz zz
            // angle = acos(( m00 + m11 + m22 - 1)/2)
            // x = (m21 - m12)/√((m21 - m12)2+(m02 - m20)2+(m10 - m01)2)
            // y = (m02 - m20)/√((m21 - m12)2+(m02 - m20)2+(m10 - m01)2)
            // z = (m10 - m01)/√((m21 - m12)2+(m02 - m20)2+(m10 - m01)2)
            var angle = Math.acos((xx + yy + zz - 1) / 2);
            var ux = (yz - zy) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            var uy = (zx - xz) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            var uz = (xy - yx) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            document.getElementById("T" + Ti.toString() + "a3").value = InputFromRad(angle);
            document.getElementById("T" + Ti.toString() + "a0").value = ux;
            document.getElementById("T" + Ti.toString() + "a1").value = uy;
            document.getElementById("T" + Ti.toString() + "a2").value = uz;
          }

          if (ipidx != 3) {
            var angle = Math.acos((xx + yy + zz - 1) / 2);
            var ux = (yz - zy) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            var uy = (zx - xz) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            var uz = (xy - yx) / Math.sqrt((yz - zy) * (yz - zy) + (zx - xz) * (zx - xz) + (xy - yx) * (xy - yx));
            document.getElementById("T" + Ti.toString() + "r0").value = ux * angle;
            document.getElementById("T" + Ti.toString() + "r1").value = uy * angle;
            document.getElementById("T" + Ti.toString() + "r2").value = uz * angle;
          }

          if (ipidx != 4) {
            // to euler angles
            var euler = new THREE.Euler();
            var rotmat = new THREE.Matrix4();
            rotmat.set( 
              xx  ,yx  ,zx ,0
              ,xy  ,yy  ,zy ,0
              ,xz  ,yz  ,zz ,0
              ,0   ,0   ,0  ,1
            );
            var order = document.getElementById("T" + Ti.toString() + "euler").value;
            euler.setFromRotationMatrix(rotmat, order);
            document.getElementById("T" + Ti.toString() + "e0").value = InputFromRad(euler.x);
            document.getElementById("T" + Ti.toString() + "e1").value = InputFromRad(euler.y);
            document.getElementById("T" + Ti.toString() + "e2").value = InputFromRad(euler.z);
          }

          if (ipidx != 8) {
            // to quaternion
            var tempw = 0.5 * Math.sqrt(1 + xx + yy + zz);
            var quat = new THREE.Quaternion();
            var mat4 = new THREE.Matrix4();
            mat4.set(xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0, 0, 0, 1);
            quat.setFromRotationMatrix(mat4);
            // to abb notation
            var abb_text = to_abb(tx, ty, tz, quat.x, quat.y, quat.z, quat.w);
            document.getElementById("T" + Ti.toString() + "abb").value = abb_text;
          }
          
          if (ipidx != 9) {
            // to compas notation
            var compas_text = to_compas(tx, ty, tz, xx, xy, xz, yx, yy, yz);
            document.getElementById("T" + Ti.toString() + "compas").value = compas_text;
          }

          // set unit spans to either (radians) or (degrees)
          var spansi = document.getElementsByName('spananglei');
          for (var i = 0; i < spansi.length; i++)
          {
              if (document.getElementById('iformatrad').checked)
              {
                  spansi[i].textContent = ' (radians)';
              }
              else
              {
                  spansi[i].textContent = ' (degrees)';
              }
          }
      }

      function eye(Ti) {
        transform_relationships[Ti].tf.identity();

        update(Ti, -1); // update all input values
      }

      function InputToRad(x)
      {
          if (document.getElementById("iformatdeg").checked)
          {
              return x / 180 * Math.PI;
          }
          else
          {
              return x;
          }
      }

      function InputFromRad(x)
      {
          if (document.getElementById("iformatdeg").checked)
          {
              return x * 180 / Math.PI;
          }
          else
          {
              return x;
          }
      }

      // requestAnimationFrame makes this function run once for every frame.
      // keep this function small to avoid slowing down the page.
      // currently it updates the 3d geometry to match the stored frame data.
      function animate() {
        requestAnimationFrame( animate );
        var slider = document.getElementById("myRange");
        param = slider.value / 100.;
        for (var Ai = 0; Ai < MAX_AXS; Ai++) {
          var xaxis = tf_axes[Ai][0];
          var yaxis = tf_axes[Ai][1];
          var zaxis = tf_axes[Ai][2];
          xaxis.scale.set(param, param, param);
          yaxis.scale.set(param, param, param);
          zaxis.scale.set(param, param, param);
        }
        origxaxis.scale.set(param, param, param);
        origyaxis.scale.set(param, param, param);
        origzaxis.scale.set(param, param, param);

        // update text and visuals
        // Move axes
        if (visuals3d_need_update) {
          var frames = tf_tree.get_unique_nodes();
          var n_axes_shown = 0;
          var debug_frame_info = "";
          // for each frame
          for (var frame of frames) {
            Ai = n_axes_shown;
            var tf = tf_tree.get_B_in_A_tf(reference_frame, frame);
            axes_labels[Ai] = frame;
            // skip null
            if (tf == null) {
              tf = eye4(); // hide axes at 0
              axes_labels[Ai] = "";
            }
            var xaxis = tf_axes[Ai][0];
            var yaxis = tf_axes[Ai][1];
            var zaxis = tf_axes[Ai][2];
            var xx = tf.elements[0];
            var xy = tf.elements[1];
            var xz = tf.elements[2];
            var yx = tf.elements[4];
            var yy = tf.elements[5];
            var yz = tf.elements[6];
            var zx = tf.elements[8];
            var zy = tf.elements[9];
            var zz = tf.elements[10];
            var tx = tf.elements[12];
            var ty = tf.elements[13];
            var tz = tf.elements[14];
            if (frame != reference_frame) {
              var frameinfomode = document.getElementById("frameinfomode").value;
              var frameinfotext = "";
              if (frameinfomode == "quaternion") {
                var quat = mat4_to_quat_xyzw(xx, xy, xz, yx, yy, yz, zx, zy, zz);
                frameinfotext = `[${tx.toFixed(2)}, ${ty.toFixed(2)}, ${tz.toFixed(2)}], [${quat.x.toFixed(2)}, ${quat.y.toFixed(2)}, ${quat.z.toFixed(2)}, ${quat.w.toFixed(2)}]`;
              } else if (frameinfomode == "ABB") {
                var quat = mat4_to_quat_xyzw(xx, xy, xz, yx, yy, yz, zx, zy, zz);
                frameinfotext = `[[${(tx * 1000.).toFixed(2)}, ${(ty * 1000.).toFixed(2)}, ${(tz * 1000.).toFixed(2)}], [${quat.w.toFixed(2)}, ${quat.x.toFixed(2)}, ${quat.y.toFixed(2)}, ${quat.z.toFixed(2)}]]`;
              } else if (frameinfomode == "compas") {
                frameinfotext = `Frame((${tx}, ${ty}, ${tz}), (${xx}, ${xy}, ${xz}), (${yx}, ${yy}, ${yz}))`;
              } else {
                frameinfotext = `${tx}, ${ty}, ${tz}`;
              }
              debug_frame_info += `<p>${frame} in ${reference_frame}:<br>${frameinfotext}</p>`;
            }
            xaxis.position.set(tx, ty, tz);
            yaxis.position.set(tx, ty, tz);
            zaxis.position.set(tx, ty, tz);
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.set( 
              xx  ,yx  ,zx ,0
              ,xy  ,yy  ,zy ,0
              ,xz  ,yz  ,zz ,0
              ,0   ,0   ,0  ,1
            );
            xaxis.rotation.setFromRotationMatrix(rotationMatrix);
            yaxis.rotation.setFromRotationMatrix(rotationMatrix);
            zaxis.rotation.setFromRotationMatrix(rotationMatrix);
            n_axes_shown += 1;
          }
          document.getElementById("debug_frame_infos").innerHTML = debug_frame_info;
          for (var Ai = n_axes_shown; Ai < MAX_AXS; Ai++) {
            var xaxis = tf_axes[Ai][0];
            var yaxis = tf_axes[Ai][1];
            var zaxis = tf_axes[Ai][2];
            xaxis.position.set(0, 0, 0);
            yaxis.position.set(0, 0, 0);
            zaxis.position.set(0, 0, 0);
            xaxis.rotation.set(0, 0, 0);
            yaxis.rotation.set(0, 0, 0);
            zaxis.rotation.set(0, 0, 0);
            axes_labels[Ai] = "";
          }
          visuals3d_need_update = false;
        }
        // re-render canvas
        renderer.render( scene, activecamera );
        // re-render labels
        // get position of originaxes in window space
        var labelshtml = "";
        for (var Ai = 0; Ai < MAX_AXS; Ai++) {
          var xaxis = tf_axes[Ai][0];
          var yaxis = tf_axes[Ai][1];
          var zaxis = tf_axes[Ai][2];
          var label = axes_labels[Ai];
          var vector = new THREE.Vector3();
          vector.setFromMatrixPosition( xaxis.matrixWorld );
          vector.project( activecamera );
          var width = document.getElementById("canvaslabels").offsetWidth;
          var height = document.getElementById("canvaslabels").offsetHeight;
          var px = Math.round( (   vector.x ) * width  / 2 );
          var py = Math.round( ( - vector.y ) * height / 2 );
          if (px < -(width / 2.) || px > (width / 2.) || py < -(height / 2.) || py > (height / 2.)) {
            continue;
          }
          labelshtml = labelshtml + `<div class="label" style="color: rgb(144, 144, 144); position: absolute; top: 50%; left: 50%; user-select: none; transform: translate(${px}px, ${py}px); z-index: 5;" draggable="false">${label}</div>`
        }
        document.getElementById("canvaslabels").innerHTML = labelshtml;
      }
      // add two arbitrary transforms
      add_transform();
      add_transform();
      // initialize transforms in a cool pattern
      for (var Ti = 0; Ti < MAX_TFS; Ti++) {
        var angle = Ti * Math.PI / 3;
        var r = 2 + Ti / 2; 
        var x = r * Math.cos(angle);
        var y = r * Math.sin(angle);
        transform_relationships[Ti].tf.elements[12] = x;
        transform_relationships[Ti].tf.elements[13] = y;
        update(Ti, -1);
      }
      // update all visuals to match input states
      for (var Ti = 0; Ti < MAX_TFS; Ti++) {
        update(Ti, 6); // translation values in the form are saved on refresh. This applies them when loading the page.
        update(Ti, 0); // same for rot \
        update(Ti, 7); // same for names \
        update_which_inputs_are_visible(Ti); // same for input mode
      }
      window.addEventListener( 'resize', onWindowResize, false );
      function onWindowResize(){

          const CF = Math.max((window.innerWidth - 1000) / window.innerWidth, 0.50);
          camera.aspect = window.innerWidth * CF / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth * CF, window.innerHeight );

      }
      onWindowResize();
      toggleGrid();
      animate();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PP4068J99C"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PP4068J99C');
</script>
<!-- end of GA -->
<title>Transformations</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<style>
body,h1 {font-family: "Raleway", Arial, sans-serif}
h1 {letter-spacing: 6px}
.w3-row-padding img {margin-bottom: 12px}

p {
    font-size: 130%;
}

.content {
  padding: 0 18px;
  background-color: white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}

/* side by side flexbox */
.interactivecanvas {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1cm;
}

.interactivecontrols {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    margin-left: 1cm;
}

/* nice slider - single thin black line, minimalistic contour for the circle */

input[type="range"] {
  display: block;
  -webkit-appearance: none;
	-moz-appearance: none;
	background: rgb(94, 94, 94);
	border-radius: 5px;
  width: 100%;
  height: 2px;
  outline: 0;
  margin: 20px;
}


  /* buttons looking flat design */
  button {
    background-color: #fdeded;
    border: 1px solid #ff9898;
    border-radius: 10px;
    padding: 10px;
    margin: 3px;
  }

/* left and right border */
.matrixtable {
    border-left: 1px solid black;
    border-right: 1px solid black;
    margin-left:6px;
    margin-right:6px;
}

/* side by side, vertically centered for equation */
.matrixequation {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    font-size: 120%;
}
</style>
<body>

<!-- !PAGE CONTENT! -->
<div class="w3-content" style="max-width:1500px">

<!-- Header -->
<header class="w3-panel w3-center w3-opacity" style="padding:28px 16px">
  <h1 class="w3-xlarge">HOW DEEP IS THE MACHINE?</h1>
  <h1>The Artificial Curiosity Series</h1>

  <div class="w3-padding-32">
    <div class="w3-bar w3-border">
      <a href="../index.html" class="w3-bar-item w3-button">dugas.ch</a>
      <a href="../blog.html" class="w3-bar-item w3-button">/ Blog</a>
      <a href="../artificial_curiosity/" class="w3-bar-item w3-button">/ Artificial Curiosity</a>
      <a href="#" class="w3-bar-item w3-button w3-light-grey">/ Transformations</a>
    </div>
  </div>
</header>

<!-- Photo Grid -->
<div class="w3-row-padding" style="margin-bottom:128px;max-width:1000px">
  <h1>Transformations</h1>
  <p>
    In robotics geometrical transformations are an everyday thing.
    Cameras, robot positions, maps, very few components of robotics software donâ€™t include them in one way or another.<br>
    But while most of my students use them daily, few understand them intuitively.
  </p>
  <p>
    I made this as an attempt to make the concepts more visual and intuitive.
  </p>

    <ul>
        <li><a href="#sectionobjects">Objects</a></li>
        <li><a href="#section2d">2D Transformations</a></li>
        <li><a href="#section3d">3D Transformations</a></li>
        <li><a href="#sectionprojection">Projection</a></li>
        <li><a href="#sectionhomogeneous">Homogeneous Coordinates</a></li>
    </ul>

  <h2 id="sectionobjects">Objects</h2>
  

  Points, Coordinates
  <div class="interactivecanvas">
    <div id="canvasCA00"></div>
    <div class="interactivecontrols" id="controlsCA00">
        <input type="range" min="0" max="100" value="100" class="slider" id="s0_CA00">
        <input type="range" min="0" max="100" value="100" class="slider" id="s1_CA00">
        <input type="range" min="0" max="100" value="100" class="slider" id="s2_CA00">
    </div>
  </div>

  Vectors
  <div class="interactivecanvas">
    <div id="canvasCA01"></div>
    <div class="interactivecontrols" id="controlsCA01">
        <input type="range" min="0" max="100" value="100" class="slider" id="s0_CA01">
        <input type="range" min="0" max="100" value="100" class="slider" id="s1_CA01">
        <input type="range" min="0" max="100" value="100" class="slider" id="s2_CA01">
    </div>
  </div>

  Frames
  <div class="interactivecanvas">
    <div id="canvasCA02"></div>
    <div class="interactivecontrols" id="controlsCA02">
        <input type="range" min="0" max="100" value="100" class="slider" id="s0_CA02">
        <input type="range" min="0" max="100" value="100" class="slider" id="s1_CA02">
        <input type="range" min="0" max="100" value="100" class="slider" id="s2_CA02">
    </div>
  </div>

  <h2 id="section2d">2D Transformations</h2>

  <div class="interactivecanvas">
    <div class="interactivetext"><span id="t0_CA10">p' = Mp</span></div>
    <div class="interactivecontrols" id="controlsCA10">
        <div class="matrixequation">
          M = 
          <table class="matrixtable">
            <tr> <td id="m00_CA10">cos(0.0)</td> <td id="m01_CA10">-sin(0.0)</td> <td id="m02_CA10">0.0</td> </tr>
            <tr> <td id="m10_CA10">sin(0.0)</td> <td id="m11_CA10">cos(0.0)</td> <td id="m12_CA10">0.0</td> </tr>
            <tr> <td id="m20_CA10">0.0</td> <td id="m21_CA10">0.0</td> <td id="m22_CA10">0.0</td> </tr>
          </table> 
        </div>
        <p></p>
        
        translation
        <input type="range" min="0" max="100" value="0" class="slider" id="s0_CA10">
        <input type="range" min="0" max="100" value="0" class="slider" id="s1_CA10">
        rotation
        <input type="range" min="0" max="100" value="0" class="slider" id="s2_CA10">
    </div>
    <div id="canvasCA10"></div>
  </div>


  <h2 id="section3d">3D Transformations</h2>

  <div class="interactivecanvas">
    <div id="canvasCA20"></div>
    <div class="interactivecontrols" id="controlsCA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s0_CA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s1_CA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s2_CA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s3_CA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s4_CA20">
        <input type="range" min="0" max="100" value="0" class="slider" id="s5_CA20">
    </div>
    <div class="interactivetext"><span id="t0_CA20">M</span></div>
  </div>

  <h2>Mixing Dimensions</h2>
  <h2 id="sectionprojection">Projection</h2>
  see also <a href="https://ksimek.github.io/2013/08/13/intrinsic/">this link</a>
  <div class="interactivecanvas">
    <div id="canvasCA30"></div>
    <div id="canvasCA31"></div>
    <div class="interactivecontrols" id="controlsCA30">
        <input type="range" min="0" max="100" value="0" class="slider" id="s0_CA30">
        <input type="range" min="0" max="100" value="0" class="slider" id="s1_CA30">
        <input type="range" min="0" max="100" value="50" class="slider" id="s2_CA30">
        <input type="range" min="0" max="100" value="50" class="slider" id="s3_CA30">
        <input type="range" min="0" max="100" value="50" class="slider" id="s4_CA30">
        <button type="button" onclick="resetValuesCA30();">Reset</button>
    </div>
    <div class="interactivetext"><span id="t0_CA30">p' = Mp</span></div>
  </div>


  <h2 id="sectionperspective">Perspective</h2>
  <h2 id="sectionhomogeneous">Homogeneous Coordinates</h2>




</div>


<div>
 <hr style="margin:auto;width:80%;height:1px;border-width:0;color:gray;background-color:gray">
 <p style="margin-bottom:1cm;"> </p>

  <h3 style="text-align:center">Comments</h3>
  <p>
  This static site doesn't allow for comments, but maybe you'll find that the next best thing is this <a href="https://news.ycombinator.com/item?id=33942597#33942959">discussion on hacker news</a>?
  </p>
  <p><br></p>
</div>
  


<!-- End Page Content -->
</div>


<!-- Javascript -->
<script src="js/three.min.js"></script>
<script src="js/LoaderSupport.js"></script>
<script src="js/OBJLoader2.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/FileSaver.js"></script>
<script>
      
    // Pinhole camera class
    function makeNdcMatrix(
      left,
      right,
      bottom,
      top,
      near,
      far
    ) {
      const tx = -(right + left) / (right - left);
      const ty = -(top + bottom) / (top - bottom);
      const tz = -(far + near) / (far - near);

      const ndc = new THREE.Matrix4();
      // prettier-ignore
      ndc.set(
          2 / (right - left), 0, 0, tx,
          0, 2 / (top - bottom), 0, ty,
          0, 0, -2 / (far - near), tz,
          0, 0, 0, 1,
        );
      return ndc;
    }

    function makePerspectiveMatrix(
      s,
      alpha,
      beta,
      x0,
      y0,
      near,
      far
    ) {
      const A = near + far;
      const B = near * far;

      const perspective = new THREE.Matrix4();
      // prettier-ignore
      perspective.set(
          alpha, s, x0, 0,
          0, beta, y0, 0,
          0, 0, -A, B,
          0, 0, 1, 0,
        );
      return perspective;
    }

    class PinholeCamera extends THREE.PerspectiveCamera {
      K;
      imageWidth;
      imageHeight;

      constructor(
        K,
        imageWidth,
        imageHeight,
        aspect,
        near,
        far
      ) {
        super(45, aspect, near, far);

        this.K = K;
        this.imageWidth = imageWidth;
        this.imageHeight = imageHeight;
        this.updateProjectionMatrix();
      }

      updateProjectionMatrix() {
        if (!this.K) {
          return;
        }


        // column-major order
        const fx = this.K.elements[0 + 0 * 3];
        const fy = this.K.elements[1 + 1 * 3];
        const ox = this.K.elements[0 + 2 * 3];
        const oy = this.K.elements[1 + 2 * 3];
        const s = this.K.elements[0 + 1 * 3];

        const imageAspect = this.imageWidth / this.imageHeight;
        const relAspect = this.aspect / imageAspect;

        const relAspectFactorX = Math.max(1, relAspect);
        const relAspectFactorY = Math.max(1, 1 / relAspect);

        const relAspectOffsetX = ((1 - relAspectFactorX) / 2) * this.imageWidth;
        const relAspectOffsetY = ((1 - relAspectFactorY) / 2) * this.imageHeight;

        const left = relAspectOffsetX;
        const right = this.imageWidth - relAspectOffsetX;
        const top = relAspectOffsetY;
        const bottom = this.imageHeight - relAspectOffsetY;

        const persp = makePerspectiveMatrix(s, fx, fy, ox, oy, this.near, this.far);
        const ndc = makeNdcMatrix(left, right, bottom, top, this.near, this.far);
        // const projection = ndc.multiply(persp);
        const projection = persp;

        this.projectionMatrix.copy(projection);
        const inverseproj = new THREE.Matrix4();
        inverseproj.getInverse(projection);
        // debug
        console.log("projection matrix");
        console.log(projection);
        console.log("inverse projection matrix");
        console.log(inverseproj);
        this.projectionMatrixInverse.copy(inverseproj);
      }
    }

    // create RGB axes
    function createAxis(which, length) {
      const L = length;
      const T = 0.04;
      const color = new THREE.Color(0x0000ff);
      if (which == 0) { color.set(0xff0000); }
      if (which == 1) { color.set(0x00ff00); }
      if (which == 2) { color.set(0x0000ff); }
      const quat = new THREE.Quaternion();
      if (which == 0) { quat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2); }
      if (which == 1) { quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0); }
      if (which == 2) { quat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2); }
      const material = new THREE.MeshBasicMaterial( { color: color } );
      var geom = new THREE.CylinderGeometry(L * T, L * T, L, 32 );
      geom.vertices.forEach((v) => {v.y += L / 2;});
      geom.vertices.forEach((v) => {v.applyQuaternion(quat);});
      const axis = new THREE.Mesh(geom, material);
      axis.position.set(0, 0, 0);
      return axis;
    }
    const W = 400;
    const H = 400;
    const CA00 = true;
    const CA01 = true;
    const CA02 = true;
    const CA10 = true;
    const CA20 = true;
    const CA30 = true;
    const CA31 = true;
    // CA00 init
    // Points
    const WMCA00 = 6; // in meters, the width of the camera frustrum
    const HMCA00 = 6;
    const sceneCA00 = new THREE.Scene();
    const cameraCA00 = new THREE.OrthographicCamera( WMCA00 / - 2, WMCA00 / 2, HMCA00 / 2, HMCA00 / - 2, 0.1, 1000 );
    const rendererCA00 = new THREE.WebGLRenderer();
    rendererCA00.setSize( W, H);
    rendererCA00.setClearColor( 0xffffff );
    if (CA00) {
        document.getElementById("canvasCA00").appendChild( rendererCA00.domElement );
    }
    sceneCA00.add(new THREE.AmbientLight(0x404040))
    var lightCA00 = new THREE.PointLight( 0xffffff );
    lightCA00.position.set( 0, -1, 5 );
    sceneCA00.add(lightCA00);
    var gridCA00 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA00.rotation.x = Math.PI / 2;
    sceneCA00.add(gridCA00);
    const xs_CA00 = [1.0, 2.0, 1.0, 1.25, 1.50, 1.75, 2.0] // smiley
    const ys_CA00 = [2.0, 2.0, 1.0, 0.90, 0.85, 0.90, 1.0] // smiley
    var pointsCA00 = [];
    for (var i = 0; i < xs_CA00.length; i++) {
        var mat = new THREE.MeshBasicMaterial( { color: 0xcccccc } );
        var geom = new THREE.SphereGeometry(0.1, 32, 16 );
        var point = new THREE.Mesh(geom, mat);
        point.position.set(xs_CA00[i], ys_CA00[i], 0);
        sceneCA00.add(point);
        pointsCA00.push(point);
    }
    cameraCA00.position.z = 100;
    cameraCA00.up.set(0, 1, 0);
    const controlsCA00 = new THREE.OrbitControls(cameraCA00, rendererCA00.domElement);
    controlsCA00.target.set(0, 0, 0);
    controlsCA00.enableRotate = false;
    controlsCA00.screenSpacePanning = true;
    controlsCA00.update();
    function updateCA00() {
        rendererCA00.render( sceneCA00, cameraCA00 );
    }
    // CA01 init
    const WMCA01 = 6; // in meters, the width of the camera frustrum
    const HMCA01 = 6;
    const sceneCA01 = new THREE.Scene();
    const cameraCA01 = new THREE.OrthographicCamera( WMCA01 / - 2, WMCA01 / 2, HMCA01 / 2, HMCA01 / - 2, 0.1, 1000 );
    const rendererCA01 = new THREE.WebGLRenderer();
    rendererCA01.setSize( W, H);
    rendererCA01.setClearColor( 0xffffff );
    if (CA01) {
        document.getElementById("canvasCA01").appendChild( rendererCA01.domElement );
    }
    sceneCA01.add(new THREE.AmbientLight(0x404040))
    var lightCA01 = new THREE.PointLight( 0xffffff );
    lightCA01.position.set( 0, -1, 5 );
    sceneCA01.add(lightCA01);
    var gridCA01 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA01.rotation.x = Math.PI / 2;
    sceneCA01.add(gridCA01);
    cameraCA01.position.z = 100;
    cameraCA01.up.set(0, 1, 0);
    const controlsCA01 = new THREE.OrbitControls(cameraCA01, rendererCA01.domElement);
    controlsCA01.target.set(0, 0, 0);
    controlsCA01.enableRotate = false;
    controlsCA01.screenSpacePanning = true;
    controlsCA01.update();
    function updateCA01() {
        rendererCA01.render( sceneCA01, cameraCA01 );
    }
    const dirCA01 = new THREE.Vector3( 1, 0, 0 );
    const originCA01 = new THREE.Vector3( 0, 0, 0 );
    const lengthCA01 = 1;
    const hexCA01 = 0x000000;
    const arrowHelper_CA01 = new THREE.ArrowHelper( dirCA01, originCA01, lengthCA01, hexCA01 );
    sceneCA01.add( arrowHelper_CA01 );
    // CA02 init
    const WMCA02 = 6; // in meters, the width of the camera frustrum
    const HMCA02 = 6;
    const sceneCA02 = new THREE.Scene();
    const cameraCA02 = new THREE.OrthographicCamera( WMCA02 / - 2, WMCA02 / 2, HMCA02 / 2, HMCA02 / - 2, 0.1, 1000 );
    const rendererCA02 = new THREE.WebGLRenderer();
    rendererCA02.setSize( W, H);
    rendererCA02.setClearColor( 0xffffff );
    if (CA02) {
        document.getElementById("canvasCA02").appendChild( rendererCA02.domElement );
    }
    sceneCA02.add(new THREE.AmbientLight(0x404040))
    var lightCA02 = new THREE.PointLight( 0xffffff );
    lightCA02.position.set( 0, -1, 5 );
    sceneCA02.add(lightCA02);
    var gridCA02 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA02.rotation.x = Math.PI / 2;
    sceneCA02.add(gridCA02);
    const AXL_CA02 = 1.0;
    const AXT_CA02 = 0.04;
    const yaxismaterial_CA02 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    var yaxiscylindergeom_CA02 = new THREE.CylinderGeometry(AXL_CA02 * AXT_CA02, AXL_CA02 * AXT_CA02, AXL_CA02, 32 );
    yaxiscylindergeom_CA02.vertices.forEach((v) => {v.y += AXL_CA02 / 2;});
    const yaxis_CA02 = new THREE.Mesh(yaxiscylindergeom_CA02, yaxismaterial_CA02);
    yaxis_CA02.position.set(0, 0, 0);
    sceneCA02.add(yaxis_CA02);
    const quat_xaxisCA02 = new THREE.Quaternion();
    quat_xaxisCA02.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2);
    const xaxismaterial_CA02 = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    var xaxiscylindergeom_CA02 = new THREE.CylinderGeometry(AXL_CA02 * AXT_CA02, AXL_CA02 * AXT_CA02, AXL_CA02, 32 );
    xaxiscylindergeom_CA02.vertices.forEach((v) => {v.y += AXL_CA02 / 2;});
    xaxiscylindergeom_CA02.vertices.forEach((v) => {v.applyQuaternion(quat_xaxisCA02);});
    const xaxis_CA02 = new THREE.Mesh(xaxiscylindergeom_CA02, xaxismaterial_CA02);
    xaxis_CA02.position.set(0, 0, 0);
    sceneCA02.add(xaxis_CA02);
    cameraCA02.position.z = 100;
    cameraCA02.up.set(0, 1, 0);
    const controlsCA02 = new THREE.OrbitControls(cameraCA02, rendererCA02.domElement);
    controlsCA02.target.set(0, 0, 0);
    controlsCA02.enableRotate = false;
    controlsCA02.screenSpacePanning = true;
    controlsCA02.update();
    function updateCA02() {
        rendererCA02.render( sceneCA02, cameraCA02 );
    }
    // CA10 init
    // 2D transform of a point
    const WMCA10 = 6; // in meters, the width of the camera frustrum
    const HMCA10 = 6;
    const sceneCA10 = new THREE.Scene();
    const cameraCA10 = new THREE.OrthographicCamera( WMCA10 / - 2, WMCA10 / 2, HMCA10 / 2, HMCA10 / - 2, 0.1, 1000 );
    const rendererCA10 = new THREE.WebGLRenderer();
    rendererCA10.setSize( W, H);
    rendererCA10.setClearColor( 0xffffff );
    if (CA10) {
        document.getElementById("canvasCA10").appendChild( rendererCA10.domElement );
    }
    sceneCA10.add(new THREE.AmbientLight(0x404040))
    var lightCA10 = new THREE.PointLight( 0xffffff );
    lightCA10.position.set( 0, -1, 5 );
    sceneCA10.add(lightCA10);
    var gridCA10 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA10.rotation.x = Math.PI / 2;
    sceneCA10.add(gridCA10);
    cameraCA10.position.z = 100;
    cameraCA10.up.set(0, 1, 0);
    const controlsCA10 = new THREE.OrbitControls(cameraCA10, rendererCA10.domElement);
    controlsCA10.target.set(0, 0, 0);
    controlsCA10.enableRotate = false;
    controlsCA10.screenSpacePanning = true;
    controlsCA10.update();
    const AXL_CA10 = 1.0;
    const AXT_CA10 = 0.04;
    const yaxismaterial_CA10 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    var yaxiscylindergeom_CA10 = new THREE.CylinderGeometry(AXL_CA10 * AXT_CA10, AXL_CA10 * AXT_CA10, AXL_CA10, 32 );
    yaxiscylindergeom_CA10.vertices.forEach((v) => {v.y += AXL_CA10 / 2;});
    const yaxis_CA10 = new THREE.Mesh(yaxiscylindergeom_CA10, yaxismaterial_CA10);
    yaxis_CA10.position.set(0, 0, 0);
    sceneCA10.add(yaxis_CA10);
    const quat_xaxisCA10 = new THREE.Quaternion();
    quat_xaxisCA10.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2);
    const xaxismaterial_CA10 = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    var xaxiscylindergeom_CA10 = new THREE.CylinderGeometry(AXL_CA10 * AXT_CA10, AXL_CA10 * AXT_CA10, AXL_CA10, 32 );
    xaxiscylindergeom_CA10.vertices.forEach((v) => {v.y += AXL_CA10 / 2;});
    xaxiscylindergeom_CA10.vertices.forEach((v) => {v.applyQuaternion(quat_xaxisCA10);});
    const xaxis_CA10 = new THREE.Mesh(xaxiscylindergeom_CA10, xaxismaterial_CA10);
    xaxis_CA10.position.set(0, 0, 0);
    sceneCA10.add(xaxis_CA10);
    const x_CA10 = 2.0;
    const y_CA10 = 1.0;
    const poldmat_CA10 = new THREE.MeshBasicMaterial( { color: 0xcccccc } );
    var poldmatgeom_CA10 = new THREE.SphereGeometry(0.1, 32, 16);
    const pold_CA10 = new THREE.Mesh(poldmatgeom_CA10, poldmat_CA10);
    pold_CA10.position.set(x_CA10, y_CA10, 0);
    sceneCA10.add(pold_CA10);
    const pmat_CA10 = new THREE.MeshBasicMaterial( { color: 0xffcccc } );
    var pmatgeom_CA10 = new THREE.SphereGeometry(0.1, 32, 16);
    const p_CA10 = new THREE.Mesh(pmatgeom_CA10, pmat_CA10);
    p_CA10.position.set(x_CA10, y_CA10, 0);
    sceneCA10.add(p_CA10);
    function updateCA10() {
        // Get inputs
        var s0 = document.getElementById("s0_CA10").value / 100.0;
        var s1 = document.getElementById("s1_CA10").value / 100.0;
        var s2 = document.getElementById("s2_CA10").value / 100.0;
        var dx = s0 * 2.0;
        var dy = s1 * 2.0;
        var angle = s2 * Math.PI * 2.0;
        // new positions
        var x_CA10_new = x_CA10 * Math.cos(angle) - y_CA10 * Math.sin(angle) + dx;
        var y_CA10_new = x_CA10 * Math.sin(angle) + y_CA10 * Math.cos(angle) + dy;
        // Update scene
        p_CA10.position.set(x_CA10_new, y_CA10_new, 0);
        xaxis_CA10.position.set(dx, dy, 0);
        xaxis_CA10.rotation.z = angle;
        yaxis_CA10.position.set(dx, dy, 0);
        yaxis_CA10.rotation.z = angle;
        rendererCA10.render( sceneCA10, cameraCA10 );
        // Update text
        document.getElementById("m00_CA10").innerHTML = "cos(" + angle.toFixed(1) + ")";
        document.getElementById("m01_CA10").innerHTML = "-sin(" + angle.toFixed(1) + ")";
        document.getElementById("m02_CA10").innerHTML = dx.toFixed(1);
        document.getElementById("m10_CA10").innerHTML = "sin(" + angle.toFixed(1) + ")";
        document.getElementById("m11_CA10").innerHTML = "cos(" + angle.toFixed(1) + ")";
        document.getElementById("m12_CA10").innerHTML = dy.toFixed(1);
    }
    // CA20 init
    const sceneCA20 = new THREE.Scene();
    const cameraCA20 = new THREE.PerspectiveCamera( 75, W / H, 0.1, 1000 );
    const rendererCA20 = new THREE.WebGLRenderer();
    rendererCA20.setSize( W, H);
    rendererCA20.setClearColor( 0xffffff );
    if (CA20) {
        document.getElementById("canvasCA20").appendChild( rendererCA20.domElement );
    }
    sceneCA20.add(new THREE.AmbientLight(0x404040))
    var lightCA20 = new THREE.PointLight( 0xffffff );
    lightCA20.position.set( 0, -1, 5 );
    sceneCA20.add(lightCA20);
    var gridCA20 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA20.rotation.x = Math.PI / 2;
    sceneCA20.add(gridCA20);
    const xaxis_CA20 = createAxis(0, 1.0);
    sceneCA20.add(xaxis_CA20);
    const yaxis_CA20 = createAxis(1, 1.0);
    sceneCA20.add(yaxis_CA20);
    const zaxis_CA20 = createAxis(2, 1.0);
    sceneCA20.add(zaxis_CA20);
    const x_CA20 = 2.0;
    const y_CA20 = 1.0;
    const z_CA20 = 1.0;
    const poldmat_CA20 = new THREE.MeshBasicMaterial( { color: 0xcccccc } );
    var poldmatgeom_CA20 = new THREE.SphereGeometry(0.1, 32, 16);
    const pold_CA20 = new THREE.Mesh(poldmatgeom_CA20, poldmat_CA20);
    pold_CA20.position.set(x_CA20, y_CA20, z_CA20);
    sceneCA20.add(pold_CA20);
    const pmat_CA20 = new THREE.MeshBasicMaterial( { color: 0xffcccc } );
    var pmatgeom_CA20 = new THREE.SphereGeometry(0.1, 32, 16);
    const p_CA20 = new THREE.Mesh(pmatgeom_CA20, pmat_CA20);
    p_CA20.position.set(x_CA20, y_CA20, z_CA20);
    sceneCA20.add(p_CA20);
    cameraCA20.position.y = -5;
    cameraCA20.position.z = 3;
    cameraCA20.position.x = 3
    cameraCA20.up.set(0, 0, 1);
    const controlsCA20 = new THREE.OrbitControls(cameraCA20, rendererCA20.domElement);
    controlsCA20.target.set(0, 0, 0);
    controlsCA20.update();
    function updateCA20() {
        // Get inputs
        var s0 = document.getElementById("s0_CA20").value / 100.0;
        var s1 = document.getElementById("s1_CA20").value / 100.0;
        var s2 = document.getElementById("s2_CA20").value / 100.0;
        var s3 = document.getElementById("s3_CA20").value / 100.0;
        var s4 = document.getElementById("s4_CA20").value / 100.0;
        var s5 = document.getElementById("s5_CA20").value / 100.0;
        var dx = s0 * 2.0;
        var dy = s1 * 2.0;
        var dz = s2 * 2.0;
        var e0 = s3 * Math.PI * 2.0;
        var e1 = s4 * Math.PI * 2.0;
        var e2 = s5 * Math.PI * 2.0;
        var euler = new THREE.Euler( e0, e1, e2, "XYZ");
        var M = new THREE.Matrix4();
        M.makeRotationFromEuler(euler);
        M.setPosition(new THREE.Vector3(dx, dy, dz));
        // new positions
        var pos = new THREE.Vector3(x_CA20, y_CA20, z_CA20);
        var pos_new = pos.applyMatrix4(M);
        var x_CA20_new = pos_new.x;
        var y_CA20_new = pos_new.y;
        var z_CA20_new = pos_new.z;
        // Update scene
        p_CA20.position.set(x_CA20_new, y_CA20_new, z_CA20_new);
        xaxis_CA20.position.set(dx, dy, dz);
        xaxis_CA20.setRotationFromEuler(euler);
        yaxis_CA20.position.set(dx, dy, dz);
        yaxis_CA20.setRotationFromEuler(euler);
        zaxis_CA20.position.set(dx, dy, dz);
        zaxis_CA20.setRotationFromEuler(euler);
        rendererCA20.render( sceneCA20, cameraCA20 );
    }
    // CA30 init
    // https://segments.ai/blog/simulating-cameras-three-js  very helpful for custom camera
    const sceneCA30 = new THREE.Scene();
    const cameraCA30 = new THREE.PerspectiveCamera( 75, W / H, 0.1, 1000 );
    const rendererCA30 = new THREE.WebGLRenderer();
    rendererCA30.setSize( W, H);
    rendererCA30.setClearColor( 0xffffff );
    if (CA30) {
        document.getElementById("canvasCA30").appendChild( rendererCA30.domElement );
    }
    sceneCA30.add(new THREE.AmbientLight(0x404040))
    var lightCA30 = new THREE.PointLight( 0xffffff );
    lightCA30.position.set( 0, 3, 0 );
    sceneCA30.add(lightCA30);
    var gridCA30 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA30.rotation.x = Math.PI / 2;
    sceneCA30.add(gridCA30);
    const xaxis_CA30 = createAxis(0, 1.0);
    sceneCA30.add(xaxis_CA30);
    const yaxis_CA30 = createAxis(1, 1.0);
    sceneCA30.add(yaxis_CA30);
    const zaxis_CA30 = createAxis(2, 1.0);
    sceneCA30.add(zaxis_CA30);
    function createFrustrum(fx, fy, u0, v0, gamma) {
      const near = 1.0;
      const far = 10.0;
      const wx = 1.0/fx;
      const wy = 1.0/fy;
      const points = [];
      for (var i = 0; i < 4; i++) {
        const ds = [0, 1, 1, 0, 2, 2, 0];
        const xs = [[0, -1,  1, 0, -1,  1, 0],
                    [0,  1,  1, 0,  1,  1, 0],
                    [0, -1,  1, 0, -1,  1, 0],
                    [0, -1, -1, 0, -1, -1, 0]];
        const ys = [[0, -1, -1, 0, -1, -1, 0],
                    [0, -1,  1, 0, -1,  1, 0],
                    [0,  1,  1, 0,  1,  1, 0],
                    [0,  1, -1, 0,  1, -1, 0]];
        for (var j = 0; j < 8; j++) {
          var d = 0;
          if (ds[j] == 1) {d = near;} else if (ds[j] == 2) {d = far;}
          var y = wy * ys[i][j] * d + v0 * d;
          var x = wx * xs[i][j] * d + u0 * d + gamma * y;
          var z = d;
          points.push( new THREE.Vector3( x, y, z ) );
        }
      }

      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      return geometry
    }
    const lineCA30 = new THREE.Line( createFrustrum(1.0, 0.5), new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    sceneCA30.add( lineCA30 );
    const ballmatCA30 = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
    const ballCA30 = new THREE.Mesh( new THREE.SphereGeometry( 1.0, 32, 32 ), ballmatCA30);
    ballCA30.position.z = 3.0;
    sceneCA30.add( ballCA30 );
    cameraCA30.position.y = -5;
    cameraCA30.position.z = 3;
    cameraCA30.position.x = 3
    cameraCA30.up.set(0, 0, 1);
    const controlsCA30 = new THREE.OrbitControls(cameraCA30, rendererCA30.domElement);
    controlsCA30.target.set(0, 0, 0);
    controlsCA30.update();
    function resetValuesCA30() {
        document.getElementById("s0_CA30").value = 50;
        document.getElementById("s1_CA30").value = 50;
        document.getElementById("s2_CA30").value = 50;
        document.getElementById("s3_CA30").value = 50;
        document.getElementById("s4_CA30").value = 50;
    }
    function updateCA30() {
        // inputs
        var fx = parseFloat(document.getElementById("s0_CA30").value) / 100.0 * 3.0 + 0.5;
        var fy = parseFloat(document.getElementById("s1_CA30").value) / 100.0 * 3.0 + 0.5;
        var u0 = parseFloat(document.getElementById("s2_CA30").value) / 100.0 * 2.0 - 1.0;
        var v0 = parseFloat(document.getElementById("s3_CA30").value) / 100.0 * 2.0 - 1.0;
        var gamma = parseFloat(document.getElementById("s4_CA30").value) / 100.0 * 2.0 - 1.0;
        lineCA30.geometry.dispose();
        lineCA30.geometry = createFrustrum(fx, fy, u0, v0, gamma);
        rendererCA30.render( sceneCA30, cameraCA30 );
    }
    // CA31 init
    // https://segments.ai/blog/simulating-cameras-three-js  very helpful for custom camera
    const sceneCA31 = new THREE.Scene();
    const matrixKCA31 = new THREE.Matrix3();
    matrixKCA31.set(1.0, 0.0, 0.0,
                     0.0, 1.0, 0.0,
                     0.0, 0.0, 1.0);
    // debug
    const tempcamCA31 = new THREE.PerspectiveCamera( 45, W / H, 0.1, 1000 );
    console.log("proper projection matrix");
    console.log(tempcamCA31.projectionMatrix);
    console.log("proper inverse projection matrix");
    console.log(tempcamCA31.projectionMatrixInverse);
    const pcameraCA31 = new PinholeCamera(matrixKCA31, W, H, W / H, 0.1, 1000);
    const cameraCA31 = tempcamCA31;
    const rendererCA31 = new THREE.WebGLRenderer();
    rendererCA31.setSize( W, H);
    rendererCA31.setClearColor( 0xffffff );
    if (CA31) {
        document.getElementById("canvasCA31").appendChild( rendererCA31.domElement );
    }
    sceneCA31.add(new THREE.AmbientLight(0x404040))
    var lightCA31 = new THREE.PointLight( 0xffffff );
    lightCA31.position.set( 0, 3, 0 );
    sceneCA31.add(lightCA31);
    const ballmatCA31 = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
    const ballCA31 = new THREE.Mesh( new THREE.SphereGeometry( 1.0, 32, 32 ), ballmatCA31);
    ballCA31.position.z = 3.0;
    sceneCA31.add( ballCA31 );
    var gridCA31 = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
    gridCA31.rotation.x = Math.PI / 2;
    sceneCA31.add(gridCA31);
    cameraCA31.position.y = 0;
    cameraCA31.position.z = -1;
    cameraCA31.position.x = 0;
    cameraCA31.up.set(0, 1, 0);
    cameraCA31.lookAt(0, 0, 1);
    const controlsCA31 = new THREE.OrbitControls(cameraCA31, rendererCA31.domElement);
    controlsCA31.target.set(0, 0, 0);
    controlsCA31.update();
    controlsCA31.enableRotate = false;
    controlsCA31.enablePan = false;
    function updateCA31() {
        // inputs
        var fx = parseFloat(document.getElementById("s0_CA30").value) / 100.0 * 3.0 + 0.5;
        var fy = parseFloat(document.getElementById("s1_CA30").value) / 100.0 * 3.0 + 0.5;
        var u0 = parseFloat(document.getElementById("s2_CA30").value) / 100.0 * 2.0 - 1.0;
        var v0 = parseFloat(document.getElementById("s3_CA30").value) / 100.0 * 2.0 - 1.0;
        var gamma = parseFloat(document.getElementById("s4_CA30").value) / 100.0 * 2.0 - 1.0;
        // cameraCA31.projectionMatrixInverse.elements[0] = 1.0 / fx;
        // cameraCA31.projectionMatrixInverse.elements[5] = 1.0 / fy;
        // cameraCA31.projectionMatrixInverse.elements[1] = gamma;
        // cameraCA31.projectionMatrixInverse.elements[2] = u0;
        // cameraCA31.projectionMatrixInverse.elements[6] = v0;
        // cameraCA31.projectionMatrixInverse.copy(new THREE.Matrix4().getInverse(cameraCA31.projectionMatrixInverse));
        cameraCA31.projectionMatrix.elements[0] = fx;
        cameraCA31.projectionMatrix.elements[5] = fy;
        cameraCA31.projectionMatrix.elements[1] = gamma;
        cameraCA31.projectionMatrix.elements[8] = -u0 * fx;
        cameraCA31.projectionMatrix.elements[9] = -v0 * fy;
        cameraCA31.position.z = 0.0;
        rendererCA31.render( sceneCA31, cameraCA31 );
    }

    // requestAnimationFrame makes this function run once for every frame.
    // keep this function small to avoid slowing down the page.
    // currently it updates the 3d geometry to match the stored frame data.
    function animate() {
        requestAnimationFrame( animate );

        // re-render canvas
        if (CA00) { updateCA00(); }
        if (CA00) { updateCA01(); }
        if (CA00) { updateCA02(); }
        if (CA10) { updateCA10(); }
        if (CA20) { updateCA20(); }
        if (CA30) { updateCA30(); }
        if (CA31) { updateCA31(); }
    }
    animate();
</script>

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    }
  });
}
</script>

<!-- Footer -->
<footer class="w3-container w3-padding-64 w3-light-grey w3-center w3-large">
  <!-- Font awesome logos: fa fa-something-something -->
  <i class="fab fa-pied-piper-alt w3-hover-opacity"></i>
  <p style="font-size:100%;">Powered by <a  id="powered_by_link" href="http://beesbeesbees.com/" target="_blank" class="w3-hover-text-green">bees</a></p>

  <script>
  var powerSources = [
    "bees",
    "eels",
    "koalas",
    "circuits",
    "logic",
    "a chihuaha",
    "infinite zoom",
    ];
  var powerLinks = [
    "http://beesbeesbees.com/",
    "http://eelslap.com",
    "http://koalastothemax.com",
    "http://electricboogiewoogie.com",
    "http://www.visual6502.org/JSSim/index.html",
    "http://chihuahuaspin.com/",
    "http://zoomquilt.org/",
    ];
  var randomIndex = Math.floor(Math.random()*powerSources.length);
  document.getElementById("powered_by_link").href = powerLinks[randomIndex];
  document.getElementById("powered_by_link").innerHTML = powerSources[randomIndex];
  </script>
</footer>

</body>
</html>

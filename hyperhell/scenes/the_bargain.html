<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Bargain</title>
<style>
body {
  margin: 0;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}
canvas {
  border: 2px solid #444;
  background: #000;
  max-width: 100%;
}
.controls {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  align-items: center;
}
.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
label {
  font-size: 12px;
  color: #aaa;
}
input[type="range"] {
  width: 150px;
}
.info {
  font-size: 14px;
  color: #888;
  text-align: center;
}
.help {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  font-size: 12px;
  color: #ccc;
  max-width: 300px;
}
</style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<div class="help">
    <div id="help-controls" style="color:rgb(156, 156, 156);">
    WASD: Move hypercamera forwards, sideways<br>
    Q/E: Move hypercamera in ana, kata directions<br>
    IJKL: Rotate hypercamera up/down, left/right<br>
    U/O: Rotate hypercamera in wx plane<br>
    Y/P: Rotate hypercamera in wy plane<br>
    Mouse drag: Rotate sensor view<br>
    Mouse wheel: Zoom<br>
    </div>
    <br>
</div>
<script type="module">

import { Transform4D, Vector4D } from '../../4d_creatures/hyperengine/transform4d.js';
import { createHypercube } from '../../4d_creatures/hyperengine/hyperobject.js';
import { TheBargainManager } from '../game_manager/the_bargain_manager.js';
import { runHyperengine } from '../../4d_creatures/hyperengine/hyperengine.js';
import { createHyperwall, createHyperwallWithCenterHole, createSphericalWallWithHole, createSphericalBridge, createObstacleCube  } from '../models/wall.js';
import { createCorridorTube, createCorridorTubeWithHole } from '../models/corridor.js';
import { createHypersphere } from '../../4d_creatures/models/hypersphere.js';
import { createHypercrab } from '../../4d_creatures/models/hypercrab.js';
import { createBargainer } from '../models/bargainer.js';
import { createGem } from '../models/gem.js';

let objects = [];

const APPLY_TEXTURES = true;

// Procedural brick wall texture generator
function generateBrickWallTexture() {
    const USIZE = 128; // horizontal (maps to wall y)
    const VSIZE = 96;  // vertical (maps to wall z / height)
    const WSIZE = 128; // 4th dim (maps to wall w)

    const texture = new Uint32Array(USIZE * VSIZE * WSIZE);

    // Hash function for per-texel noise
    function hash(x, y, z) {
        let h = ((x * 374761393 + y * 668265263 + z * 1274126177) | 0);
        h = ((h ^ (h >> 13)) * 1103515245 + 12345) | 0;
        return (h & 0x7fffffff) / 0x7fffffff; // [0, 1]
    }

    // Dark grey brick base colors
    const brickBases = [
        [55, 55, 55],
        [48, 50, 52],
        [62, 58, 56],
        [42, 44, 48],
        [52, 48, 53],
        [60, 56, 52],
        [45, 49, 50],
        [58, 54, 50],
        [50, 52, 56],
    ];
    const mortarBase = [5, 5, 5]; // near-black mortar

    // Brick dimensions in texels
    const brickH = 10;  // brick height in v
    const mortarH = 3;  // mortar thickness in v
    const brickW = 28;  // brick width in u
    const mortarW = 3;  // mortar thickness in u
    const brickD = 28;  // brick depth in w
    const mortarD = 3;  // mortar thickness in w
    const rowPeriodV = brickH + mortarH; // 13
    const colPeriodU = brickW + mortarW; // 31
    const colPeriodW = brickD + mortarD; // 31

    // Per-brick color hash
    function brickColorIdx(a, b, c) {
        return Math.abs(((a * 73 + b * 157 + c * 37) * 2654435761) | 0) % brickBases.length;
    }

    for (let w = 0; w < WSIZE; w++) {
        for (let v = 0; v < VSIZE; v++) {
            for (let u = 0; u < USIZE; u++) {
                let index = u + v * USIZE + w * USIZE * VSIZE;

                // Horizontal mortar
                let rowInCycle = v % rowPeriodV;
                let isHMortar = rowInCycle >= brickH;
                let rowIdx = Math.floor(v / rowPeriodV);

                // U-direction mortar
                let uOffset = (rowIdx % 2 === 0) ? 0 : Math.floor(colPeriodU / 2);
                let colInCycleU = (u + uOffset) % colPeriodU;
                let isUMortar = colInCycleU >= brickW;

                // W-direction mortar
                let wOffset = (rowIdx % 2 === 0) ? 0 : Math.floor(colPeriodW / 2);
                let colInCycleW = (w + wOffset) % colPeriodW;
                let isWMortar = colInCycleW >= brickD;

                let r, g, b;
                let isMortar = isHMortar || isUMortar || isWMortar;

                if (isMortar) {
                    // Mortar with slight noise
                    let n = hash(u, v, w) * 8 - 4;
                    r = Math.max(0, Math.min(255, mortarBase[0] + n));
                    g = Math.max(0, Math.min(255, mortarBase[1] + n));
                    b = Math.max(0, Math.min(255, mortarBase[2] + n));
                } else {
                    // Per-brick base color
                    let brickU = Math.floor((u + uOffset) / colPeriodU);
                    let brickWi = Math.floor((w + wOffset) / colPeriodW);
                    let ci = brickColorIdx(rowIdx, brickU, brickWi);
                    let base = brickBases[ci];

                    // Per-brick tint shift (consistent within a brick)
                    let brickSeed = hash(brickU * 7 + 31, rowIdx * 13 + 53, brickWi * 19 + 71);
                    let tintShift = (brickSeed - 0.5) * 16;

                    // Per-texel noise for surface grain
                    let grain = (hash(u, v, w) - 0.5) * 20;

                    // Subtle edge darkening near mortar lines
                    let distToHMortar = Math.min(rowInCycle, brickH - 1 - rowInCycle);
                    let distToUMortar = Math.min(colInCycleU, brickW - 1 - colInCycleU);
                    let distToWMortar = Math.min(colInCycleW, brickD - 1 - colInCycleW);
                    let edgeDist = Math.min(distToHMortar, distToUMortar, distToWMortar);
                    let edgeDarken = edgeDist <= 1 ? -10 : 0;

                    // Occasional darker splotch (stain)
                    let stain = hash(u ^ 0x55, v ^ 0xAA, w ^ 0x33);
                    let stainDarken = stain < 0.08 ? -15 : 0;

                    r = Math.max(0, Math.min(255, base[0] + tintShift + grain + edgeDarken + stainDarken));
                    g = Math.max(0, Math.min(255, base[1] + tintShift + grain + edgeDarken + stainDarken));
                    b = Math.max(0, Math.min(255, base[2] + tintShift + grain + edgeDarken + stainDarken));
                }

                let rgba_u32 = (255 << 24) | (b << 16) | (g << 8) | r;
                texture[index] = rgba_u32;
            }
        }
    }

    return { texture, texture_info: { USIZE, VSIZE, WSIZE } };
}

// Dark texture with red glowing eye pairs at semi-random positions
function generateDarkEyesTexture() {
    const USIZE = 128;
    const VSIZE = 96;
    const WSIZE = 128;
    const texture = new Uint32Array(USIZE * VSIZE * WSIZE);

    function hash(x, y, z) {
        let h = ((x * 374761393 + y * 668265263 + z * 1274126177) | 0);
        h = ((h ^ (h >> 13)) * 1103515245 + 12345) | 0;
        return (h & 0x7fffffff) / 0x7fffffff;
    }

    // Generate eye pair positions using hash for semi-random placement
    const eyePairs = [];
    const numPairs = 16;
    for (let i = 0; i < numPairs; i++) {
        const cu = 14 + hash(i * 7 + 3, 1, 0) * (USIZE - 28);
        const cv = 14 + hash(2, i * 13 + 7, 0) * (VSIZE - 28);
        const cw = hash(0, 3, i * 19 + 11) * WSIZE;
        const spacing = 4 + hash(i * 3, i * 5, i * 7) * 3; // 4-7 texels between eyes
        const eyeRadU = 2.5 + hash(i * 11, i * 17, 4) * 1.5; // U radius: 2.5-4
        const eyeRadV = eyeRadU * 2.5; // aspect correction so eyes look round on wall
        const eyeRadW = 15 + hash(i * 23, 5, i * 29) * 20;  // large W extent: 15-35

        eyePairs.push({
            u1: cu - spacing, u2: cu + spacing,
            v: cv, w: cw,
            radU: eyeRadU, radV: eyeRadV, radW: eyeRadW
        });
    }

    for (let w = 0; w < WSIZE; w++) {
        for (let v = 0; v < VSIZE; v++) {
            for (let u = 0; u < USIZE; u++) {
                const index = u + v * USIZE + w * USIZE * VSIZE;

                // Near-black base with subtle noise
                const n = hash(u, v, w);
                const base = 3 + n * 9;
                let r = base, g = base, b = base;

                // Check proximity to any eye
                let maxGlow = 0;
                for (const pair of eyePairs) {
                    for (const eu of [pair.u1, pair.u2]) {
                        const du = (u - eu) / pair.radU;
                        const dv = (v - pair.v) / pair.radV;
                        // W wraps around for seamless tiling
                        let dw_raw = Math.abs(w - pair.w);
                        if (dw_raw > WSIZE / 2) dw_raw = WSIZE - dw_raw;
                        const dw = dw_raw / pair.radW;

                        const dist2 = du * du + dv * dv + dw * dw;
                        if (dist2 < 1.0) {
                            const intensity = 1.0 - Math.sqrt(dist2);
                            const glow = intensity * intensity;
                            maxGlow = Math.max(maxGlow, glow);
                        }
                    }
                }

                if (maxGlow > 0) {
                    r = Math.max(r, 40 + maxGlow * 215);
                    g = Math.min(g, 3 + maxGlow * 10);
                    b = Math.min(b, 2);
                }

                r = Math.max(0, Math.min(255, Math.round(r)));
                g = Math.max(0, Math.min(255, Math.round(g)));
                b = Math.max(0, Math.min(255, Math.round(b)));

                texture[index] = (255 << 24) | (b << 16) | (g << 8) | r;
            }
        }
    }

    return { texture, texture_info: { USIZE, VSIZE, WSIZE } };
}

// Starry sky texture - mostly black with white and slightly colored dots
function generateStarryTexture() {
    const USIZE = 128;
    const VSIZE = 96;
    const WSIZE = 128;
    const texture = new Uint32Array(USIZE * VSIZE * WSIZE);

    function hash(x, y, z) {
        let h = ((x * 374761393 + y * 668265263 + z * 1274126177) | 0);
        h = ((h ^ (h >> 13)) * 1103515245 + 12345) | 0;
        return (h & 0x7fffffff) / 0x7fffffff;
    }

    // Star colors: mostly white, some blue-white, yellow-white, reddish
    const starColors = [
        [255, 255, 255],   // pure white
        [255, 255, 255],   // pure white (more common)
        [200, 220, 255],   // blue-white
        [180, 200, 255],   // blue
        [255, 240, 200],   // yellow-white
        [255, 200, 170],   // warm/reddish
    ];

    // Pre-generate stars as ellipsoids with large W extent (like dark eyes texture)
    // so they're visible in any W-slice of the 3D texture
    const stars = [];
    const numStars = 80;
    for (let i = 0; i < numStars; i++) {
        stars.push({
            u: hash(i * 7 + 3, i * 11 + 17, 1) * USIZE,
            v: hash(i * 13 + 5, i * 19 + 23, 2) * VSIZE,
            w: hash(i * 29 + 7, i * 31 + 11, 3) * WSIZE,
            radUV: 1.0 + hash(i * 37, i * 41, 4) * 2.0,  // UV radius 1-3
            radW: 15 + hash(i * 43, i * 47, 5) * 35,      // W extent 15-50 (large!)
            colorIdx: Math.floor(hash(i * 53, i * 59, 6) * starColors.length),
            brightness: 0.6 + hash(i * 61, i * 67, 7) * 0.4
        });
    }

    for (let w = 0; w < WSIZE; w++) {
        for (let v = 0; v < VSIZE; v++) {
            for (let u = 0; u < USIZE; u++) {
                const index = u + v * USIZE + w * USIZE * VSIZE;

                // Very dark background with subtle noise
                const n = hash(u, v, w);
                const base = 1 + n * 3;
                let r = base, g = base, b = base + 1; // faint blue-black tint

                // Check all stars
                let maxGlow = 0;
                let bestColor = null;
                for (const star of stars) {
                    const du = (u - star.u) / star.radUV;
                    const dv = (v - star.v) / star.radUV;
                    let dw_raw = Math.abs(w - star.w);
                    if (dw_raw > WSIZE / 2) dw_raw = WSIZE - dw_raw; // wrap W
                    const dw = dw_raw / star.radW;

                    const dist2 = du * du + dv * dv + dw * dw;
                    if (dist2 < 1.0) {
                        const intensity = 1.0 - Math.sqrt(dist2);
                        const glow = intensity * intensity * star.brightness;
                        if (glow > maxGlow) {
                            maxGlow = glow;
                            bestColor = starColors[star.colorIdx];
                        }
                    }
                }

                if (maxGlow > 0) {
                    r = Math.max(r, bestColor[0] * maxGlow);
                    g = Math.max(g, bestColor[1] * maxGlow);
                    b = Math.max(b, bestColor[2] * maxGlow);
                }

                r = Math.max(0, Math.min(255, Math.round(r)));
                g = Math.max(0, Math.min(255, Math.round(g)));
                b = Math.max(0, Math.min(255, Math.round(b)));

                texture[index] = (255 << 24) | (b << 16) | (g << 8) | r;
            }
        }
    }

    return { texture, texture_info: { USIZE, VSIZE, WSIZE } };
}

const _H = 3; // wall z height
const _2 = 1.0 / Math.sqrt(2);
const AREA1_ZH = 100.0;

const ROOM1 = true;
const CORRIDOR1 = true;
const ROOM2 = true;
const ROOM3 = true;

// First room
//           |---| hr
//         _3__
//       /2     \4
// x <- |1   x   
//       \7     /5
//         ----6
//           | y
//           v
//
const brickTex = generateBrickWallTexture();
const applyBrick = (wall, su=1, sv=1, sw=1) => {
  if (!APPLY_TEXTURES) return; wall.texture = brickTex.texture; wall.texture_info = brickTex.texture_info; wall.vertices_in_texmap = wall.vertices_in_object.map(v => new Vector4D((v.y*.5+.5)*su, (v.z*.5+.5)*sv, (v.w*.5+.5)*sw, 0));
};
const R1HR = 5; // hexagon radius
const R1HS = R1HR / (0.5 + _2); // hexagon side
const R1HW = 10; // w thickness of the room
const r1c = new Vector4D(0, 0, AREA1_ZH, 0);
if (ROOM1) {
  const hr = R1HR; // hexagon radius
  const hs = R1HS/2.0;
  const hw = R1HW/2.0;
  // 1
  objects.push(createHyperwall(
    new Transform4D([
      [ 1,  0,  0,  0, hr],
      [ 0, hs,  0,  0,  0],
      [ 0,  0, _H,  0,  AREA1_ZH],
      [ 0,  0,  0, hw,  0],
      [ 0,  0,  0,  0,  1]
    ]),
    0xff0000
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // 2
  objects.push(createHyperwall(
    new Transform4D([
      [    _2, hs*_2,     0,     0, hr*_2],
      [   -_2, hs*_2,     0,     0,-hr*_2],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x777700
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // 3
  objects.push(createHyperwall(
    new Transform4D([
      [     0,    hs,     0,     0,     0],
      [    -1,     0,     0,     0,   -hr],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x007700
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // 4
  objects.push(createHyperwall(
    new Transform4D([
      [   -_2, hs*_2,     0,     0,-hr*_2],
      [   -_2,-hs*_2,     0,     0,-hr*_2],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x777700
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // missing opposite wall, on to 5
  // 5
  objects.push(createHyperwall(
    new Transform4D([
      [   -_2,-hs*_2,     0,     0,-hr*_2],
      [    _2,-hs*_2,     0,     0, hr*_2],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x777700
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // 6
  objects.push(createHyperwall(
    new Transform4D([
      [     0,   -hs,     0,     0,     0],
      [     1,     0,     0,     0,    hr],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x00ff00
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // 7
  objects.push(createHyperwall(
    new Transform4D([
      [    _2,-hs*_2,     0,     0, hr*_2],
      [    _2, hs*_2,     0,     0, hr*_2],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     0,     0,     0,    hw,     0],
      [     0,     0,     0,     0,     1]
    ]),
    0x777700
  ));
  applyBrick(objects[objects.length - 1], 1, 1, 2);
  // w+ bounding wall
  objects.push(createHyperwall(
    new Transform4D([
      [     0,    hr,     0,     0,     0],
      [     0,     0,     0,    hr,     0],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [     1,     0,     0,     0,    hw],
      [     0,     0,     0,     0,     1]
    ]),
    0x0000ff
  ));
  objects.push(createHyperwall(
    new Transform4D([
      [     0,    hr,     0,     0,     0],
      [     0,     0,     0,    hr,     0],
      [     0,     0,    _H,     0,     AREA1_ZH],
      [    -1,     0,     0,     0,   -hw],
      [     0,     0,     0,     0,     1]
    ]),
    0x000077
  ));
}

// First corridor
const C1ml = 50.0;
if (CORRIDOR1) {
  const center = new Vector4D(- R1HR - C1ml / 2.0, 0, AREA1_ZH, 0);
  const main_dir = new Vector4D(1,0,0,0);
  const main_length = C1ml;
  const dir1 = new Vector4D(0,1,0,0);
  const dir2 = new Vector4D(0,0,0,1);
  const length1 = R1HS;
  const length2 = R1HW;
  const c1idx = objects.length;
  createCorridorTube(objects, center, main_dir, main_length, dir1, dir2, length1, length2, _H);
  applyBrick(objects[c1idx + 0], 10, 1, 2); // wall 1 (+y side)
  applyBrick(objects[c1idx + 2], 10, 1, 1); // wall 2 (-w side)
}

// Second room, cubic with two exits (+x and -w)
const R2R = 10.0;
const R2X = -R1HR - C1ml - R2R; // center of room2 in x
const C2R = 5.0; // corridor 2 size (both dims)
const r2c = new Vector4D(R2X, 0, AREA1_ZH, 0); // convenience
const r2_magicwall1_c = r2c.add(new Vector4D(R2R, 0, 0, 0));
let r2_magicwall1_idx = null;
if (ROOM2) {
  const _r = R2R;
  const h1f1 = R1HS / 2.0 / R2R;
  const h1f2 = R1HW / 2.0 / R2R;
  createHyperwallWithCenterHole(objects,
    new Transform4D([
        [1, 0, 0, 0, _r + R2X],
        [0, _r, 0, 0, 0],
        [0, 0, _H, 0, AREA1_ZH],
        [0, 0, 0, _r, 0],
        [0, 0, 0, 0, 1]
    ]),
    h1f1, h1f2,
    0xff0000
  );
  applyBrick(objects[objects.length - 4], 2, 1, 2);
  applyBrick(objects[objects.length - 3], 2, 1, 2);
  applyBrick(objects[objects.length - 2], 2, 1, 2);
  applyBrick(objects[objects.length - 1], 2, 1, 2);
  // magic wall
  r2_magicwall1_idx = objects.length;
  objects.push(createHyperwall(
    new Transform4D([
      [1, 0, 0, 0,        r2_magicwall1_c.x],
      [0, R1HS/2.0, 0, 0, r2_magicwall1_c.y],
      [0, 0, _H, 0,       r2_magicwall1_c.z],
      [0, 0, 0, R1HW/2.0, r2_magicwall1_c.w],
      [0, 0, 0, 0, 1]
    ]),
    0xff0000
  ));
  applyBrick(objects[objects.length - 1], 2, 1, 2);
  // other walls
  objects.push(createHyperwall(
    new Transform4D([
      [1, 0, 0, 0, -_r + R2X],
      [0, _r, 0, 0, 0],
      [0, 0, _H, 0, AREA1_ZH],
      [0, 0, 0, _r, 0],
      [0, 0, 0, 0, 1]
    ]),
    0x770000
  ));
  applyBrick(objects[objects.length - 1], 2, 1, 2);
  objects.push(createHyperwall(new Transform4D([
      [0, _r, 0, 0, R2X],
      [1, 0, 0, 0, _r],
      [0, 0, _H, 0, AREA1_ZH],
      [0, 0, 0, _r, 0],
      [0, 0, 0, 0, 1]
  ]), 0x00ff00));
  applyBrick(objects[objects.length - 1], 2, 1, 2);
  objects.push(createHyperwall(new Transform4D([
      [0, _r, 0, 0, R2X],
      [1, 0, 0, 0, -_r],
      [0, 0, _H, 0, AREA1_ZH],
      [0, 0, 0, _r, 0],
      [0, 0, 0, 0, 1]
  ]), 0x007700));
  applyBrick(objects[objects.length - 1], 2, 1, 2);
  // Room2 W+ Wall
  objects.push(createHyperwall(new Transform4D([
      [0, _r, 0, 0, R2X],
      [0, 0, 0, _r, 0],
      [0, 0, _H, 0, AREA1_ZH],
      [1, 0, 0, 0, _r],
      [0, 0, 0, 0, 1]
  ]), 0x0000ff));
  if (APPLY_TEXTURES) {
    const darkEyesTex = generateDarkEyesTexture();
    const wPlusWall = objects[objects.length - 1];
    wPlusWall.texture = darkEyesTex.texture;
    wPlusWall.texture_info = darkEyesTex.texture_info;
    wPlusWall.vertices_in_texmap = wPlusWall.vertices_in_object.map(
      v => new Vector4D((v.y * .5 + .5), (v.z * .5 + .5), (v.w * .5 + .5), 0)
    );
  }
  const h2f = C2R / 2.0 / R2R;
  createHyperwallWithCenterHole(objects,
    new Transform4D([
      [0, _r, 0, 0, R2X],
      [0, 0, 0, _r, 0],
      [0, 0, _H, 0, AREA1_ZH],
      [1, 0, 0, 0, -_r],
      [0, 0, 0, 0, 1]
    ]),
    h2f, h2f,
    0x000077
  );

  // Bargainer
  let bargainer = createBargainer();
  bargainer.pose.matrix[0][0] = 2.0;
  bargainer.pose.matrix[1][1] = 2.0;
  bargainer.pose.matrix[2][2] = 2.0;
  bargainer.pose.matrix[3][3] = 2.0;
  bargainer.pose.rotate_self_by_delta('XY', Math.PI, true);
  bargainer.pose.translate_self_by_delta(R2X - R2R, 0, 1.0+AREA1_ZH, 0);
  objects.push(bargainer);

} // ROOM 2
let bargainerIndex = objects.length - 1;

// First area is elevated and so needs a floor surface
const area1xmax = R1HR;
const area1xmin = R2X - R2R;
const area1ymax = R2R;
const area1ymin = -R2R;
const area1wmax = R2R;
const area1wmin = -R2R;
const a1xl = area1xmax - area1xmin;
const a1yl = area1ymax - area1ymin;
const a1wl = area1wmax - area1wmin;
const a1c = new Vector4D(
  (area1xmax + area1xmin) / 2.0,
  (area1ymax + area1ymin) / 2.0,
  AREA1_ZH,
  (area1wmax + area1wmin) / 2.0
);
let area1Floor = createHyperwall(
    new Transform4D([
      [ 0, a1xl/2.0,  0,  0,a1c.x],
      [ 0,  0,a1yl/2.0,  0, a1c.y],
      [ 1,  0,  0,      0,  a1c.z],
      [ 0,  0,  0,a1wl/2.0, a1c.w],
      [ 0,  0,  0,  0,  1]
    ]),
    0xffffff
  );
area1Floor.collider = null; // height is handled in the player controller
// Black and white checkerboard texture with two lights at each end
{
  const SU = 320;
  const SV = 160;
  const SW = 32;
  const tex = new Uint32Array(SU * SV * SW);
  // Two lights at opposite ends of the u-axis (x-direction), centered in v,w
  const light1 = { u: SU * 2/5, v: SV / 2, w: SW / 2 };
  const light2 = { u: SU * 7/8, v: SV/2, w: SW/2 };
  const light3 = { u: 0, v: SV/4, w: SW/2 };
  const light4 = { u: 0, v: SV*3/4, w: SW/2 };
  const lightRadius = SU * 0.15; // falloff radius
  for (let w = 0; w < SW; w++) {
    for (let v = 0; v < SV; v++) {
      for (let u = 0; u < SU; u++) {
        // Distance to each light
        let d1 = Math.sqrt((u - light1.u) ** 2 + (v - light1.v) ** 2 + (w - light1.w) ** 2);
        let d2 = Math.sqrt((u - light2.u) ** 2 + (v - light2.v) ** 2 + (w - light2.w) ** 2);
        let d3 = Math.sqrt((u - light3.u) ** 2 + (v - light3.v) ** 2 + (w - light3.w) ** 2);
        let d4 = Math.sqrt((u - light4.u) ** 2 + (v - light4.v) ** 2 + (w - light4.w) ** 2);
        // Smooth falloff: bright near light, dark far away
        let b1 = Math.max(0, 1.0 - d1 / lightRadius);
        let b2 = Math.max(0, 1.0 - d2 / lightRadius);
        let b3 = Math.max(0, 1.0 - d3 / lightRadius);
        let b4 = Math.max(0, 1.0 - d4 / lightRadius);
        let brightness = Math.min(1.0, b1 + b2 + b3 + b4);
        // Base checkerboard
        let isWhite = ((Math.ceil(u/10) + Math.ceil(v/10) + w) % 2 === 0);
        let base = isWhite ? 255 : 30;
        let minBright = isWhite ? 0.35 : 0.05;
        let lit = base * (minBright + (1.0 - minBright) * brightness);
        // Per-texel dirt noise
        let nh = ((u * 374761393 + v * 668265263 + w * 1274126177) | 0);
        nh = ((nh ^ (nh >> 13)) * 1103515245 + 12345) | 0;
        let noise = ((nh & 0x7fffffff) / 0x7fffffff - 0.5) * 20;
        lit = Math.max(0, Math.min(255, lit + noise));
        // Warm orange tint near lights
        let r = Math.round(Math.min(255, lit * (1.0 + 0.15 * brightness)));
        let g = Math.round(Math.min(255, lit * (1.0 + 0.05 * brightness)));
        let b = Math.round(Math.max(0, lit * (1.0 - 0.10 * brightness)));
        let rgba_u32 = (255 << 24) | (b << 16) | (g << 8) | r;
        tex[u + v * SU + w * SU * SV] = rgba_u32;
      }
    }
  }
  area1Floor.texture = tex;
  area1Floor.texture_info = { USIZE: SU, VSIZE: SV, WSIZE: SW };
}
objects.push(area1Floor);

// End of Area1 -------------------------------------------

// corridor 2 (falling down)
let c2l = AREA1_ZH;
let c2c = new Vector4D(R2X, 0, AREA1_ZH / 2.0 + _H, -R2R - C2R / 2.0);
createCorridorTubeWithHole(objects, c2c, new Vector4D(0,0,-1,0), c2l, new Vector4D(0,0,0,1), new Vector4D(1,0,0,0), C2R, C2R, -c2l / 2.0 + _H / 2.0, _H + 1.0, new Vector4D(0,1,0,0), C2R, true);

// Area2 ------------------------------------------------ 

// Corridor 3 (-w, gun)
const c3r = C2R;
const C3L = 30.0;
let c3c = new Vector4D(R2X, 0, 0, -R2R - C3L / 2.0);
createCorridorTubeWithHole(objects, c3c, new Vector4D(0,0,0,-1), C3L, new Vector4D(1,0,0,0), new Vector4D(0,1,0,0), c3r, c3r, 0.0, 0.0, new Vector4D(0,0,1,0), _H, false);

// Corridor 4
const c4r = c3r;
const C4L = 30.0;
let c4c = new Vector4D(R2X, 0, 0, -R2R - C3L - C4L / 2.0);
createCorridorTubeWithHole(objects, c4c, new Vector4D(0,0,0,1), C4L, new Vector4D(0,1,0,0), new Vector4D(1,0,0,0), c4r, c4r, -C4L / 2.0 + c4r, c4r, new Vector4D(0,0,1,0), _H, false);

// Corridor 5a (y+), wide in x, narrow in w
//   ______
// __|    _  
// __    |_|  | x
//   |_____   v
//      <--
//       y
const c5ar1 = c4r;
const C5A_R2 = 20.0;
const C5A_L = 30.0;
let c5c = new Vector4D(R2X, C5A_L / 2.0 + c4r / 2.0, 0, -R2R - C3L - C4L + c4r);
let c5_entrance = new Vector4D(R2X,       c4r / 2.0, 0, -R2R - C3L - C4L + c4r);
createHyperwallWithCenterHole(
  objects,
  new Transform4D([
    [  0,  C5A_R2/2.0,  0,        0, c5_entrance.x],
    [  1,        0,  0,        0, c5_entrance.y],
    [  0,        0, _H,        0, c5_entrance.z],
    [  0,        0,  0,   c5ar1/2, c5_entrance.w],
    [  0,        0,  0,        0,      1]
  ]),
  c5ar1 / C5A_R2,
  c5ar1 / c5ar1,
  0x0000ff
);
createCorridorTube(objects, c5c, new Vector4D(0,1,0,0), C5A_L, new Vector4D(0,0,0,1), new Vector4D(1,0,0,0), c5ar1, C5A_R2, _H);
objects.push(createObstacleCube(new Transform4D([
    [  3,        0,  0,        0, c5c.x],
    [  0,        3,  0,        0, c5c.y],
    [  0,        0, _H/2.0,        0, c5c.z + _H/2.0],
    [  0,        0,  0,c5ar1/2.0, c5c.w],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
// prep two monster spawns
const c5_monster1 = c5c.add(new Vector4D(6, 0, 0, 0));
const c5_monster2 = c5c.add(new Vector4D(-6, 0, 0, 0));
// Room 3

const R3YL = 20.0;
const R3WL = 40.0;
const R3XL = C5A_R2;
const R3_ENDYL = 10.0; // wall 5 y length
const R3_OUTWL = 5.0 / _2; // out opening width in W
const R3_OUTYL = 7.0; // out corridor (w7) y side
const R3_OUTXL = R3XL;
const r3_ref = new Vector4D(R2X, C5A_L + c5ar1 / 2.0, 0, -R2R - C3L - C4L + c4r / 2.0); // ref point
const r3_entrance = r3_ref.add(new Vector4D(0, 0, 0, c4r / 2.0));
//                     . r3_ref
//        \          / |
//c6_ref . \6      3/  | 1
//       7\ \__4___/ / |   |
//        5|___________|   v y
//               2
//            w <-- 
const w1_c = r3_ref.add(new Vector4D(0, R3YL / 2.0, 0, 0));
const w2_c = w1_c.add(new Vector4D(0, R3YL/2.0, 0, R3WL / 2.0));
const w3_dy = R3YL - R3_ENDYL;
const w3_dw = w3_dy;
const w3_wyl = Math.sqrt(w3_dw * w3_dw + w3_dy * w3_dy);
const w3_c = r3_ref.add(new Vector4D(0, w3_dy/2.0, 0, c5ar1 + w3_dw/2.0));
const W3A_DW = 10.0;
const W3A_DY = 10.0;
const W3B_DY = 10.0;
const W3C_DW = 10.0;
const W3A_GAP = c5ar1;
// triangular walls in w1/2 corner
const w3a_c = r3_ref.add(new Vector4D(0, W3A_GAP + W3A_DY/2.0, 0, W3A_GAP + W3A_DW/2.0));  // parallel to w3
const w3a_wyl = Math.sqrt(W3A_DW * W3A_DW + W3A_DY * W3A_DY);
const w3b_c = r3_ref.add(new Vector4D(0, W3A_GAP + W3B_DY/2.0, 0, W3A_GAP)); // parallel to w1
const w3c_c = r3_ref.add(new Vector4D(0, W3A_GAP + W3B_DY, 0, W3A_GAP + W3C_DW/2.0)); // parallel to w2
// blocks in same corner
const obst_c = w3b_c.add(new Vector4D(0, 0, 0, -W3A_GAP/2.0)); // wall 1 obstacles
const obst_x = R3XL / 4.0;
const obst2_c = w3c_c.add(new Vector4D(0, R3_ENDYL/2.0, 0, 0)); // wall 2 obstacles
// pillars between wall 2 and 4
const pill_ref = w2_c.add(new Vector4D(0, -R3_ENDYL/2.0, 0, 5));
const pill_r = 0.3;
const w4_wl = R3WL - c5ar1 - w3_dw - R3_OUTWL;
const w4_c = w3_c.add(new Vector4D(0, w3_dy/2.0, 0, w3_dw/2.0 + w4_wl / 2.0));
const w5_yl = R3_ENDYL;
const w5_c = w2_c.add(new Vector4D(0, -w5_yl/2.0, 0, R3WL / 2.0));
const w7_dy = R3_OUTYL;
const w7_dw = R3_OUTYL;
const w7_wyl = Math.sqrt(w7_dw * w7_dw + w7_dy * w7_dy);
const w6_dw = w7_dw + R3_OUTWL;
const w6_dy = w6_dw;
const w6_wyl = Math.sqrt(w6_dw * w6_dw + w6_dy * w6_dy);
const w6_c = w4_c.add(new Vector4D(0, -w6_dy/2.0, 0, w4_wl / 2.0 + w6_dw / 2.0));
const w7_c = w5_c.add(new Vector4D(0, -w5_yl/2.0 -w7_dy/2.0, 0, w7_dw/2.0));
const w8_c = r3_ref.add(new Vector4D(R3XL/2.0, R3YL/2.0, 0, (R3WL + w7_dw)/2.0));
const w9_c = r3_ref.add(new Vector4D(-R3XL/2.0, R3YL/2.0, 0, (R3WL + w7_dw)/2.0));
// need to add more x+ end walls to cover extra length of exit corridor
const w8a_c = r3_ref.add(new Vector4D(R3XL/2.0, -R3YL/2.0, 0, R3WL + w7_dw/2.0));
const w9a_c = r3_ref.add(new Vector4D(-R3XL/2.0,-R3YL/2.0, 0, R3WL + w7_dw/2.0));
if (ROOM3) {
  // 1
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,        0,  0,  R3XL/2.0, w1_c.x],
      [ 0, R3YL/2.0,  0,         0, w1_c.y],
      [ 0,        0, _H,         0, w1_c.z],
      [ 1,        0,  0,         0, w1_c.w],
      [ 0,        0,  0,         0,      1]
    ]),
    0xff0000
  ));
  // w2
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,        0,  0,  R3XL/2.0, w2_c.x],
      [-1,        0,  0,         0, w2_c.y],
      [ 0,        0, _H,         0, w2_c.z],
      [ 0, R3WL/2.0,  0,         0, w2_c.w],
      [ 0,        0,  0,         0,      1]
    ]),
    0x00ff00
  ));
  // w3
  objects.push(createHyperwall(
    new Transform4D([
      [  0,             0,  0,  R3XL/2.0, w3_c.x],
      [-_2, w3_wyl/2.0*_2,  0,         0, w3_c.y],
      [  0,             0, _H,         0, w3_c.z],
      [ _2, w3_wyl/2.0*_2,  0,         0, w3_c.w],
      [  0,             0,  0,         0,      1]
    ]),
    0xffff00
  ));
  // w3a
  objects.push(createHyperwall(
    new Transform4D([
      [  0,             0,  0,  R3XL/2.0, w3a_c.x],
      [-_2, w3a_wyl/2.0*_2,  0,         0, w3a_c.y],
      [  0,             0, _H,         0, w3a_c.z],
      [ _2, w3a_wyl/2.0*_2,  0,         0, w3a_c.w],
      [  0,             0,  0,         0,      1]
    ]),
    0xffff00
  ));
  // w3b
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,        0,  0,  R3XL/2.0, w3b_c.x],
      [ 0, W3B_DY/2.0,  0,         0, w3b_c.y],
      [ 0,        0, _H,         0, w3b_c.z],
      [ 1,        0,  0,         0, w3b_c.w],
      [ 0,        0,  0,         0,      1]
    ]),
    0xff0000
  ));
  // w3c
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,        0,  0,  R3XL/2.0, w3c_c.x],
      [-1,        0,  0,         0, w3c_c.y],
      [ 0,        0, _H,         0, w3c_c.z],
      [ 0, W3C_DW/2.0,  0,         0, w3c_c.w],
      [ 0,        0,  0,         0,      1]
    ]),
    0x00ff00
  ));
  // w4
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,         0,  0,  R3XL/2.0, w4_c.x],
      [-1,         0,  0,         0, w4_c.y],
      [ 0,         0, _H,         0, w4_c.z],
      [ 0, w4_wl/2.0,  0,         0, w4_c.w],
      [ 0,         0,  0,         0,      1]
    ]),
    0x00ff00
  ));
  // w5
  objects.push(createHyperwall(
    new Transform4D([
      [ 0,        0,  0,  R3XL/2.0, w5_c.x],
      [ 0, w5_yl/2.0,  0,         0, w5_c.y],
      [ 0,        0, _H,         0, w5_c.z],
      [ 1,        0,  0,         0, w5_c.w],
      [ 0,        0,  0,         0,      1]
    ]),
    0xff0000
  ));
  // w6
  objects.push(createHyperwall(
    new Transform4D([
      [  0,             0,  0,  R3XL/2.0, w6_c.x],
      [ _2, w6_wyl/2.0*_2,  0,         0, w6_c.y],
      [  0,             0, _H,         0, w6_c.z],
      [ _2,-w6_wyl/2.0*_2,  0,         0, w6_c.w],
      [  0,             0,  0,         0,      1]
    ]),
    0xffff00
  ));
  // w7
  objects.push(createHyperwall(
    new Transform4D([
      [  0,             0,  0,  R3XL/2.0, w7_c.x],
      [ _2, w7_wyl/2.0*_2,  0,         0, w7_c.y],
      [  0,             0, _H,         0, w7_c.z],
      [ _2,-w7_wyl/2.0*_2,  0,         0, w7_c.w],
      [  0,             0,  0,         0,      1]
    ]),
    0xffff00
  ));
  // w8
  objects.push(createHyperwall(
    new Transform4D([
      [ 1,        0,  0,                0, w8_c.x],
      [ 0, R3YL/2.0,  0,                0, w8_c.y],
      [ 0,        0, _H,                0, w8_c.z],
      [ 0,        0,  0, (R3WL+w7_dw)/2.0, w8_c.w],
      [ 0,        0,  0,                0,      1]
    ]),
    0x0000ff
  ));
  objects.push(createHyperwall(
    new Transform4D([
      [ 1,        0,  0,                0, w8a_c.x],
      [ 0, R3YL/2.0,  0,                0, w8a_c.y],
      [ 0,        0, _H,                0, w8a_c.z],
      [ 0,        0,  0,        w7_dw/2.0, w8a_c.w],
      [ 0,        0,  0,                0,      1]
    ]),
    0x0000ff
  ));
  // w9
  objects.push(createHyperwall(
    new Transform4D([
      [ 1,        0,  0,                0, w9_c.x],
      [ 0, R3YL/2.0,  0,                0, w9_c.y],
      [ 0,        0, _H,                0, w9_c.z],
      [ 0,        0,  0, (R3WL+w7_dw)/2.0, w9_c.w],
      [ 0,        0,  0,                0,      1]
    ]),
    0x0000ff
  ));
  objects.push(createHyperwall(
    new Transform4D([
      [ 1,        0,  0,                0, w9a_c.x],
      [ 0, R3YL/2.0,  0,                0, w9a_c.y],
      [ 0,        0, _H,                0, w9a_c.z],
      [ 0,        0,  0,        w7_dw/2.0, w9a_c.w],
      [ 0,        0,  0,                0,      1]
    ]),
    0x0000ff
  ));
  // Blocks in wall 1/2 corner
objects.push(createObstacleCube(new Transform4D([
    [ obst_x/2.0,        0,  0,        0, obst_c.x - obst_x * -1.5],
    [  0,    W3B_DY/2.0,  0,        0, obst_c.y],
    [  0,        0, _H/2.0,        0, obst_c.z + _H/2.0],
    [  0,        0,  0,W3A_GAP/2.0, obst_c.w],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ obst_x/2.0,        0,  0,        0, obst_c.x - obst_x * 0.5],
    [  0,    W3B_DY/2.0,  0,        0, obst_c.y],
    [  0,        0, _H/2.0,        0, obst_c.z + _H/2.0],
    [  0,        0,  0,W3A_GAP/2.0, obst_c.w],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ obst_x/2.0,        0,  0,        0, obst2_c.x - obst_x * 1.5],
    [  0,    R3_ENDYL/2.0,  0,        0, obst2_c.y],
    [  0,        0, _H/2.0,        0, obst2_c.z + _H/2.0],
    [  0,        0,  0,W3C_DW/2.0, obst2_c.w],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ obst_x/2.0,        0,  0,        0, obst2_c.x - obst_x * -0.5],
    [  0,    R3_ENDYL/2.0,  0,        0, obst2_c.y],
    [  0,        0, _H/2.0,        0, obst2_c.z + _H/2.0],
    [  0,        0,  0,W3C_DW/2.0, obst2_c.w],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
// Pillars
objects.push(createObstacleCube(new Transform4D([
    [ pill_r,        0,  0,        0, pill_ref.x + obst_x],
    [  0,    R3_ENDYL/2.0,  0,        0, pill_ref.y],
    [  0,        0, _H/2.0,        0, pill_ref.z + _H/2.0],
    [  0,        0,  0,pill_r, pill_ref.w - obst_x],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ pill_r,        0,  0,        0, pill_ref.x - obst_x],
    [  0,    R3_ENDYL/2.0,  0,        0, pill_ref.y],
    [  0,        0, _H/2.0,        0, pill_ref.z + _H/2.0],
    [  0,        0,  0,pill_r, pill_ref.w - obst_x],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ pill_r,        0,  0,        0, pill_ref.x + obst_x],
    [  0,    R3_ENDYL/2.0,  0,        0, pill_ref.y],
    [  0,        0, _H/2.0,        0, pill_ref.z + _H/2.0],
    [  0,        0,  0,pill_r, pill_ref.w + obst_x],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));
objects.push(createObstacleCube(new Transform4D([
    [ pill_r,        0,  0,        0, pill_ref.x - obst_x],
    [  0,    R3_ENDYL/2.0,  0,        0, pill_ref.y],
    [  0,        0, _H/2.0,        0, pill_ref.z + _H/2.0],
    [  0,        0,  0,pill_r, pill_ref.w + obst_x],
    [  0,        0,  0,        0,      1]
  ]),
  0x00ff00
));

}

// Corridor 6
// see room 3 diagram for ref point
const c6_ref = r3_ref.add(new Vector4D(0, R3YL - R3_ENDYL - R3_OUTYL, 0, R3WL + R3_OUTYL));
const c6_yd = R3_OUTWL;
const C6_XL = 60.0;
const C6_WD = c6_yd;
const c6_c = c6_ref.add(new Vector4D(0, -R3_OUTWL / 2.0, 0, C6_WD/2.0));
// x+ corridor, hole in -w dir
createCorridorTubeWithHole(objects, c6_c, new Vector4D(-1,0,0,0), C6_XL, new Vector4D(0,0,0,-1), new Vector4D(0,1,0,0), C6_WD, c6_yd, 0.0, R3_OUTXL, new Vector4D(0,0,1,0), _H, false);

// Room 4         _
//          /\       
//        4/  \3     | L
//    ____/8/\7\     _
//d |      /|.  \ |  _ c7_ref in the middle of the room
//    ___. \|   / |
//   r4ref\5\/6/  v
//        1\  /2  y
//          \/
//       x <-- 
//
//       11     12
//       --------
//       | |   | | w
//    -----------  ^
//      -| |   | | | r4_ref in W middle
//    ------------  
//       | |   | |
//       ----. ---   c7_ref in -W
//        9      10
const R4_L = 15.0; // outer reference length
const R4_YL = 2 * R4_L + 2 *c6_yd;
const R4_XL = 2 * R4_L + c6_yd;
const R4_WL = C6_WD * 3;
const R4_d = c6_yd / 2.0; // half opening
const R4_l = 10.0; // inner reference length
const R4_OUTYR = 2.0;
const C7_DY = 5.0;
const C7_DX = 5.0;
const r4_ref = c6_ref.add(new Vector4D(-C6_XL/2.0, 0, 0, C6_WD/2.0)); // in W middle
const c7_ref = r4_ref.add(new Vector4D(-R4_L, -R4_d, 0, -R4_WL/2.0)); // at -W end, but X, Y middle
const r4_entrance = r4_ref.add(new Vector4D(0, -R4_d, 0, 0)); 
if (true) {
  const w1_xl = R4_L;
  const w1_yl = R4_L;
  const w1_xyl = Math.sqrt(w1_xl * w1_xl + w1_yl * w1_yl);
  const w1_c = r4_ref.add(new Vector4D(-w1_xl/2.0, w1_yl/2.0, 0, 0));
  const w2_xl = R4_L + R4_d;
  const w2_yl = R4_L + R4_d;
  const w2_xyl = Math.sqrt(w2_xl * w2_xl + w2_yl * w2_yl);
  const w2_c = r4_ref.add(new Vector4D(-w1_xl -w2_xl/2.0, w1_yl - w2_yl/2.0, 0, 0));
  const ref2 = r4_ref.add(new Vector4D(-w1_xl -w2_xl, w1_yl - w2_yl, 0, 0)); // tip of the room
  const w3_xl = R4_L + R4_d;
  const w3_yl = R4_L + R4_d;
  const w3_xyl = Math.sqrt(w3_xl * w3_xl + w3_yl * w3_yl);
  const w3_c = ref2.add(new Vector4D(w3_xl/2.0, -w3_yl/2.0, 0, 0));
  const w4_xl = R4_L;
  const w4_yl = R4_L;
  const w4_xyl = Math.sqrt(w4_xl * w4_xl + w4_yl * w4_yl);
  const w4_c = ref2.add(new Vector4D(w3_xl + w4_xl/2.0, -w3_yl + w4_yl/2.0, 0, 0));
  const ref3 = c7_ref.add(new Vector4D(R4_l, 0, 0, R4_WL/2.0)); // left tip of inner room
  const w5_xl = R4_l;
  const w5_yl = R4_l;
  const w5_xyl = Math.sqrt(w5_xl * w5_xl + w5_yl * w5_yl);
  const w5_c = ref3.add(new Vector4D(-w5_xl/2.0, w5_yl/2.0, 0, 0));
  const w6_xl = R4_l - R4_OUTYR;
  const w6_yl = R4_l - R4_OUTYR;
  const w6_xyl = Math.sqrt(w6_xl * w6_xl + w6_yl * w6_yl);
  const w6_c = ref3.add(new Vector4D(-w5_xl -w6_xl/2.0, w5_yl - w6_yl/2.0, 0, 0));
  const w8_xl = R4_l;
  const w8_yl = R4_l;
  const w8_xyl = Math.sqrt(w8_xl * w8_xl + w8_yl * w8_yl);
  const w8_c = ref3.add(new Vector4D(-w8_xl/2.0, -w8_yl/2.0, 0, 0));
  const w7_xl = R4_l - R4_OUTYR;
  const w7_yl = R4_l - R4_OUTYR;
  const w7_xyl = Math.sqrt(w7_xl * w7_xl + w7_yl * w7_yl);
  const w7_c = ref3.add(new Vector4D(-w8_xl -w7_xl/2.0, -w8_yl + w7_yl/2.0, 0, 0));
  // W- wall with hole
  const w9_xl = 2 * R4_L;
  const w9_yl = R4_YL;
  const w9_c = c7_ref;
  // W- wall on the side
  const w10_xl = R4_d;
  const w10_yl = R4_YL;
  const w10_c = c7_ref.add(new Vector4D(-R4_L -R4_d / 2.0, 0, 0, 0));
  // W+ wall in the middle
  const w11_xl = 2 * R4_L;
  const w11_yl = R4_YL;
  const w11_c = c7_ref.add(new Vector4D(0, 0, 0, R4_WL));
  // W+ wall on the side
  const w12_xl = R4_d;
  const w12_yl = R4_YL;
  const w12_c = c7_ref.add(new Vector4D(-R4_L -R4_d / 2.0, 0, 0, R4_WL));
  // Temporarily add a square between wall
  const wt1_xl = 20.0;
  const wt1_yl = 20.0;
  const wt1_c = c7_ref.add(new Vector4D(0, 0, 0, R4_WL/3.0));
  const wt2_xl = 20.0;
  const wt2_yl = 20.0;
  const wt2_c = c7_ref.add(new Vector4D(0, 0, 0, 2 * R4_WL/3.0));
  // wall with hole for entrance
  const wte_c = r4_ref.add(new Vector4D(0, -R4_d, 0, 0));
  createHyperwallWithCenterHole(objects,
    new Transform4D([
      [ 1,        0,  0,                0, wte_c.x],
      [ 0,     R4_d,  0,                0, wte_c.y],
      [ 0,        0, _H,                0, wte_c.z],
      [ 0,        0,  0,        R4_WL/2.0, wte_c.w],
      [ 0,        0,  0,                0,      1]
    ]),
    R4_d / R4_d,
    R4_d * 2.0 / R4_WL,
    0xff0000
  );

  // w1: bottom-left diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [-_2, w1_xyl/2.0*_2,  0,        0, w1_c.x],
      [-_2,-w1_xyl/2.0*_2,  0,        0, w1_c.y],
      [  0,             0, _H,        0, w1_c.z],
      [  0,             0,  0, R4_WL/2, w1_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0xff0000
  ));
  // w2: bottom-right diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [-_2,-w2_xyl/2.0*_2,  0,        0, w2_c.x],
      [ _2,-w2_xyl/2.0*_2,  0,        0, w2_c.y],
      [  0,             0, _H,        0, w2_c.z],
      [  0,             0,  0, R4_WL/2, w2_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0xff7700
  ));
  // w3: top-right diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2,-w3_xyl/2.0*_2,  0,        0, w3_c.x],
      [ _2, w3_xyl/2.0*_2,  0,        0, w3_c.y],
      [  0,             0, _H,        0, w3_c.z],
      [  0,             0,  0, R4_WL/2, w3_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0xffff00
  ));
  // w4: top-left diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2, w4_xyl/2.0*_2,  0,        0, w4_c.x],
      [-_2, w4_xyl/2.0*_2,  0,        0, w4_c.y],
      [  0,             0, _H,        0, w4_c.z],
      [  0,             0,  0, R4_WL/2, w4_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0x00ff00
  ));
  // w5: inner bottom-left diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2,-w5_xyl/2.0*_2,  0,        0, w5_c.x],
      [ _2, w5_xyl/2.0*_2,  0,        0, w5_c.y],
      [  0,             0, _H,        0, w5_c.z],
      [  0,             0,  0, R4_WL/2, w5_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0x00ffff
  ));
  // w6: inner bottom-right diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2, w6_xyl/2.0*_2,  0,        0, w6_c.x],
      [-_2, w6_xyl/2.0*_2,  0,        0, w6_c.y],
      [  0,             0, _H,        0, w6_c.z],
      [  0,             0,  0, R4_WL/2, w6_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0x0077ff
  ));
  // w7: inner top-right diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2, w7_xyl/2.0*_2,  0,        0, w7_c.x],
      [ _2,-w7_xyl/2.0*_2,  0,        0, w7_c.y],
      [  0,             0, _H,        0, w7_c.z],
      [  0,             0,  0, R4_WL/2, w7_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0x77ff00
  ));
  // w8: inner top-left diagonal
  objects.push(createHyperwall(
    new Transform4D([
      [ _2,-w8_xyl/2.0*_2,  0,        0, w8_c.x],
      [-_2,-w8_xyl/2.0*_2,  0,        0, w8_c.y],
      [  0,             0, _H,        0, w8_c.z],
      [  0,             0,  0, R4_WL/2, w8_c.w],
      [  0,             0,  0,        0,      1]
    ]),
    0x7700ff
  ));
  // w9: W- wall with hole (center)
  const h1f1 = C7_DX / w9_xl;
  const h1f2 = C7_DY / w9_yl;
  createHyperwallWithCenterHole(
    objects,
    new Transform4D([
      [  0, w9_xl/2.0,  0,        0, w9_c.x],
      [  0,        0,  0, w9_yl/2, w9_c.y],
      [  0,        0, _H,        0, w9_c.z],
      [ -1,        0,  0,        0, w9_c.w],
      [  0,        0,  0,        0,      1]
    ]),
    h1f1, h1f2,
    0x0000ff
  );
  // w10: W- wall on the side
  objects.push(createHyperwall(
    new Transform4D([
      [  0, w10_xl/2.0,  0,         0, w10_c.x],
      [  0,         0,  0, w10_yl/2, w10_c.y],
      [  0,         0, _H,         0, w10_c.z],
      [ -1,         0,  0,         0, w10_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0x000077
  ));
  // w11: W+ wall in the middle
  objects.push(createHyperwall(
    new Transform4D([
      [  0, w11_xl/2.0,  0,         0, w11_c.x],
      [  0,         0,  0, w11_yl/2, w11_c.y],
      [  0,         0, _H,         0, w11_c.z],
      [  1,         0,  0,         0, w11_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0x0000ff
  ));
  // w12: W+ wall on the side
  objects.push(createHyperwall(
    new Transform4D([
      [  0, w12_xl/2.0,  0,         0, w12_c.x],
      [  0,         0,  0, w12_yl/2, w12_c.y],
      [  0,         0, _H,         0, w12_c.z],
      [  1,         0,  0,         0, w12_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0x000077
  ));
  // temporary floors
  objects.push(createHyperwall(
    new Transform4D([
      [  0, wt1_xl/2.0,  0,         0, wt1_c.x],
      [  0,         0,  0, wt1_yl/2, wt1_c.y],
      [  0,         0, _H,         0, wt1_c.z],
      [  1,         0,  0,         0, wt1_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0x0000ff
  ));
  objects.push(createHyperwall(
    new Transform4D([
      [  0, wt2_xl/2.0,  0,         0, wt2_c.x],
      [  0,         0,  0, wt2_yl/2, wt2_c.y],
      [  0,         0, _H,         0, wt2_c.z],
      [  1,         0,  0,         0, wt2_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0x0000ff
  ));
}

// Corridor 7, -W direction
const C7_LW = 10.0;
const c7_c = c7_ref.add(new Vector4D(0, 0, 0, -C7_LW/2.0));
createCorridorTube(objects, c7_c, new Vector4D(0,0,0,-1), C7_LW, new Vector4D(1,0,0,0), new Vector4D(0,1,0,0), C7_DX, C7_DY, _H);

// Room 5
//   ___
//   |  xxxx
// --   xxxx
// --             | y
//   |__xxxx      v
//  w <--

const R5_WL = 60.0;
const R5_DX = 20.0;
const R5_DY = 20.0;
const R5_BX = 5.0;
const R5_BY = 5.0;
const R5_BZ = 0.5;
const R5_BoffsetX = 6.0;
const R5_BoffsetY = 7.0;
const R5_LAVA_WL = 30.0;
const R5_BWL = 35.0;
const C8_LW = 10.0;
const C8_DX = 10.0;
const C8_DY = 10.0;
const r5_shore_wl = (R5_WL - R5_LAVA_WL) / 2.0;
const r5_entrance = c7_c.add(new Vector4D(0, 0, 0, -C7_LW/2.0));
const r5_c = r5_entrance.add(new Vector4D(0, 0, 0, -R5_WL/2.0));
const r5_firstshore_c = r5_entrance.add(new Vector4D(0, 0, 0, -r5_shore_wl/2.0));
const r5_secondshore_c = r5_c.add(new Vector4D(0, 0, 0, -R5_LAVA_WL/2.0 -r5_shore_wl/2.0));
const r5_bc = r5_c.add(new Vector4D(R5_BoffsetX, R5_BoffsetY, 0, R5_BZ/2.0, 0));
const r5_exit = r5_c.add(new Vector4D(0, 0, 0, -R5_WL/2.0));
if (true) {
  const h1f1 = C7_DX / R5_DX;
  const h1f2 = C7_DY / R5_DY;
  createHyperwallWithCenterHole(objects,
      new Transform4D([
          [0, R5_DX/2.0,  0,       0, r5_entrance.x],
          [0,         0,  0, R5_DY/2, r5_entrance.y],
          [0,         0, _H,       0, r5_entrance.z],
          [1,         0,  0,       0, r5_entrance.w],
          [0,         0,  0,       0, 1]
      ]),
      h1f1, h1f2,
      0xff0000
  );
  createCorridorTube(objects, r5_firstshore_c, new Vector4D(0,0,0,-1), r5_shore_wl, new Vector4D(1,0,0,0), new Vector4D(0,1,0,0), R5_DX, R5_DY, _H);
  // Stop the player from jumping out
  const r5_firstedge_c = r5_firstshore_c.add(new Vector4D(0, 0, 0, -r5_shore_wl/2.0));
  createHyperwallWithCenterHole(objects,
      new Transform4D([
          [0, R5_DX/2.0*2,  0,       0, r5_firstedge_c.x],
          [0,         0,  0, R5_DY/2*2, r5_firstedge_c.y],
          [0,         0, _H,       0, r5_firstedge_c.z],
          [1,         0,  0,       0, r5_firstedge_c.w],
          [0,         0,  0,       0, 1]
      ]),
      1.0/2.0, 1.0/2.0,
      0xff0000
  );
  // Lava surface rendered by floor shader
  // Lava river is long in Y direction
  // Add +x and -x wall
  const r5_xp_c = r5_c.add(new Vector4D(R5_DX/2.0 * 2.0, 0, 0, 0));
  const r5_xm_c = r5_c.add(new Vector4D(-R5_DX/2.0 * 2.0, 0, 0, 0));
  objects.push(createHyperwall(
    new Transform4D([
      [  1,         0,  0,         0, r5_xp_c.x],
      [  0, R5_DY,  0,         0, r5_xp_c.y],
      [  0,         0, _H,         0, r5_xp_c.z],
      [  0,         0,  0, R5_LAVA_WL/2.0, r5_xp_c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0xffff00
  ));
  // objects.push(createHyperwall(
  //   new Transform4D([
  //     [  1,         0,  0,         0, r5_xm_c.x],
  //     [  0, R5_DY,  0,         0, r5_xm_c.y],
  //     [  0,         0, _H,         0, r5_xm_c.z],
  //     [  0,         0,  0, R5_LAVA_WL/2.0, r5_xm_c.w],
  //     [  0,         0,  0,         0,       1]
  //   ]),
  //   0xffff00
  // ));
  // Second shore wall
  createCorridorTube(objects, r5_secondshore_c, new Vector4D(0,0,0,-1), r5_shore_wl, new Vector4D(1,0,0,0), new Vector4D(0,1,0,0), R5_DX, R5_DY, _H);
  // Bridge
  objects.push(createHypercube(
    new Transform4D([
      [ R5_BX/2.0,         0,         0,              0,  r5_bc.x],
      [         0, R5_BY/2.0,         0,              0,  r5_bc.y],
      [         0,         0, R5_BZ/2.0,              0,  r5_bc.z],
      [         0,         0,         0, R5_BWL/2.0,  r5_bc.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object
  // To make the player's life easier, add a monolith at the first bridge entrance
  const r5_m1_r = 2.0;
  const r5_m1_h = 3.0;
  const r5_m1c = r5_bc.add(new Vector4D(0, 0, _H + r5_m1_h/2.0, R5_LAVA_WL/2.0));
  objects.push(createHypercube(
    new Transform4D([
      [ r5_m1_r,         0,         0,              0,  r5_m1c.x],
      [         0, r5_m1_r,         0,              0,  r5_m1c.y],
      [         0,         0, r5_m1_h/2.0,          0,  r5_m1c.z],
      [         0,         0,         0,      r5_m1_r,  r5_m1c.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object
  // Stop the player from jumping out
  const r5_secondedge_c = r5_secondshore_c.add(new Vector4D(0, 0, 0, r5_shore_wl/2.0));
  createHyperwallWithCenterHole(objects,
      new Transform4D([
          [0, R5_DX/2.0*2,  0,       0, r5_secondedge_c.x],
          [0,         0,  0, R5_DY/2*2, r5_secondedge_c.y],
          [0,         0, _H,       0, r5_secondedge_c.z],
          [1,         0,  0,       0, r5_secondedge_c.w],
          [0,         0,  0,       0, 1]
      ]),
      1.0/2.0, 1.0/2.0,
      0xff0000
  );
  // End wall
  createHyperwallWithCenterHole(objects,
      new Transform4D([
          [0, R5_DX/2.0,  0,       0, r5_exit.x],
          [0,         0,  0, R5_DY/2, r5_exit.y],
          [0,         0, _H,       0, r5_exit.z],
          [1,         0,  0,       0, r5_exit.w],
          [0,         0,  0,       0, 1]
      ]),
      C8_DX / R5_DX,
      C8_DY / R5_DY,
      0xff0000
  );
}

// Corridor 8
const c8_c = r5_exit.add(new Vector4D(0, 0, 0, -C8_LW/2.0));
createCorridorTube(objects, c8_c, new Vector4D(0,0,0,-1), C8_LW, new Vector4D(1,0,0,0), new Vector4D(0,1,0,0), C8_DX, C8_DY, _H);

// Room 6
const R6_R = 60.0;
const R6_LavaR = 45.0;
const R6_CutW = 2.0;
const R6_BridgeShellR = 30.0;
const R6_BridgeShellHZ = 0.3;
const R6_PedestalR = 7.0;
const R6_PedestalHZ = 1.0;
const r6_entrance = r5_exit.add(new Vector4D(0, 0, 0, -C8_LW));
const r6_c = r6_entrance.add(new Vector4D(0, 0, 0, -R6_R + R6_CutW));
let magicWallIndex = null;
let bossEntranceWallIdx = null;
if (true) {
  // Entrance wall
  const innerR = R6_R * 0.4;
  const h1f1 = C8_DX / innerR / 2.0;
  const h1f2 = C8_DY / innerR / 2.0;
  createHyperwallWithCenterHole(objects,
      new Transform4D([
          [0,  innerR,  0,       0, r6_entrance.x],
          [0,         0,  0,  innerR, r6_entrance.y],
          [0,         0, _H,       0, r6_entrance.z],
          [1,         0,  0,       0, r6_entrance.w],
          [0,         0,  0,       0, 1]
      ]),
      h1f1, h1f2,
      0xff0000
  );
  // Magic wall at boss room entrance (blocks player from leaving once inside)
  bossEntranceWallIdx = objects.length;
  objects.push(createHyperwall(
    new Transform4D([
      [0,  C8_DX/2.0,  0,         0, r5_exit.x],
      [0,          0,  0, C8_DY/2.0, r5_exit.y],
      [0,          0, _H,         0, r5_exit.z],
      [1,          0,  0,         0, r5_exit.w],
      [0,          0,  0,         0, 1]
    ]),
    0xffff00
  ));
  // outer wall
  objects.push(createSphericalWallWithHole(new Transform4D([
        [         0,         0,         0,           R6_R,  r6_c.x],
        [         0,      R6_R,         0,              0,  r6_c.y],
        [         0,         0,        _H,              0,  r6_c.z],
        [      R6_R,         0,         0,              0,  r6_c.w],
        [         0,         0,         0,              0,  1]
    ]), 
    R6_CutW / R6_R,
    0x00ffff
  ));
  if (APPLY_TEXTURES) {
    const starryTex = generateStarryTexture();
    const bossWall = objects[objects.length - 1];
    bossWall.texture = starryTex.texture;
    bossWall.texture_info = starryTex.texture_info;
    // bossWall.vertices_in_texmap = bossWall.vertices_in_object.map(v => {
    //   const theta = Math.atan2(v.w, v.y);
    //   const u = theta / (2 * Math.PI) + 0.5;
    //   const vv = v.x * 0.5 + 0.5;
    //   const ww = v.z * 0.5 + 0.5;
    //   return new Vector4D(u, vv, ww, 0);
    // });
  }
  // Lava rendered by floor shader
  // Spherical Bridge
  objects.push(createSphericalBridge(new Transform4D([
        [         0,         0,         0,       R6_BridgeShellR,  r6_c.x],
        [         0,  R6_BridgeShellR,         0,              0,  r6_c.y],
        [         0,         0, R6_BridgeShellHZ,              0,         r6_c.z],
        [  R6_BridgeShellR,         0,         0,              0,  r6_c.w], // We give this the same rotation as the outer wall to match the discontinuities
        [         0,         0,         0,              0,  1]
    ]),
    0.9, 1.1,
    0x222222
  ));
  // Connect Outer Shore to Spherical Bridge (x+)
  const r6_b1_lx = R6_R - R6_BridgeShellR - 5.0;
  const r6_b1_r = R5_BX / 2.0;
  const r6_b1c = r6_c.add(new Vector4D(r6_b1_lx/2.0 + R6_BridgeShellR, 0, 0, 0));
  objects.push(createHypercube(
    new Transform4D([
      [ r6_b1_lx/2.0,         0,         0,              0,  r6_b1c.x],
      [         0, r6_b1_r,         0,              0,  r6_b1c.y],
      [         0,         0, R5_BZ/2.0,              0,  r6_b1c.z],
      [         0,         0,         0, r6_b1_r,  r6_b1c.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object
  // Magic wall across bridge 1 that disappears when boss is dead
  magicWallIndex = objects.length;
  objects.push(createHyperwall(
    new Transform4D([
      [  1,         0,  0,         0, r6_b1c.x],
      [  0, r6_b1_r*2.0,  0,         0, r6_b1c.y],
      [  0,         0, _H,         0, r6_b1c.z],
      [  0,         0,  0, r6_b1_r*2.0, r6_b1c.w],
      [  0,         0,  0,         0,       1]
    ]),
    0xffff00
  ));

  // To make the player's life easier, add a monolith at the first bridge entrance
  const r6_m1_r = 2.0;
  const r6_m1_h = 3.0;
  const r6_m1c = r6_c.add(new Vector4D(r6_b1_lx + R6_BridgeShellR - 10.0, 0, _H + r6_m1_h/2.0, 0));
  objects.push(createHypercube(
    new Transform4D([
      [ r6_m1_r,         0,         0,              0,  r6_m1c.x],
      [         0, r6_m1_r,         0,              0,  r6_m1c.y],
      [         0,         0, r6_m1_h/2.0,              0,  r6_m1c.z],
      [         0,         0,         0, r6_m1_r,  r6_m1c.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object
  // Connect Spherical Bridge To Pedestal (y+)
  const r6_b2_ly = R6_BridgeShellR;
  const r6_b2_r = R5_BX / 2.0;
  const r6_b2c = r6_c.add(new Vector4D(0, r6_b2_ly/2.0, 0, 0));
  objects.push(createHypercube(
    new Transform4D([
      [ r6_b2_r,         0,         0,              0,  r6_b2c.x],
      [         0, r6_b2_ly/2.0,         0,              0,  r6_b2c.y],
      [         0,         0, R5_BZ/2.0,              0,  r6_b2c.z],
      [         0,         0,         0, r6_b2_r,  r6_b2c.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object
  // To make the player's life easier, add a monolith at the first bridge entrance
  const r6_m2_r = 2.0;
  const r6_m2_h = 3.0;
  const r6_m2c = r6_c.add(new Vector4D(0, r6_b2_ly, _H + r6_m2_h/2.0, 0));
  objects.push(createHypercube(
    new Transform4D([
      [ r6_m2_r,         0,         0,              0,  r6_m2c.x],
      [         0, r6_m2_r,         0,              0,  r6_m2c.y],
      [         0,         0, r6_m2_h/2.0,              0,  r6_m2c.z],
      [         0,         0,         0, r6_m2_r,  r6_m2c.w],
      [         0,         0,         0,              0,  1]
    ]),
    0x222222
  ));
  objects[objects.length-1].simulate_physics = false; // static object

  // Pedestal
  objects.push(createSphericalBridge(new Transform4D([
        [         0,         0,         0,       R6_PedestalR,  r6_c.x],
        [         0,  R6_PedestalR,         0,              0,  r6_c.y],
        [         0,         0, R6_PedestalHZ,              0,         r6_c.z],
        [  R6_PedestalR,         0,         0,              0,  r6_c.w], // We give this the same rotation as the outer wall to match the discontinuities
        [         0,         0,         0,              0,  1]
    ]),
    0.2, 1.0,
    0x222222
  ));
  // End gem - created by the game manager
}


function the_bargain_floor_heightmap(x, y, w) {
  if (x >= area1xmin && x <= area1xmax && y >= area1ymin && y <= area1ymax && w >= area1wmin && w <= area1wmax) {
    return AREA1_ZH;
  }
  return 0.0;
}

// Check WebGPU support
if (!navigator.gpu) {
  document.body.innerHTML = '<div style="color: red; padding: 20px;">WebGPU is not supported in your browser.</div>';
  throw new Error('WebGPU not supported');
}

// Floor shader with lava lakes
const bargainFloorShader = `
    if (true) {
    let ray_origin_in_world = hypercameraPoseBuffer.tr;
    let ray_direction_in_world = vec4<f32>(
        hypercameraPoseBuffer.r0.x * 1.0 + hypercameraPoseBuffer.r1.x * u + hypercameraPoseBuffer.r2.x * v + hypercameraPoseBuffer.r3.x * l,
        hypercameraPoseBuffer.r0.y * 1.0 + hypercameraPoseBuffer.r1.y * u + hypercameraPoseBuffer.r2.y * v + hypercameraPoseBuffer.r3.y * l,
        hypercameraPoseBuffer.r0.z * 1.0 + hypercameraPoseBuffer.r1.z * u + hypercameraPoseBuffer.r2.z * v + hypercameraPoseBuffer.r3.z * l,
        hypercameraPoseBuffer.r0.w * 1.0 + hypercameraPoseBuffer.r1.w * u + hypercameraPoseBuffer.r2.w * v + hypercameraPoseBuffer.r3.w * l
    );
    let denominator = ray_direction_in_world.z;
    if (abs(denominator) > 1e-6) {
        let t = -ray_origin_in_world.z / denominator;
        if (t > 0.0) {
            let intersect_point = vec4<f32>(
                ray_origin_in_world.x + t * ray_direction_in_world.x,
                ray_origin_in_world.y + t * ray_direction_in_world.y,
                0.0,
                ray_origin_in_world.w + t * ray_direction_in_world.w
            );
            let x = intersect_point.x;
            let y = intersect_point.y;
            let w = intersect_point.w;

            // Check lava regions
            var is_lava = false;

            // Room 5 lava: rectangular region in W
            let r5_cx = f32(${r5_c.x});
            let r5_cy = f32(${r5_c.y});
            let r5_cw = f32(${r5_c.w});
            let r5_hw = f32(${R5_LAVA_WL / 2.0});
            let r5_hx = f32(${R5_DX / 2.0 * 3});
            let r5_hy = f32(${R5_DY / 2.0 * 100});
            if (abs(x - r5_cx) < r5_hx && abs(y - r5_cy) < r5_hy && abs(w - r5_cw) < r5_hw) {
                is_lava = true;
            }

            // Room 6 lava: spherical region
            let r6_cx = f32(${r6_c.x});
            let r6_cy = f32(${r6_c.y});
            let r6_cw = f32(${r6_c.w});
            let r6_r = f32(${R6_LavaR});
            let r6_dx = x - r6_cx;
            let r6_dy = y - r6_cy;
            let r6_dw = w - r6_cw;
            if (r6_dx*r6_dx + r6_dy*r6_dy + r6_dw*r6_dw < r6_r*r6_r) {
                is_lava = true;
            }

            if (is_lava) {
                // Animated lava effect
                let wave1 = sin(x * 0.6 + sim_t * 0.5) * 0.5 + 0.5;
                let wave2 = sin(y * 0.45 - sim_t * 0.3) * 0.5 + 0.5;
                let wave3 = sin(w * 0.54 + sim_t * 0.7) * 0.5 + 0.5;
                let wave = (wave1 + wave2 + wave3) / 3.0;
                var lava_r = 0.8 + 0.2 * wave;
                var lava_g = 0.3 * wave;
                var lava_b = 0.0;

                // Bubbles - two layers at different scales
                var bubble_add = 0.0;

                // Layer 1: small frequent bubbles
                let bc1 = 3.0;
                let b1cx = floor(x / bc1);
                let b1cy = floor(y / bc1);
                let b1cw = floor(w / bc1);
                let b1h1 = fract(sin(b1cx * 127.1 + b1cw * 311.7 + b1cy * 74.7) * 43758.5453);
                let b1h2 = fract(sin(b1cx * 269.5 + b1cw * 183.3 + b1cy * 246.1) * 43758.5453);
                let b1h3 = fract(sin(b1cx * 419.2 + b1cw * 371.9 + b1cy * 519.3) * 43758.5453);
                let b1h4 = fract(sin(b1cx * 547.3 + b1cw * 157.9 + b1cy * 323.7) * 43758.5453);
                let b1x = (b1cx + 0.2 + b1h1 * 0.6) * bc1;
                let b1y = (b1cy + 0.2 + b1h2 * 0.6) * bc1;
                let b1w = (b1cw + 0.2 + b1h3 * 0.6) * bc1;
                let b1per = 3.0 + b1h4 * 7.0;
                let b1ph = fract((sim_t + b1h1 * 100.0) / b1per);
                let b1rad = 0.15 + b1h2 * 0.35;
                let b1d = sqrt((x-b1x)*(x-b1x) + (y-b1y)*(y-b1y) + (w-b1w)*(w-b1w));
                var b1sz = 0.0;
                if (b1ph < 0.3) { b1sz = b1ph / 0.3; }
                else if (b1ph < 0.5) { b1sz = 1.0; }
                else if (b1ph < 0.7) { b1sz = 1.0 - (b1ph - 0.5) / 0.2; }
                let b1er = b1rad * b1sz;
                if (b1d < b1er && b1er > 0.01) {
                    let b1e = b1d / b1er;
                    bubble_add = max(bubble_add, (1.0 - b1e * b1e) * 0.5);
                }

                // Layer 2: larger rare bubbles
                let bc2 = 7.0;
                let b2cx = floor(x / bc2);
                let b2cy = floor(y / bc2);
                let b2cw = floor(w / bc2);
                let b2h1 = fract(sin(b2cx * 213.7 + b2cw * 491.3 + b2cy * 167.1) * 43758.5453);
                let b2h2 = fract(sin(b2cx * 337.9 + b2cw * 259.1 + b2cy * 413.7) * 43758.5453);
                let b2h3 = fract(sin(b2cx * 571.3 + b2cw * 643.7 + b2cy * 389.1) * 43758.5453);
                let b2h4 = fract(sin(b2cx * 691.1 + b2cw * 823.3 + b2cy * 197.9) * 43758.5453);
                let b2x = (b2cx + 0.15 + b2h1 * 0.7) * bc2;
                let b2y = (b2cy + 0.15 + b2h2 * 0.7) * bc2;
                let b2w = (b2cw + 0.15 + b2h3 * 0.7) * bc2;
                let b2per = 5.0 + b2h4 * 10.0;
                let b2ph = fract((sim_t + b2h1 * 100.0) / b2per);
                let b2rad = 0.4 + b2h2 * 0.6;
                let b2d = sqrt((x-b2x)*(x-b2x) + (y-b2y)*(y-b2y) + (w-b2w)*(w-b2w));
                var b2sz = 0.0;
                if (b2ph < 0.3) { b2sz = b2ph / 0.3; }
                else if (b2ph < 0.5) { b2sz = 1.0; }
                else if (b2ph < 0.7) { b2sz = 1.0 - (b2ph - 0.5) / 0.2; }
                let b2er = b2rad * b2sz;
                if (b2d < b2er && b2er > 0.01) {
                    let b2e = b2d / b2er;
                    bubble_add = max(bubble_add, (1.0 - b2e * b2e) * 0.7);
                }

                lava_r = min(1.0, lava_r + bubble_add);
                lava_g = min(1.0, lava_g + bubble_add * 0.7);
                lava_b = min(0.3, lava_b + bubble_add * 0.15);

                best_voxel.r = lava_r;
                best_voxel.g = lava_g;
                best_voxel.b = lava_b;
            } else {
                // Dark checkerboard floor
                let checker_size = 5.0;
                let check_x = floor(x / checker_size);
                let check_y = floor(y / checker_size);
                let check_w = floor(w / checker_size);
                let is_white = (i32(check_x) + i32(check_y) + i32(check_w)) % 2 == 0;
                if (is_white) {
                    best_voxel.r = 0.15;
                    best_voxel.g = 0.15;
                    best_voxel.b = 0.15;
                } else {
                    best_voxel.r = 0.05;
                    best_voxel.g = 0.05;
                    best_voxel.b = 0.05;
                }
            }
            best_voxel.a = 0.2;
            best_voxel.s = t;
        }
    }
    }
`;

// PoIs
let poIs = {
  roomCenters: [
    {name: "Room 1", pos: r1c},
    {name: "Room 2", pos: r2c},
    {name: "Corridor 3", pos: c3c},
    {name: "Room 3", pos: r3_entrance},
    {name: "Corridor 6", pos: c6_c},
    {name: "Room 4", pos: r4_entrance},
    {name: "Corridor 7", pos: c7_c},
    {name: "Room 5", pos: r5_entrance},
    {name: "Room 6", pos: r6_entrance},
  ],
  shadeSpawns: [
    c4c.add(new Vector4D(0, 0, 0, C4L/2.0)),
    c5_monster1,
    c5_monster2,
    pill_ref,
    pill_ref.add(new Vector4D(5, 0, 0, 5)),
    pill_ref.add(new Vector4D(-5, 0, 0, 5)),
  ],
  crawlerSpawns: [
    {
      pos: c4c.add(new Vector4D(0, 0, _H, -C4L/2.0)),
      volumeMin: c4c.add(new Vector4D(-c4r/2, -c4r/2, _H, -C4L/2.0)),
      volumeMax: c4c.add(new Vector4D(c4r/2, c4r/2, _H, -C4L/2.0)),
    },
    {
      pos: w5_c.add(new Vector4D(0, 0, _H, 0)),
      volumeMin: new Vector4D(w5_c.x - R3XL / 2.0, w5_c.y - w5_yl / 2.0 + 1, _H, w5_c.w),
      volumeMax: new Vector4D(w5_c.x + R3XL / 2.0, w5_c.y + w5_yl / 2.0 - 1, _H, w5_c.w),
    },
    {
      pos: w4_c.add(new Vector4D(0, 0, _H, 0)),
      volumeMin: new Vector4D(w4_c.x - R3XL / 2.0, w4_c.y, _H, w4_c.w),
      volumeMax: new Vector4D(w4_c.x + R3XL / 2.0, w4_c.y, _H, w4_c.w + w4_wl / 2.0),
    },

  ],
  ophaneSpawns: [
    {
      pos: r6_c.add(new Vector4D(0, 0, _H+8, 0)),
      volumeCenter: r6_c,
      volumeRadius: R6_BridgeShellR,
    },
  ],
  room6Center: r6_c,
  room6OuterRadius: R6_R,
  room6InnerRadius: R6_BridgeShellR,
  magicWallIndex: magicWallIndex,
  bossEntranceWallIdx: bossEntranceWallIdx,
  bargainerPos: new Vector4D(R2X - R2R + 1.7, 0, 1.0 + AREA1_ZH, 0),
  bargainerIndex: bargainerIndex,
  room2MagicWallCenter: r2_magicwall1_c,
  room2MagicWallIdx: r2_magicwall1_idx,
  tutorialZones: [
    {
      id: "room1_welcome",
      aabbMin: new Vector4D(-R1HR + 1, -R1HR + 1, AREA1_ZH - 1, -R1HW/2 + 1),
      aabbMax: new Vector4D(R1HR - 1, R1HR - 1, AREA1_ZH + _H + 1, R1HW/2 - 1),
      requireBargain: false,
      title: "HYPERHELL",
      text: "This is a Demo of HYPERHELL,<br>the first 4D shooter of its kind.<br><br><u>Controls</u><br>Use WASD keys to move. Left-click + drag to look around (or J/L keys).",
    },
    {
      id: "room2_controls",
      aabbMin: new Vector4D(R2X - R2R + 1, -R2R + 1, AREA1_ZH - 1, -R2R + 1),
      aabbMax: new Vector4D(R2X + R2R - 1, R2R - 1, AREA1_ZH + 1, R2R - 1),
      requireBargain: true,
      title: "4D MOVEMENT",
      text: "You wake up feeling... different.<br><br><u>Controls</u><br>You can now move in the 4th dimension.<br>Left click + drag up/down to rotate your view in 4D, and find an exit.",
    },
    {
      id: "corridor3_shooting",
      aabbMin: c3c.add(new Vector4D(-c3r/2, -c3r/2, -_H, -1)),
      aabbMax: c3c.add(new Vector4D(c3r/2, c3r/2, _H, 1)),
      requireBargain: false,
      title: "COMBAT",
      text: "Enemies can move in 4 dimensions,<br>but so can you.<br><br>Press Q/E to step sideways in the 4th dimension, and Space to shoot.",
    },
    {
      id: "corridor4_unblink",
      aabbMin: c4c.add(new Vector4D(-c4r/2, -c4r/2, -_H, -1 -4)),
      aabbMax: c4c.add(new Vector4D(c4r/2, c4r/2, _H, 1 -4)),
      requireBargain: false,
      title: "UNBLINK",
      text: "Open your Eye...<br><br>Press and hold R to Unblink,<br>allowing you to see more of the 4th dimension.<br>While unblinking, some enemies are easier to shoot.",
    },
  ],
};


const main_canvas = document.getElementById('canvas');
let custom_scene = {
    visibleHyperobjects: objects,
    mainCanvas: main_canvas,
    floor_heightmap: the_bargain_floor_heightmap,
    floorShader: bargainFloorShader
};

// GameManager
// Player controls, NPCs, Monsters, etc
let gameManager = new TheBargainManager(custom_scene, poIs);
custom_scene.gameManager = gameManager;


runHyperengine(custom_scene).catch(err => {
  console.error(err);
  document.body.innerHTML += '<div style="color: red; padding: 20px;">Error: ' + err.message + '</div>';
});
</script>
</body>
</html>